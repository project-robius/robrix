Warning: can't set `hex_literal_case = Upper`, unstable features are only available in nightly channel.
Warning: can't set `fn_single_line = true`, unstable features are only available in nightly channel.
Warning: can't set `imports_granularity = Crate`, unstable features are only available in nightly channel.
Warning: can't set `group_imports = StdExternalCrate`, unstable features are only available in nightly channel.
Warning: can't set `reorder_impl_items = false`, unstable features are only available in nightly channel.
Warning: can't set `spaces_around_ranges = true`, unstable features are only available in nightly channel.
Warning: can't set `blank_lines_upper_bound = 3`, unstable features are only available in nightly channel.
Warning: can't set `inline_attribute_width = 50`, unstable features are only available in nightly channel.
Warning: can't set `format_generated_files = false`, unstable features are only available in nightly channel.
Warning: can't set `error_on_line_overflow = false`, unstable features are only available in nightly channel.
Diff in /app/src/app.rs:4:

 use std::{cell::RefCell, collections::HashMap};
 use makepad_widgets::*;
[31m-use matrix_sdk::{RoomState, ruma::{OwnedRoomId, RoomId}};
[m[32m+use matrix_sdk::{
[m[32m+    RoomState,
[m[32m+    ruma::{OwnedRoomId, RoomId},
[m[32m+};
[m use serde::{Deserialize, Serialize};
 use crate::{
[31m-    avatar_cache::clear_avatar_cache, home::{
[m[31m-        event_source_modal::{EventSourceModalAction, EventSourceModalWidgetRefExt}, invite_modal::{InviteModalAction, InviteModalWidgetRefExt}, main_desktop_ui::MainDesktopUiAction, navigation_tab_bar::{NavigationBarAction, SelectedTab}, new_message_context_menu::NewMessageContextMenuWidgetRefExt, room_context_menu::RoomContextMenuWidgetRefExt, room_screen::{InviteAction, MessageAction, clear_timeline_states}, rooms_list::{RoomsListAction, RoomsListRef, RoomsListUpdate, clear_all_invited_rooms, enqueue_rooms_list_update}
[m[31m-    }, join_leave_room_modal::{
[m[31m-        JoinLeaveModalKind, JoinLeaveRoomModalAction, JoinLeaveRoomModalWidgetRefExt
[m[31m-    }, login::login_screen::LoginAction, logout::logout_confirm_modal::{LogoutAction, LogoutConfirmModalAction, LogoutConfirmModalWidgetRefExt}, persistence, profile::user_profile_cache::clear_user_profile_cache, room::BasicRoomDetails, shared::{callout_tooltip::{
[m[31m-        CalloutTooltipWidgetRefExt,
[m[31m-        TooltipAction,
[m[31m-    }, confirmation_modal::{ConfirmationModalContent, ConfirmationModalWidgetRefExt}, image_viewer::{ImageViewerAction, LoadState}, popup_list::{PopupKind, enqueue_popup_notification}}, sliding_sync::{DirectMessageRoomAction, MatrixRequest, current_user_id, submit_async_request}, utils::RoomNameId, verification::VerificationAction, verification_modal::{
[m[31m-        VerificationModalAction,
[m[31m-        VerificationModalWidgetRefExt,
[m[31m-    }
[m[32m+    avatar_cache::clear_avatar_cache,
[m[32m+    home::{
[m[32m+        event_source_modal::{EventSourceModalAction, EventSourceModalWidgetRefExt},
[m[32m+        invite_modal::{InviteModalAction, InviteModalWidgetRefExt},
[m[32m+        main_desktop_ui::MainDesktopUiAction,
[m[32m+        navigation_tab_bar::{NavigationBarAction, SelectedTab},
[m[32m+        new_message_context_menu::NewMessageContextMenuWidgetRefExt,
[m[32m+        room_context_menu::RoomContextMenuWidgetRefExt,
[m[32m+        room_screen::{InviteAction, MessageAction, clear_timeline_states},
[m[32m+        rooms_list::{
[m[32m+            RoomsListAction, RoomsListRef, RoomsListUpdate, clear_all_invited_rooms,
[m[32m+            enqueue_rooms_list_update,
[m[32m+        },
[m[32m+    },
[m[32m+    join_leave_room_modal::{
[m[32m+        JoinLeaveModalKind, JoinLeaveRoomModalAction, JoinLeaveRoomModalWidgetRefExt,
[m[32m+    },
[m[32m+    login::login_screen::LoginAction,
[m[32m+    logout::logout_confirm_modal::{
[m[32m+        LogoutAction, LogoutConfirmModalAction, LogoutConfirmModalWidgetRefExt,
[m[32m+    },
[m[32m+    persistence,
[m[32m+    profile::user_profile_cache::clear_user_profile_cache,
[m[32m+    room::BasicRoomDetails,
[m[32m+    shared::{
[m[32m+        callout_tooltip::{CalloutTooltipWidgetRefExt, TooltipAction},
[m[32m+        confirmation_modal::{ConfirmationModalContent, ConfirmationModalWidgetRefExt},
[m[32m+        image_viewer::{ImageViewerAction, LoadState},
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    },
[m[32m+    sliding_sync::{DirectMessageRoomAction, MatrixRequest, current_user_id, submit_async_request},
[m[32m+    utils::RoomNameId,
[m[32m+    verification::VerificationAction,
[m[32m+    verification_modal::{VerificationModalAction, VerificationModalWidgetRefExt},
[m };

 live_design! {
Diff in /app/src/app.rs:72:
                     }
                     draw_bg: {color: #F3F3F3},
                 }
[31m-
[m
[32m+
[m                 body = {
                     padding: 0,

Diff in /app/src/app.rs:101:
                                 image_viewer_modal_inner = <ImageViewer> {}
                             }
                         }
[31m-
[m[32m+
[m                         // Context menus should be shown in front of other UI elements,
                         // but behind verification modals.
                         new_message_context_menu = <NewMessageContextMenu> { }
Diff in /app/src/app.rs:187:

 #[derive(Live)]
 pub struct App {
[31m-    #[live] ui: WidgetRef,
[m[32m+    #[live]
[m[32m+    ui: WidgetRef,
[m     /// The top-level app state, shared across various parts of the app.
[31m-    #[rust] app_state: AppState,
[m[32m+    #[rust]
[m[32m+    app_state: AppState,
[m     /// The details of a room we're waiting on to be loaded so that we can navigate to it.
     /// This can be either a room we're waiting to join, or one we're waiting to be invited to.
     /// Also includes an optional room ID to be closed once the awaited room has been loaded.
Diff in /app/src/app.rs:196:
[31m-    #[rust] waiting_to_navigate_to_room: Option<(BasicRoomDetails, Option<OwnedRoomId>)>,
[m[32m+    #[rust]
[m[32m+    waiting_to_navigate_to_room: Option<(BasicRoomDetails, Option<OwnedRoomId>)>,
[m }

 impl LiveRegister for App {
Diff in /app/src/app.rs:213:
         // and link it to the real `tsp_enabled` DSL namespace, which contains real TSP widgets.
         // If the `tsp` feature is not enabled, link the "tsp_link" DSL namespace
         // to the `tsp_disabled` DSL namespace instead, which defines dummy placeholder widgets.
[31m-        #[cfg(feature = "tsp")] {
[m[32m+        #[cfg(feature = "tsp")]
[m[32m+        {
[m             crate::tsp::live_design(cx);
             cx.link(id!(tsp_link), id!(tsp_enabled));
         }
Diff in /app/src/app.rs:220:
[31m-        #[cfg(not(feature = "tsp"))] {
[m[32m+        #[cfg(not(feature = "tsp"))]
[m[32m+        {
[m             crate::tsp_dummy::live_design(cx);
             cx.link(id!(tsp_link), id!(tsp_disabled));
         }
Diff in /app/src/app.rs:251:
         let _ = tracing_subscriber::fmt::try_init();

         // Override Makepad's new default-JSON logger. We just want regular formatting.
[31m-        fn regular_log(file_name: &str, line_start: u32, column_start: u32, _line_end: u32, _column_end: u32, message: String, level: LogLevel) {
[m[32m+        fn regular_log(
[m[32m+            file_name: &str,
[m[32m+            line_start: u32,
[m[32m+            column_start: u32,
[m[32m+            _line_end: u32,
[m[32m+            _column_end: u32,
[m[32m+            message: String,
[m[32m+            level: LogLevel,
[m[32m+        ) {
[m             let l = match level {
[31m-                LogLevel::Panic   => "[!]",
[m[31m-                LogLevel::Error   => "[E]",
[m[32m+                LogLevel::Panic => "[!]",
[m[32m+                LogLevel::Error => "[E]",
[m                 LogLevel::Warning => "[W]",
[31m-                LogLevel::Log     => "[I]",
[m[31m-                LogLevel::Wait    => "[.]",
[m[32m+                LogLevel::Log => "[I]",
[m[32m+                LogLevel::Wait => "[.]",
[m             };
[31m-            println!("{l} {file_name}:{}:{}: {message}", line_start + 1, column_start + 1);
[m[32m+            println!(
[m[32m+                "{l} {file_name}:{}:{}: {message}",
[m[32m+                line_start + 1,
[m[32m+                column_start + 1
[m[32m+            );
[m         }
         *LOG_WITH_LEVEL.write().unwrap() = regular_log;

Diff in /app/src/app.rs:277:
         log!("App::Startup: starting matrix sdk loop");
         let _tokio_rt_handle = crate::sliding_sync::start_matrix_tokio().unwrap();

[31m-        #[cfg(feature = "tsp")] {
[m[32m+        #[cfg(feature = "tsp")]
[m[32m+        {
[m             log!("App::Startup: initializing TSP (Trust Spanning Protocol) module.");
             crate::tsp::tsp_init(_tokio_rt_handle).unwrap();
         }
Diff in /app/src/app.rs:284:
     }

     fn handle_actions(&mut self, cx: &mut Cx, actions: &Actions) {
[31m-        let invite_confirmation_modal_inner = self.ui.confirmation_modal(ids!(invite_confirmation_modal_inner));
[m[32m+        let invite_confirmation_modal_inner = self
[m[32m+            .ui
[m[32m+            .confirmation_modal(ids!(invite_confirmation_modal_inner));
[m         if let Some(_accepted) = invite_confirmation_modal_inner.closed(actions) {
             self.ui.modal(ids!(invite_confirmation_modal)).close(cx);
         }
Diff in /app/src/app.rs:291:

[31m-        let delete_confirmation_modal_inner = self.ui.confirmation_modal(ids!(delete_confirmation_modal_inner));
[m[32m+        let delete_confirmation_modal_inner = self
[m[32m+            .ui
[m[32m+            .confirmation_modal(ids!(delete_confirmation_modal_inner));
[m         if let Some(_accepted) = delete_confirmation_modal_inner.closed(actions) {
             self.ui.modal(ids!(delete_confirmation_modal)).close(cx);
         }
Diff in /app/src/app.rs:296:

[31m-        let positive_confirmation_modal_inner = self.ui.confirmation_modal(ids!(positive_confirmation_modal_inner));
[m[32m+        let positive_confirmation_modal_inner = self
[m[32m+            .ui
[m[32m+            .confirmation_modal(ids!(positive_confirmation_modal_inner));
[m         if let Some(_accepted) = positive_confirmation_modal_inner.closed(actions) {
             self.ui.modal(ids!(positive_confirmation_modal)).close(cx);
         }
Diff in /app/src/app.rs:302:
         for action in actions {
             match action.downcast_ref() {
                 Some(LogoutConfirmModalAction::Open) => {
[31m-                    self.ui.logout_confirm_modal(ids!(logout_confirm_modal_inner)).reset_state(cx);
[m[32m+                    self.ui
[m[32m+                        .logout_confirm_modal(ids!(logout_confirm_modal_inner))
[m[32m+                        .reset_state(cx);
[m                     self.ui.modal(ids!(logout_confirm_modal)).open(cx);
                     continue;
[31m-                },
[m[32m+                }
[m                 Some(LogoutConfirmModalAction::Close { was_internal, .. }) => {
                     if *was_internal {
                         self.ui.modal(ids!(logout_confirm_modal)).close(cx);
Diff in /app/src/app.rs:312:
                     }
                     continue;
[31m-                },
[m[32m+                }
[m                 _ => {}
             }

Diff in /app/src/app.rs:323:
                     self.ui.redraw(cx);
                     continue;
                 }
[31m-                Some(LogoutAction::ClearAppState { on_clear_appstate }) =>  {
[m[31m-                    // Clear user profile cache, invited_rooms timeline states
[m[32m+                Some(LogoutAction::ClearAppState { on_clear_appstate }) => {
[m[32m+                    // Clear user profile cache, invited_rooms timeline states
[m                     clear_all_app_state(cx);
                     // Reset all app state to its default.
                     self.app_state = Default::default();
Diff in /app/src/app.rs:343:
             }

             // Handle an action requesting to open the new message context menu.
[31m-            if let MessageAction::OpenMessageContextMenu { details, abs_pos } = action.as_widget_action().cast() {
[m[32m+            if let MessageAction::OpenMessageContextMenu { details, abs_pos } =
[m[32m+                action.as_widget_action().cast()
[m[32m+            {
[m                 self.ui.callout_tooltip(ids!(app_tooltip)).hide(cx);
[31m-                let new_message_context_menu = self.ui.new_message_context_menu(ids!(new_message_context_menu));
[m[32m+                let new_message_context_menu = self
[m[32m+                    .ui
[m[32m+                    .new_message_context_menu(ids!(new_message_context_menu));
[m                 let expected_dimensions = new_message_context_menu.show(cx, details);
                 // Ensure the context menu does not spill over the window's bounds.
                 let rect = self.ui.window(ids!(main_window)).area().rect(cx);
Diff in /app/src/app.rs:352:
                 let pos_x = min(abs_pos.x, rect.size.x - expected_dimensions.x);
                 let pos_y = min(abs_pos.y, rect.size.y - expected_dimensions.y);
[31m-                new_message_context_menu.apply_over(cx, live! {
[m[31m-                    main_content = { margin: { left: (pos_x), top: (pos_y) } }
[m[31m-                });
[m[32m+                new_message_context_menu.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        main_content = { margin: { left: (pos_x), top: (pos_y) } }
[m[32m+                    },
[m[32m+                );
[m                 self.ui.redraw(cx);
                 continue;
             }
Diff in /app/src/app.rs:360:

             // Handle an action requesting to open the room context menu.
[31m-            if let RoomsListAction::OpenRoomContextMenu { details, pos } = action.as_widget_action().cast() {
[m[32m+            if let RoomsListAction::OpenRoomContextMenu { details, pos } =
[m[32m+                action.as_widget_action().cast()
[m[32m+            {
[m                 self.ui.callout_tooltip(ids!(app_tooltip)).hide(cx);
                 let room_context_menu = self.ui.room_context_menu(ids!(room_context_menu));
                 let expected_dimensions = room_context_menu.show(cx, details);
Diff in /app/src/app.rs:367:
                 let rect = self.ui.window(ids!(main_window)).area().rect(cx);
                 let pos_x = min(pos.x, rect.size.x - expected_dimensions.x);
                 let pos_y = min(pos.y, rect.size.y - expected_dimensions.y);
[31m-                room_context_menu.apply_over(cx, live! {
[m[31m-                    main_content = { margin: { left: (pos_x), top: (pos_y) } }
[m[31m-                });
[m[32m+                room_context_menu.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        main_content = { margin: { left: (pos_x), top: (pos_y) } }
[m[32m+                    },
[m[32m+                );
[m                 self.ui.redraw(cx);
                 continue;
             }
Diff in /app/src/app.rs:391:
                 cx.widget_action(
                     self.ui.widget_uid(),
                     &HeapLiveIdPath::default(),
[31m-                    StackNavigationAction::Push(id!(main_content_view))
[m[32m+                    StackNavigationAction::Push(id!(main_content_view)),
[m                 );
                 self.ui.redraw(cx);
                 continue;
Diff in /app/src/app.rs:426:
                     cx.action(MainDesktopUiAction::LoadDockFromAppState);
                     continue;
                 }
[31m-                Some(AppStateAction::NavigateToRoom { room_to_close, destination_room }) => {
[m[32m+                Some(AppStateAction::NavigateToRoom {
[m[32m+                    room_to_close,
[m[32m+                    destination_room,
[m[32m+                }) => {
[m                     self.navigate_to_room(cx, room_to_close.as_ref(), destination_room);
                     continue;
                 }
Diff in /app/src/app.rs:433:
                 // If we successfully loaded a room that we were waiting on,
                 // we can now navigate to it and optionally close a previous room.
[31m-                Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, .. }) if
[m[31m-                    self.waiting_to_navigate_to_room.as_ref()
[m[32m+                Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, .. })
[m[32m+                    if self
[m[32m+                        .waiting_to_navigate_to_room
[m[32m+                        .as_ref()
[m                         .is_some_and(|(dr, _)| dr.room_id() == room_name_id.room_id()) =>
                 {
                     log!("Loaded awaited room {room_name_id:?}, navigating to it now...");
Diff in /app/src/app.rs:440:
[31m-                    if let Some((dest_room, room_to_close)) = self.waiting_to_navigate_to_room.take() {
[m[32m+                    if let Some((dest_room, room_to_close)) =
[m[32m+                        self.waiting_to_navigate_to_room.take()
[m[32m+                    {
[m                         self.navigate_to_room(cx, room_to_close.as_ref(), &dest_room);
                     }
                     continue;
Diff in /app/src/app.rs:447:

             // Handle actions for showing or hiding the tooltip.
             match action.as_widget_action().cast() {
[31m-                TooltipAction::HoverIn { text, widget_rect, options } => {
[m[32m+                TooltipAction::HoverIn {
[m[32m+                    text,
[m[32m+                    widget_rect,
[m[32m+                    options,
[m[32m+                } => {
[m                     // Don't show any tooltips if the message context menu is currently shown.
[31m-                    if self.ui.new_message_context_menu(ids!(new_message_context_menu)).is_currently_shown(cx) {
[m[32m+                    if self
[m[32m+                        .ui
[m[32m+                        .new_message_context_menu(ids!(new_message_context_menu))
[m[32m+                        .is_currently_shown(cx)
[m[32m+                    {
[m                         self.ui.callout_tooltip(ids!(app_tooltip)).hide(cx);
[32m+                    } else {
[m[32m+                        self.ui
[m[32m+                            .callout_tooltip(ids!(app_tooltip))
[m[32m+                            .show_with_options(cx, &text, widget_rect, options);
[m                     }
[31m-                    else {
[m[31m-                        self.ui.callout_tooltip(ids!(app_tooltip)).show_with_options(
[m[31m-                            cx,
[m[31m-                            &text,
[m[31m-                            widget_rect,
[m[31m-                            options,
[m[31m-                        );
[m[31m-                    }
[m                     continue;
                 }
                 TooltipAction::HoverOut => {
Diff in /app/src/app.rs:492:
             //
             // Note: other verification actions are handled by the verification modal itself.
             if let Some(VerificationAction::RequestReceived(state)) = action.downcast_ref() {
[31m-                self.ui.verification_modal(ids!(verification_modal_inner))
[m[32m+                self.ui
[m[32m+                    .verification_modal(ids!(verification_modal_inner))
[m                     .initialize_with_data(cx, state.clone());
                 self.ui.modal(ids!(verification_modal)).open(cx);
                 continue;
Diff in /app/src/app.rs:513:
                 _ => {}
             }
             // Handle actions to open/close the TSP verification modal.
[31m-            #[cfg(feature = "tsp")] {
[m[32m+            #[cfg(feature = "tsp")]
[m[32m+            {
[m                 use std::ops::Deref;
[31m-                use crate::tsp::{tsp_verification_modal::{TspVerificationModalAction, TspVerificationModalWidgetRefExt}, TspIdentityAction};
[m[32m+                use crate::tsp::{
[m[32m+                    tsp_verification_modal::{
[m[32m+                        TspVerificationModalAction, TspVerificationModalWidgetRefExt,
[m[32m+                    },
[m[32m+                    TspIdentityAction,
[m[32m+                };
[m
[31m-                if let Some(TspIdentityAction::ReceivedDidAssociationRequest { details, wallet_db }) = action.downcast_ref() {
[m[31m-                    self.ui.tsp_verification_modal(ids!(tsp_verification_modal_inner))
[m[32m+                if let Some(TspIdentityAction::ReceivedDidAssociationRequest {
[m[32m+                    details,
[m[32m+                    wallet_db,
[m[32m+                }) = action.downcast_ref()
[m[32m+                {
[m[32m+                    self.ui
[m[32m+                        .tsp_verification_modal(ids!(tsp_verification_modal_inner))
[m                         .initialize_with_details(cx, details.clone(), wallet_db.deref().clone());
                     self.ui.modal(ids!(tsp_verification_modal)).open(cx);
                     continue;
Diff in /app/src/app.rs:530:
             }

             // Handle a request to show the invite confirmation modal.
[31m-            if let Some(InviteAction::ShowInviteConfirmationModal(content_opt)) = action.downcast_ref() {
[m[32m+            if let Some(InviteAction::ShowInviteConfirmationModal(content_opt)) =
[m[32m+                action.downcast_ref()
[m[32m+            {
[m                 if let Some(content) = content_opt.borrow_mut().take() {
                     invite_confirmation_modal_inner.show(cx, content);
                     self.ui.modal(ids!(invite_confirmation_modal)).open(cx);
Diff in /app/src/app.rs:539:
             }

             // Handle a request to show the generic positive confirmation modal.
[31m-            if let Some(PositiveConfirmationModalAction::Show(content_opt)) = action.downcast_ref() {
[m[32m+            if let Some(PositiveConfirmationModalAction::Show(content_opt)) = action.downcast_ref()
[m[32m+            {
[m                 if let Some(content) = content_opt.borrow_mut().take() {
                     positive_confirmation_modal_inner.show(cx, content);
                     self.ui.modal(ids!(positive_confirmation_modal)).open(cx);
Diff in /app/src/app.rs:550:
             // Handle a request to show the delete confirmation modal.
             if let Some(ConfirmDeleteAction::Show(content_opt)) = action.downcast_ref() {
                 if let Some(content) = content_opt.borrow_mut().take() {
[31m-                    self.ui.confirmation_modal(ids!(delete_confirmation_modal_inner)).show(cx, content);
[m[32m+                    self.ui
[m[32m+                        .confirmation_modal(ids!(delete_confirmation_modal_inner))
[m[32m+                        .show(cx, content);
[m                     self.ui.modal(ids!(delete_confirmation_modal)).open(cx);
                 }
                 continue;
Diff in /app/src/app.rs:559:
             // Handle InviteModalAction to open/close the invite modal.
             match action.downcast_ref() {
                 Some(InviteModalAction::Open(room_name_id)) => {
[31m-                    self.ui.invite_modal(ids!(invite_modal_inner)).show(cx, room_name_id.clone());
[m[31m-                    self.ui.modal(ids!(invite_modal)).open(cx);
[m[32m+                    self.ui
[m[32m+                        .invite_modal(ids!(invite_modal_inner))
[m[32m+                        .show(cx, room_name_id.clone());
[m[32m+                    self.ui.modal(ids!(invite_modal)).open(cx);
[m                     continue;
                 }
                 Some(InviteModalAction::Close) => {
Diff in /app/src/app.rs:572:

             // Handle EventSourceModalAction to open/close the event source modal.
             match action.downcast_ref() {
[31m-                Some(EventSourceModalAction::Open { room_id, event_id, original_json }) => {
[m[31m-                    self.ui.event_source_modal(ids!(event_source_modal_inner))
[m[32m+                Some(EventSourceModalAction::Open {
[m[32m+                    room_id,
[m[32m+                    event_id,
[m[32m+                    original_json,
[m[32m+                }) => {
[m[32m+                    self.ui
[m[32m+                        .event_source_modal(ids!(event_source_modal_inner))
[m                         .show(cx, room_id.clone(), event_id.clone(), original_json.clone());
                     self.ui.modal(ids!(event_source_modal)).open(cx);
                     continue;
Diff in /app/src/app.rs:588:
             // Handle DirectMessageRoomActions
             match action.downcast_ref() {
                 Some(DirectMessageRoomAction::FoundExisting { room_name_id, .. }) => {
[31m-                    self.navigate_to_room(cx, None, &BasicRoomDetails::RoomId(room_name_id.clone()));
[m[32m+                    self.navigate_to_room(
[m[32m+                        cx,
[m[32m+                        None,
[m[32m+                        &BasicRoomDetails::RoomId(room_name_id.clone()),
[m[32m+                    );
[m                 }
                 Some(DirectMessageRoomAction::DidNotExist { user_profile }) => {
                     let user_profile = user_profile.clone();
Diff in /app/src/app.rs:596:
                         Some(un) if !un.is_empty() => format!(
                             "You don't have an existing direct message room with {} ({}).\n\n\
                             Would you like to create one now?",
[31m-                            un,
[m[31m-                            user_profile.user_id,
[m[32m+                            un, user_profile.user_id,
[m                         ),
                         _ => format!(
                             "You don't have an existing direct message room with {}.\n\n\
Diff in /app/src/app.rs:627:
                     );
                     self.ui.modal(ids!(positive_confirmation_modal)).open(cx);
                 }
[31m-                Some(DirectMessageRoomAction::FailedToCreate { user_profile, error }) => {
[m[32m+                Some(DirectMessageRoomAction::FailedToCreate {
[m[32m+                    user_profile,
[m[32m+                    error,
[m[32m+                }) => {
[m                     enqueue_popup_notification(
[31m-                        format!("Failed to create a new DM room with {}.\n\nError: {error}", user_profile.displayable_name()),
[m[32m+                        format!(
[m[32m+                            "Failed to create a new DM room with {}.\n\nError: {error}",
[m[32m+                            user_profile.displayable_name()
[m[32m+                        ),
[m                         PopupKind::Error,
                         None,
                     );
Diff in /app/src/app.rs:636:
                 }
                 Some(DirectMessageRoomAction::NewlyCreated { room_name_id, .. }) => {
[31m-                    self.navigate_to_room(cx, None, &BasicRoomDetails::RoomId(room_name_id.clone()));
[m[32m+                    self.navigate_to_room(
[m[32m+                        cx,
[m[32m+                        None,
[m[32m+                        &BasicRoomDetails::RoomId(room_name_id.clone()),
[m[32m+                    );
[m                 }
                 _ => {}
             }
Diff in /app/src/app.rs:644:
 }

 /// Clears all thread-local UI caches (user profiles, invited rooms, and timeline states).
[31m-/// The `cx` parameter ensures that these thread-local caches are cleared on the main UI thread,
[m[32m+/// The `cx` parameter ensures that these thread-local caches are cleared on the main UI thread,
[m fn clear_all_app_state(cx: &mut Cx) {
     clear_user_profile_cache(cx);
     clear_all_invited_rooms(cx);
Diff in /app/src/app.rs:665:
                     error!("Failed to save app state. Error: {e}");
                 }
             }
[31m-            #[cfg(feature = "tsp")] {
[m[32m+            #[cfg(feature = "tsp")]
[m[32m+            {
[m                 // Save the TSP wallet state, if it exists, with a 3-second timeout.
                 let tsp_state = std::mem::take(&mut *crate::tsp::tsp_state_ref().lock().unwrap());
                 let res = crate::sliding_sync::block_on_async_with_timeout(
Diff in /app/src/app.rs:672:
                     Some(std::time::Duration::from_secs(3)),
                     async move {
                         match tsp_state.close_and_serialize().await {
[31m-                            Ok(saved_state) => match persistence::save_tsp_state_async(saved_state).await {
[m[31m-                                Ok(_) => { }
[m[31m-                                Err(e) => error!("Failed to save TSP wallet state. Error: {e}"),
[m[32m+                            Ok(saved_state) => {
[m[32m+                                match persistence::save_tsp_state_async(saved_state).await {
[m[32m+                                    Ok(_) => {}
[m[32m+                                    Err(e) => error!("Failed to save TSP wallet state. Error: {e}"),
[m[32m+                                }
[m                             }
[31m-                            Err(e) => error!("Failed to close and serialize TSP wallet state. Error: {e}"),
[m[32m+                            Err(e) => {
[m[32m+                                error!("Failed to close and serialize TSP wallet state. Error: {e}")
[m[32m+                            }
[m                         }
                     },
                 );
Diff in /app/src/app.rs:683:
                 if let Err(_e) = res {
[31m-                    error!("Failed to save TSP wallet state before app shutdown. Error: Timed Out.");
[m[32m+                    error!(
[m[32m+                        "Failed to save TSP wallet state before app shutdown. Error: Timed Out."
[m[32m+                    );
[m                 }
             }
         }
Diff in /app/src/app.rs:688:
[31m-
[m[32m+
[m         // Forward events to the MatchEvent trait implementation.
         self.match_event(cx, event);
         let scope = &mut Scope::with_data(&mut self.app_state);
Diff in /app/src/app.rs:733:
                 .modal(ids!(login_screen_view.login_screen.login_status_modal))
                 .close(cx);
         }
[31m-        self.ui.view(ids!(login_screen_view)).set_visible(cx, show_login);
[m[31m-        self.ui.view(ids!(home_screen_view)).set_visible(cx, !show_login);
[m[32m+        self.ui
[m[32m+            .view(ids!(login_screen_view))
[m[32m+            .set_visible(cx, show_login);
[m[32m+        self.ui
[m[32m+            .view(ids!(home_screen_view))
[m[32m+            .set_visible(cx, !show_login);
[m     }

     /// Navigates to the given `destination_room`, optionally closing the `room_to_close`.
Diff in /app/src/app.rs:754:
                     &HeapLiveIdPath::default(),
                     DockAction::TabCloseWasPressed(tab_id),
                 );
[31m-                enqueue_rooms_list_update(RoomsListUpdate::HideRoom { room_id: to_close.clone() });
[m[32m+                enqueue_rooms_list_update(RoomsListUpdate::HideRoom {
[m[32m+                    room_id: to_close.clone(),
[m[32m+                });
[m             }
         });

Diff in /app/src/app.rs:761:
         let destination_room_id = destination_room.room_id();
[31m-        let new_selected_room = match cx.get_global::<RoomsListRef>().get_room_state(destination_room_id) {
[m[32m+        let new_selected_room = match cx
[m[32m+            .get_global::<RoomsListRef>()
[m[32m+            .get_room_state(destination_room_id)
[m[32m+        {
[m             Some(RoomState::Joined) => SelectedRoom::JoinedRoom {
                 room_name_id: destination_room.room_name_id().clone(),
             },
Diff in /app/src/app.rs:768:
             },
             // If the destination room is not yet loaded, show a join modal.
             _ => {
[31m-                log!("Destination room {:?} not loaded, showing join modal...", destination_room.room_name_id());
[m[31m-                self.waiting_to_navigate_to_room = Some((
[m[31m-                    destination_room.clone(),
[m[31m-                    room_to_close.cloned(),
[m[31m-                ));
[m[32m+                log!(
[m[32m+                    "Destination room {:?} not loaded, showing join modal...",
[m[32m+                    destination_room.room_name_id()
[m[32m+                );
[m[32m+                self.waiting_to_navigate_to_room =
[m[32m+                    Some((destination_room.clone(), room_to_close.cloned()));
[m                 cx.action(JoinLeaveRoomModalAction::Open {
                     kind: JoinLeaveModalKind::JoinRoom {
                         details: destination_room.clone(),
Diff in /app/src/app.rs:784:
             }
         };

[31m-
[m[31m-        log!("Navigating to destination room {:?}, closing room {:?}",
[m[32m+        log!(
[m[32m+            "Navigating to destination room {:?}, closing room {:?}",
[m             destination_room.room_name_id(),
             room_to_close,
         );
Diff in /app/src/app.rs:849:
     pub selected_room: Option<SelectedRoom>,
 }

[31m-
[m /// Represents a room currently or previously selected by the user.
 ///
 /// One `SelectedRoom` is considered equal to another if their `room_id`s are equal.
Diff in /app/src/app.rs:887:
         match self {
             SelectedRoom::InvitedRoom { room_name_id } if room_name_id.room_id() == room_id => {
                 let name = room_name_id.clone();
[31m-                *self = SelectedRoom::JoinedRoom {
[m[31m-                    room_name_id: name,
[m[31m-                };
[m[32m+                *self = SelectedRoom::JoinedRoom { room_name_id: name };
[m                 true
             }
             _ => false,
Diff in /app/src/avatar_cache.rs:6:

 use crate::sliding_sync::{submit_async_request, MatrixRequest};

[31m-
[m thread_local! {
     /// A cache of Avatar images, indexed by Matrix URI.
     ///
Diff in /app/src/avatar_cache.rs:65:
 /// This function requires passing in a reference to `Cx`,
 /// which isn't used, but acts as a guarantee that this function
 /// must only be called by the main UI thread.
[31m-pub fn get_or_fetch_avatar(
[m[31m-    _cx: &mut Cx,
[m[31m-    avatar_uri: &OwnedMxcUri,
[m[31m-) -> AvatarCacheEntry {
[m[31m-    AVATAR_NEW_CACHE.with_borrow_mut(|cache| {
[m[31m-        match cache.raw_entry_mut().from_key(avatar_uri) {
[m[31m-            RawEntryMut::Occupied(occupied) => occupied.get().clone(),
[m[31m-            RawEntryMut::Vacant(vacant) => {
[m[31m-                vacant.insert(avatar_uri.clone(), AvatarCacheEntry::Requested);
[m[31m-                submit_async_request(MatrixRequest::FetchAvatar {
[m[31m-                    mxc_uri: avatar_uri.clone(),
[m[31m-                    on_fetched: enqueue_avatar_update,
[m[31m-                });
[m[31m-                AvatarCacheEntry::Requested
[m[31m-            }
[m[32m+pub fn get_or_fetch_avatar(_cx: &mut Cx, avatar_uri: &OwnedMxcUri) -> AvatarCacheEntry {
[m[32m+    AVATAR_NEW_CACHE.with_borrow_mut(|cache| match cache.raw_entry_mut().from_key(avatar_uri) {
[m[32m+        RawEntryMut::Occupied(occupied) => occupied.get().clone(),
[m[32m+        RawEntryMut::Vacant(vacant) => {
[m[32m+            vacant.insert(avatar_uri.clone(), AvatarCacheEntry::Requested);
[m[32m+            submit_async_request(MatrixRequest::FetchAvatar {
[m[32m+                mxc_uri: avatar_uri.clone(),
[m[32m+                on_fetched: enqueue_avatar_update,
[m[32m+            });
[m[32m+            AvatarCacheEntry::Requested
[m         }
     })
 }
Diff in /app/src/event_preview.rs:7:

 use std::borrow::Cow;

[31m-use matrix_sdk::{ruma::{events::{room::{guest_access::GuestAccess, history_visibility::HistoryVisibility, join_rules::JoinRule, message::{MessageFormat, MessageType}}, AnySyncMessageLikeEvent, AnySyncTimelineEvent, FullStateEventContent, SyncMessageLikeEvent}, serde::Raw, UserId}};
[m[32m+use matrix_sdk::{
[m[32m+    ruma::{
[m[32m+        events::{
[m[32m+            room::{
[m[32m+                guest_access::GuestAccess,
[m[32m+                history_visibility::HistoryVisibility,
[m[32m+                join_rules::JoinRule,
[m[32m+                message::{MessageFormat, MessageType},
[m[32m+            },
[m[32m+            AnySyncMessageLikeEvent, AnySyncTimelineEvent, FullStateEventContent,
[m[32m+            SyncMessageLikeEvent,
[m[32m+        },
[m[32m+        serde::Raw,
[m[32m+        UserId,
[m[32m+    },
[m[32m+};
[m use matrix_sdk_base::crypto::types::events::UtdCause;
[31m-use matrix_sdk_ui::timeline::{self, AnyOtherFullStateEventContent, EncryptedMessage, EventTimelineItem, MemberProfileChange, MembershipChange, MsgLikeKind, OtherMessageLike, RoomMembershipChange, TimelineItemContent};
[m[32m+use matrix_sdk_ui::timeline::{
[m[32m+    self, AnyOtherFullStateEventContent, EncryptedMessage, EventTimelineItem, MemberProfileChange,
[m[32m+    MembershipChange, MsgLikeKind, OtherMessageLike, RoomMembershipChange, TimelineItemContent,
[m[32m+};
[m
 use crate::utils;

Diff in /app/src/event_preview.rs:38:
 }
 impl TextPreview {
     /// Formats the text preview with the appropriate preceding username.
[31m-    pub fn format_with(
[m[31m-        self,
[m[31m-        username: &str,
[m[31m-        as_html: bool,
[m[31m-    ) -> String {
[m[32m+    pub fn format_with(self, username: &str, as_html: bool) -> String {
[m         let Self { text, before_text } = self;
         match before_text {
             BeforeText::Nothing => text,
Diff in /app/src/event_preview.rs:49:
[31m-            BeforeText::UsernameWithColon => if as_html {
[m[31m-                format!("<b>{}</b>: {}", htmlize::escape_text(username), text)
[m[31m-            } else {
[m[31m-                format!("{}: {}", username, text)
[m[31m-            },
[m[32m+            BeforeText::UsernameWithColon => {
[m[32m+                if as_html {
[m[32m+                    format!("<b>{}</b>: {}", htmlize::escape_text(username), text)
[m[32m+                } else {
[m[32m+                    format!("{}: {}", username, text)
[m[32m+                }
[m[32m+            }
[m             BeforeText::UsernameWithoutColon => format!(
                 "{} {}",
[31m-                if as_html { htmlize::escape_text(username) } else { username.into() },
[m[32m+                if as_html {
[m[32m+                    htmlize::escape_text(username)
[m[32m+                } else {
[m[32m+                    username.into()
[m[32m+                },
[m                 text,
             ),
         }
Diff in /app/src/event_preview.rs:67:
     sender_username: &str,
 ) -> TextPreview {
     match content {
[31m-        TimelineItemContent::MsgLike(msg_like_content) => {
[m[31m-            match &msg_like_content.kind {
[m[31m-                MsgLikeKind::Message(msg) => text_preview_of_message(msg, sender_username),
[m[31m-                MsgLikeKind::Sticker(sticker) => TextPreview::from((
[m[31m-                    format!("[Sticker]: <i>{}</i>", htmlize::escape_text(&sticker.content().body)),
[m[31m-                    BeforeText::UsernameWithColon,
[m[31m-                )),
[m[31m-                MsgLikeKind::Poll(poll_state) => TextPreview::from((
[m[31m-                    format!(
[m[31m-                        "[Poll]: {}",
[m[31m-                        htmlize::escape_text(
[m[31m-                            poll_state.fallback_text()
[m[31m-                                .unwrap_or_else(|| poll_state.results().question)
[m[31m-                        ),
[m[32m+        TimelineItemContent::MsgLike(msg_like_content) => match &msg_like_content.kind {
[m[32m+            MsgLikeKind::Message(msg) => text_preview_of_message(msg, sender_username),
[m[32m+            MsgLikeKind::Sticker(sticker) => TextPreview::from((
[m[32m+                format!(
[m[32m+                    "[Sticker]: <i>{}</i>",
[m[32m+                    htmlize::escape_text(&sticker.content().body)
[m[32m+                ),
[m[32m+                BeforeText::UsernameWithColon,
[m[32m+            )),
[m[32m+            MsgLikeKind::Poll(poll_state) => TextPreview::from((
[m[32m+                format!(
[m[32m+                    "[Poll]: {}",
[m[32m+                    htmlize::escape_text(
[m[32m+                        poll_state
[m[32m+                            .fallback_text()
[m[32m+                            .unwrap_or_else(|| poll_state.results().question)
[m                     ),
[31m-                    BeforeText::UsernameWithColon,
[m[31m-                )),
[m[31m-                MsgLikeKind::Redacted => {
[m[31m-                    let mut preview = text_preview_of_redacted_message(
[m[31m-                        None,
[m[31m-                        sender_user_id,
[m[31m-                        sender_username,
[m[31m-                    );
[m[31m-                    preview.text = htmlize::escape_text(&preview.text).into();
[m[31m-                    preview
[m[31m-                }
[m[31m-                MsgLikeKind::UnableToDecrypt(em) => text_preview_of_encrypted_message(em),
[m[31m-                MsgLikeKind::Other(oml) => text_preview_of_other_message_like(oml),
[m[32m+                ),
[m[32m+                BeforeText::UsernameWithColon,
[m[32m+            )),
[m[32m+            MsgLikeKind::Redacted => {
[m[32m+                let mut preview =
[m[32m+                    text_preview_of_redacted_message(None, sender_user_id, sender_username);
[m[32m+                preview.text = htmlize::escape_text(&preview.text).into();
[m[32m+                preview
[m             }
[31m-        }
[m[32m+            MsgLikeKind::UnableToDecrypt(em) => text_preview_of_encrypted_message(em),
[m[32m+            MsgLikeKind::Other(oml) => text_preview_of_other_message_like(oml),
[m[32m+        },
[m         TimelineItemContent::MembershipChange(membership_change) => {
[31m-            text_preview_of_room_membership_change(membership_change, true)
[m[31m-                .unwrap_or_else(|| TextPreview::from((
[m[32m+            text_preview_of_room_membership_change(membership_change, true).unwrap_or_else(|| {
[m[32m+                TextPreview::from((
[m                     String::from("<i>underwent a membership change</i>"),
                     BeforeText::UsernameWithoutColon,
[31m-                )))
[m[32m+                ))
[m[32m+            })
[m         }
         TimelineItemContent::ProfileChange(profile_change) => {
             text_preview_of_member_profile_change(profile_change, sender_username, true)
Diff in /app/src/event_preview.rs:109:
         }
         TimelineItemContent::OtherState(other_state) => {
[31m-            text_preview_of_other_state(other_state, true)
[m[31m-                .unwrap_or_else(|| TextPreview::from((
[m[32m+            text_preview_of_other_state(other_state, true).unwrap_or_else(|| {
[m[32m+                TextPreview::from((
[m                     String::from("<i>initiated another state change</i>"),
                     BeforeText::UsernameWithoutColon,
[31m-                )))
[m[32m+                ))
[m[32m+            })
[m         }
         TimelineItemContent::FailedToParseMessageLike { event_type, .. } => TextPreview::from((
             format!("[Failed to parse <i>{}</i> message]", event_type),
Diff in /app/src/event_preview.rs:133:
     }
 }

[31m-
[m[31m-
[m /// Returns the plaintext `body` of the given timeline event.
[31m-pub fn plaintext_body_of_timeline_item(
[m[31m-    event_tl_item: &EventTimelineItem,
[m[31m-) -> String {
[m[32m+pub fn plaintext_body_of_timeline_item(event_tl_item: &EventTimelineItem) -> String {
[m     match event_tl_item.content() {
[31m-        TimelineItemContent::MsgLike(msg_likecontent) => {
[m[31m-            match &msg_likecontent.kind {
[m[31m-                MsgLikeKind::Message(msg) => {
[m[31m-                    msg.body().into()
[m[31m-                }
[m[31m-                MsgLikeKind::Sticker(sticker) => {
[m[31m-                    sticker.content().body.clone()
[m[31m-                }
[m[31m-                MsgLikeKind::Poll(poll_state) => {
[m[31m-                    format!("[Poll]: {}",
[m[31m-                        poll_state.fallback_text().unwrap_or_else(|| poll_state.results().question)
[m[31m-                    )
[m[31m-                }
[m[31m-                MsgLikeKind::Redacted => {
[m[31m-                    let sender_username = utils::get_or_fetch_event_sender(event_tl_item, None);
[m[31m-                    text_preview_of_redacted_message(
[m[31m-                        event_tl_item.latest_json(),
[m[31m-                        event_tl_item.sender(),
[m[31m-                        &sender_username,
[m[31m-                    ).format_with(&sender_username, false)
[m[31m-                }
[m[31m-                MsgLikeKind::UnableToDecrypt(em) => {
[m[31m-                    text_preview_of_encrypted_message(em)
[m[31m-                        .format_with(&utils::get_or_fetch_event_sender(event_tl_item, None), false)
[m[31m-                }
[m[31m-                MsgLikeKind::Other(other_msg_like) => {
[m[31m-                    text_preview_of_other_message_like(other_msg_like)
[m[31m-                        .format_with(&utils::get_or_fetch_event_sender(event_tl_item, None), false)}
[m[32m+        TimelineItemContent::MsgLike(msg_likecontent) => match &msg_likecontent.kind {
[m[32m+            MsgLikeKind::Message(msg) => msg.body().into(),
[m[32m+            MsgLikeKind::Sticker(sticker) => sticker.content().body.clone(),
[m[32m+            MsgLikeKind::Poll(poll_state) => {
[m[32m+                format!(
[m[32m+                    "[Poll]: {}",
[m[32m+                    poll_state
[m[32m+                        .fallback_text()
[m[32m+                        .unwrap_or_else(|| poll_state.results().question)
[m[32m+                )
[m             }
[31m-        }
[m[32m+            MsgLikeKind::Redacted => {
[m[32m+                let sender_username = utils::get_or_fetch_event_sender(event_tl_item, None);
[m[32m+                text_preview_of_redacted_message(
[m[32m+                    event_tl_item.latest_json(),
[m[32m+                    event_tl_item.sender(),
[m[32m+                    &sender_username,
[m[32m+                )
[m[32m+                .format_with(&sender_username, false)
[m[32m+            }
[m[32m+            MsgLikeKind::UnableToDecrypt(em) => text_preview_of_encrypted_message(em).format_with(
[m[32m+                &utils::get_or_fetch_event_sender(event_tl_item, None),
[m[32m+                false,
[m[32m+            ),
[m[32m+            MsgLikeKind::Other(other_msg_like) => {
[m[32m+                text_preview_of_other_message_like(other_msg_like).format_with(
[m[32m+                    &utils::get_or_fetch_event_sender(event_tl_item, None),
[m[32m+                    false,
[m[32m+                )
[m[32m+            }
[m[32m+        },
[m         TimelineItemContent::MembershipChange(membership_change) => {
             text_preview_of_room_membership_change(membership_change, false)
[31m-                .unwrap_or_else(|| TextPreview::from((
[m[31m-                    String::from("underwent a membership change."),
[m[31m-                    BeforeText::UsernameWithoutColon,
[m[31m-                )))
[m[31m-                .format_with(&utils::get_or_fetch_event_sender(event_tl_item, None), false)
[m[32m+                .unwrap_or_else(|| {
[m[32m+                    TextPreview::from((
[m[32m+                        String::from("underwent a membership change."),
[m[32m+                        BeforeText::UsernameWithoutColon,
[m[32m+                    ))
[m[32m+                })
[m[32m+                .format_with(
[m[32m+                    &utils::get_or_fetch_event_sender(event_tl_item, None),
[m[32m+                    false,
[m[32m+                )
[m         }
         TimelineItemContent::ProfileChange(profile_change) => {
             text_preview_of_member_profile_change(
Diff in /app/src/event_preview.rs:183:
                 profile_change,
                 &utils::get_or_fetch_event_sender(event_tl_item, None),
                 false,
[31m-            ).text
[m[32m+            )
[m[32m+            .text
[m         }
         TimelineItemContent::OtherState(other_state) => {
             text_preview_of_other_state(other_state, false)
Diff in /app/src/event_preview.rs:190:
[31m-                .unwrap_or_else(|| TextPreview::from((
[m[31m-                    String::from("initiated another state change."),
[m[31m-                    BeforeText::UsernameWithoutColon,
[m[31m-                )))
[m[31m-                .format_with(&utils::get_or_fetch_event_sender(event_tl_item, None), false)
[m[32m+                .unwrap_or_else(|| {
[m[32m+                    TextPreview::from((
[m[32m+                        String::from("initiated another state change."),
[m[32m+                        BeforeText::UsernameWithoutColon,
[m[32m+                    ))
[m[32m+                })
[m[32m+                .format_with(
[m[32m+                    &utils::get_or_fetch_event_sender(event_tl_item, None),
[m[32m+                    false,
[m[32m+                )
[m         }
         TimelineItemContent::FailedToParseMessageLike { event_type, error } => {
             format!("Failed to parse {} message. Error: {}", event_type, error)
Diff in /app/src/event_preview.rs:198:
         }
[31m-        TimelineItemContent::FailedToParseState { event_type, error, state_key } => {
[m[31m-            format!("Failed to parse {} state; key: {}. Error: {}", event_type, state_key, error)
[m[32m+        TimelineItemContent::FailedToParseState {
[m[32m+            event_type,
[m[32m+            error,
[m[32m+            state_key,
[m[32m+        } => {
[m[32m+            format!(
[m[32m+                "Failed to parse {} state; key: {}. Error: {}",
[m[32m+                event_type, state_key, error
[m[32m+            )
[m         }
         TimelineItemContent::CallInvite => String::from("[Call Invitation]"),
         TimelineItemContent::RtcNotification => String::from("[RTC Call Notification]"),
Diff in /app/src/event_preview.rs:204:
     }
 }

[31m-
[m /// Returns a text preview of the given message as an Html-formatted string.
[31m-pub fn text_preview_of_message(
[m[31m-    message: &timeline::Message,
[m[31m-    sender_username: &str,
[m[31m-) -> TextPreview {
[m[32m+pub fn text_preview_of_message(message: &timeline::Message, sender_username: &str) -> TextPreview {
[m     let text = match message.msgtype() {
         MessageType::Audio(audio) => format!(
             "[Audio]: <i>{}</i>",
Diff in /app/src/event_preview.rs:248:
             "[Location]: <i>{}</i>",
             htmlize::escape_text(&location.body),
         ),
[31m-        MessageType::Notice(notice) => format!("<i>{}</i>",
[m[32m+        MessageType::Notice(notice) => format!(
[m[32m+            "<i>{}</i>",
[m             if let Some(formatted_body) = notice.formatted.as_ref() {
                 utils::trim_start_html_whitespace(&formatted_body.body).into()
             } else {
Diff in /app/src/event_preview.rs:260:
             notice.server_notice_type.as_str(),
             notice.body,
         ),
[31m-        MessageType::Text(text) => {
[m[31m-            text.formatted
[m[31m-                .as_ref()
[m[31m-                .and_then(|fb|
[m[31m-                    (fb.format == MessageFormat::Html).then(|| {
[m[31m-                        let filtered_and_trimmed = utils::trim_start_html_whitespace(
[m[31m-                            utils::remove_mx_reply(&fb.body)
[m[31m-                        );
[m[31m-                        utils::linkify(filtered_and_trimmed, true).to_string()
[m[31m-                    })
[m[31m-                )
[m[31m-                .unwrap_or_else(|| match utils::linkify(&text.body, false) {
[m[31m-                    Cow::Borrowed(plaintext) => htmlize::escape_text(plaintext).to_string(),
[m[31m-                    Cow::Owned(linkified) => linkified,
[m[32m+        MessageType::Text(text) => text
[m[32m+            .formatted
[m[32m+            .as_ref()
[m[32m+            .and_then(|fb| {
[m[32m+                (fb.format == MessageFormat::Html).then(|| {
[m[32m+                    let filtered_and_trimmed =
[m[32m+                        utils::trim_start_html_whitespace(utils::remove_mx_reply(&fb.body));
[m[32m+                    utils::linkify(filtered_and_trimmed, true).to_string()
[m                 })
[32m+            })
[m[32m+            .unwrap_or_else(|| match utils::linkify(&text.body, false) {
[m[32m+                Cow::Borrowed(plaintext) => htmlize::escape_text(plaintext).to_string(),
[m[32m+                Cow::Owned(linkified) => linkified,
[m[32m+            }),
[m[32m+        MessageType::VerificationRequest(verification) => {
[m[32m+            format!("[Verification Request] <i>to user {}</i>", verification.to,)
[m         }
[31m-        MessageType::VerificationRequest(verification) => format!(
[m[31m-            "[Verification Request] <i>to user {}</i>",
[m[31m-            verification.to,
[m[31m-        ),
[m         MessageType::Video(video) => format!(
             "[Video]: <i>{}</i>",
             if let Some(formatted_body) = video.formatted.as_ref() {
Diff in /app/src/event_preview.rs:286:
[31m-               Cow::Borrowed(formatted_body.body.as_str())
[m[32m+                Cow::Borrowed(formatted_body.body.as_str())
[m             } else {
                 htmlize::escape_text(&video.body)
             }
Diff in /app/src/event_preview.rs:290:
         ),
[31m-        MessageType::_Custom(custom) => format!(
[m[31m-            "[Custom message]: {:?}",
[m[31m-            custom,
[m[31m-        ),
[m[32m+        MessageType::_Custom(custom) => format!("[Custom message]: {:?}", custom,),
[m         other => format!(
             "[Unknown message type]: {}",
             htmlize::escape_text(other.body()),
Diff in /app/src/event_preview.rs:300:
     TextPreview::from((text, BeforeText::UsernameWithColon))
 }

[31m-
[m /// Returns a plaintext preview of the given redacted message.
 ///
 /// Note: this function accepts the component parts of an [`EventTimelineItem`]
Diff in /app/src/event_preview.rs:315:
 ) -> TextPreview {
     let mut redactor_and_reason = None;
     if let Some(redacted_msg) = latest_json {
[31m-        if let Ok(AnySyncTimelineEvent::MessageLike(
[m[31m-            AnySyncMessageLikeEvent::RoomMessage(
[m[31m-                SyncMessageLikeEvent::Redacted(redaction)
[m[31m-            )
[m[31m-        )) = redacted_msg.deserialize() {
[m[32m+        if let Ok(AnySyncTimelineEvent::MessageLike(AnySyncMessageLikeEvent::RoomMessage(
[m[32m+            SyncMessageLikeEvent::Redacted(redaction),
[m[32m+        ))) = redacted_msg.deserialize()
[m[32m+        {
[m             if let Ok(redacted_because) = redaction.unsigned.redacted_because.deserialize() {
[31m-                redactor_and_reason = Some((
[m[31m-                    redacted_because.sender,
[m[31m-                    redacted_because.content.reason,
[m[31m-                ));
[m[32m+                redactor_and_reason =
[m[32m+                    Some((redacted_because.sender, redacted_because.content.reason));
[m             }
         }
     }
Diff in /app/src/event_preview.rs:331:
     let text = match redactor_and_reason {
         Some((redactor, Some(reason))) => {
             if redactor == sender_user_id {
[31m-                format!("{} deleted their own message: \"{}\".", original_sender_username, reason)
[m[32m+                format!(
[m[32m+                    "{} deleted their own message: \"{}\".",
[m[32m+                    original_sender_username, reason
[m[32m+                )
[m             } else {
[31m-                format!("{} deleted {}'s message: \"{}\".", redactor, original_sender_username, reason)
[m[32m+                format!(
[m[32m+                    "{} deleted {}'s message: \"{}\".",
[m[32m+                    redactor, original_sender_username, reason
[m[32m+                )
[m             }
         }
         Some((redactor, None)) => {
Diff in /app/src/event_preview.rs:340:
             if redactor == sender_user_id {
                 format!("{} deleted their own message.", original_sender_username)
             } else {
[31m-                format!("{} deleted {}'s message.", redactor, original_sender_username)
[m[32m+                format!(
[m[32m+                    "{} deleted {}'s message.",
[m[32m+                    redactor, original_sender_username
[m[32m+                )
[m             }
         }
         None => {
Diff in /app/src/event_preview.rs:350:
     TextPreview::from((text, BeforeText::Nothing))
 }

[31m-
[m /// Returns a plaintext preview of the given encrypted message that could not be decrypted.
 ///
 /// This is used for "Unable to decrypt" messages, which may have a known cause
Diff in /app/src/event_preview.rs:357:
 /// for why they could not be decrypted.
[31m-pub fn text_preview_of_encrypted_message(
[m[31m-    encrypted_message: &EncryptedMessage,
[m[31m-) -> TextPreview {
[m[32m+pub fn text_preview_of_encrypted_message(encrypted_message: &EncryptedMessage) -> TextPreview {
[m     let cause_str = match encrypted_message {
         EncryptedMessage::MegolmV1AesSha2 { cause, .. } => match cause {
             UtdCause::Unknown => None,
Diff in /app/src/event_preview.rs:364:
[31m-            UtdCause::SentBeforeWeJoined => Some(
[m[31m-                "this message was sent before you joined the room."
[m[31m-            ),
[m[31m-            UtdCause::VerificationViolation => Some(
[m[31m-                "this message was sent by an unverified user."
[m[31m-            ),
[m[31m-            UtdCause::UnsignedDevice => Some(
[m[31m-                "the sending device wasn't signed by its owner."
[m[31m-            ),
[m[31m-            UtdCause::UnknownDevice => Some(
[m[31m-                "the sending device's signature was not found."
[m[31m-            ),
[m[32m+            UtdCause::SentBeforeWeJoined => {
[m[32m+                Some("this message was sent before you joined the room.")
[m[32m+            }
[m[32m+            UtdCause::VerificationViolation => Some("this message was sent by an unverified user."),
[m[32m+            UtdCause::UnsignedDevice => Some("the sending device wasn't signed by its owner."),
[m[32m+            UtdCause::UnknownDevice => Some("the sending device's signature was not found."),
[m             UtdCause::HistoricalMessageAndBackupIsDisabled => Some(
[31m-                "historical messages are not available on this device because server-side key backup was disabled."
[m[32m+                "historical messages are not available on this device because server-side key backup was disabled.",
[m             ),
[31m-            UtdCause::WithheldForUnverifiedOrInsecureDevice => Some(
[m[31m-                "your device doesn't meet the sender's security requirements."
[m[31m-            ),
[m[31m-            UtdCause::WithheldBySender => Some(
[m[31m-                "the sender withheld this message from you."
[m[31m-            ),
[m[31m-            UtdCause::HistoricalMessageAndDeviceIsUnverified => Some(
[m[31m-                "historical messages are not available; you must verify this device."
[m[31m-            ),
[m[31m-        }
[m[32m+            UtdCause::WithheldForUnverifiedOrInsecureDevice => {
[m[32m+                Some("your device doesn't meet the sender's security requirements.")
[m[32m+            }
[m[32m+            UtdCause::WithheldBySender => Some("the sender withheld this message from you."),
[m[32m+            UtdCause::HistoricalMessageAndDeviceIsUnverified => {
[m[32m+                Some("historical messages are not available; you must verify this device.")
[m[32m+            }
[m[32m+        },
[m         _ => None,
     };
     let text = if let Some(cause) = cause_str {
Diff in /app/src/event_preview.rs:397:
 }

 /// Returns a plaintext preview of the given other message-like event.
[31m-pub fn text_preview_of_other_message_like(
[m[31m-    other_msg_like: &OtherMessageLike,
[m[31m-) -> TextPreview {
[m[32m+pub fn text_preview_of_other_message_like(other_msg_like: &OtherMessageLike) -> TextPreview {
[m     TextPreview::from((
         format!("[Other message type: {}]", other_msg_like.event_type()),
         BeforeText::UsernameWithColon,
Diff in /app/src/event_preview.rs:412:
     format_as_html: bool,
 ) -> Option<TextPreview> {
     let text = match other_state.content() {
[31m-        AnyOtherFullStateEventContent::RoomAliases(FullStateEventContent::Original { content, .. }) => {
[m[32m+        AnyOtherFullStateEventContent::RoomAliases(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => {
[m             let mut s = String::from("set this room's aliases to ");
             let last_alias = content.aliases.len() - 1;
             for (i, alias) in content.aliases.iter().enumerate() {
Diff in /app/src/event_preview.rs:427:
         AnyOtherFullStateEventContent::RoomAvatar(_) => {
             Some(String::from("set this room's avatar picture."))
         }
[31m-        AnyOtherFullStateEventContent::RoomCanonicalAlias(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(format!("set the main address of this room to {}.",
[m[31m-                content.alias.as_ref().map(|a| a.as_str()).unwrap_or("none")
[m[31m-            ))
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomCreate(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(format!("created this room (v{}).", content.room_version.as_str()))
[m[31m-        }
[m[32m+        AnyOtherFullStateEventContent::RoomCanonicalAlias(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(format!(
[m[32m+            "set the main address of this room to {}.",
[m[32m+            content.alias.as_ref().map(|a| a.as_str()).unwrap_or("none")
[m[32m+        )),
[m[32m+        AnyOtherFullStateEventContent::RoomCreate(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(format!(
[m[32m+            "created this room (v{}).",
[m[32m+            content.room_version.as_str()
[m[32m+        )),
[m         AnyOtherFullStateEventContent::RoomEncryption(_) => {
             Some(String::from("enabled encryption in this room."))
         }
Diff in /app/src/event_preview.rs:441:
[31m-        AnyOtherFullStateEventContent::RoomGuestAccess(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(match &content.guest_access {
[m[31m-                GuestAccess::CanJoin => String::from("has allowed guests to join this room."),
[m[31m-                GuestAccess::Forbidden => String::from("has forbidden guests from joining this room."),
[m[31m-                custom => format!("has set custom guest access rules for this room: {}", custom.as_str()),
[m[31m-            })
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomHistoryVisibility(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(format!("set this room's history to be visible by {}",
[m[31m-                match &content.history_visibility {
[m[31m-                    HistoryVisibility::Invited => "invited users, since they were invited.",
[m[31m-                    HistoryVisibility::Joined => "joined users, since they joined.",
[m[31m-                    HistoryVisibility::Shared => "joined users, for all of time.",
[m[31m-                    HistoryVisibility::WorldReadable => "anyone for all time.",
[m[31m-                    custom => custom.as_str(),
[m[31m-                },
[m[31m-            ))
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomJoinRules(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(match &content.join_rule {
[m[31m-                JoinRule::Public => String::from("set this room to be joinable by anyone."),
[m[31m-                JoinRule::Knock => String::from("set this room to be joinable by invite only or by request."),
[m[31m-                JoinRule::Private => String::from("set this room to be private."),
[m[31m-                JoinRule::Restricted(_) => String::from("set this room to be joinable by invite only or with restrictions."),
[m[31m-                JoinRule::KnockRestricted(_) => String::from("set this room to be joinable by invite only or requestable with restrictions."),
[m[31m-                JoinRule::Invite  => String::from("set this room to be joinable by invite only."),
[m[31m-                custom => format!("set custom join rules for this room: {}", custom.as_str()),
[m[31m-            })
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomPinnedEvents(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(format!("pinned {} events in this room.", content.pinned.len()))
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomName(FullStateEventContent::Original { content, .. }) => {
[m[32m+        AnyOtherFullStateEventContent::RoomGuestAccess(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(match &content.guest_access {
[m[32m+            GuestAccess::CanJoin => String::from("has allowed guests to join this room."),
[m[32m+            GuestAccess::Forbidden => String::from("has forbidden guests from joining this room."),
[m[32m+            custom => format!(
[m[32m+                "has set custom guest access rules for this room: {}",
[m[32m+                custom.as_str()
[m[32m+            ),
[m[32m+        }),
[m[32m+        AnyOtherFullStateEventContent::RoomHistoryVisibility(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(format!(
[m[32m+            "set this room's history to be visible by {}",
[m[32m+            match &content.history_visibility {
[m[32m+                HistoryVisibility::Invited => "invited users, since they were invited.",
[m[32m+                HistoryVisibility::Joined => "joined users, since they joined.",
[m[32m+                HistoryVisibility::Shared => "joined users, for all of time.",
[m[32m+                HistoryVisibility::WorldReadable => "anyone for all time.",
[m[32m+                custom => custom.as_str(),
[m[32m+            },
[m[32m+        )),
[m[32m+        AnyOtherFullStateEventContent::RoomJoinRules(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(match &content.join_rule {
[m[32m+            JoinRule::Public => String::from("set this room to be joinable by anyone."),
[m[32m+            JoinRule::Knock => {
[m[32m+                String::from("set this room to be joinable by invite only or by request.")
[m[32m+            }
[m[32m+            JoinRule::Private => String::from("set this room to be private."),
[m[32m+            JoinRule::Restricted(_) => {
[m[32m+                String::from("set this room to be joinable by invite only or with restrictions.")
[m[32m+            }
[m[32m+            JoinRule::KnockRestricted(_) => String::from(
[m[32m+                "set this room to be joinable by invite only or requestable with restrictions.",
[m[32m+            ),
[m[32m+            JoinRule::Invite => String::from("set this room to be joinable by invite only."),
[m[32m+            custom => format!("set custom join rules for this room: {}", custom.as_str()),
[m[32m+        }),
[m[32m+        AnyOtherFullStateEventContent::RoomPinnedEvents(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(format!(
[m[32m+            "pinned {} events in this room.",
[m[32m+            content.pinned.len()
[m[32m+        )),
[m[32m+        AnyOtherFullStateEventContent::RoomName(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => {
[m             let name = if format_as_html {
                 htmlize::escape_text(&content.name)
             } else {
Diff in /app/src/event_preview.rs:481:
         AnyOtherFullStateEventContent::RoomPowerLevels(_) => {
             Some(String::from("set the power levels for this room."))
         }
[31m-        AnyOtherFullStateEventContent::RoomServerAcl(_) => {
[m[31m-            Some(String::from("set the server access control list for this room."))
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomTombstone(FullStateEventContent::Original { content, .. }) => {
[m[31m-            Some(format!("closed this room and upgraded it to {}", content.replacement_room.matrix_to_uri()))
[m[31m-        }
[m[31m-        AnyOtherFullStateEventContent::RoomTopic(FullStateEventContent::Original { content, .. }) => {
[m[32m+        AnyOtherFullStateEventContent::RoomServerAcl(_) => Some(String::from(
[m[32m+            "set the server access control list for this room.",
[m[32m+        )),
[m[32m+        AnyOtherFullStateEventContent::RoomTombstone(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => Some(format!(
[m[32m+            "closed this room and upgraded it to {}",
[m[32m+            content.replacement_room.matrix_to_uri()
[m[32m+        )),
[m[32m+        AnyOtherFullStateEventContent::RoomTopic(FullStateEventContent::Original {
[m[32m+            content,
[m[32m+            ..
[m[32m+        }) => {
[m             let topic = if format_as_html {
                 htmlize::escape_text(&content.topic)
             } else {
Diff in /app/src/event_preview.rs:496:
             Some(format!("changed this room's topic to \"{topic}\"."))
         }
         AnyOtherFullStateEventContent::SpaceParent(_) => {
[31m-            let state_key  = if format_as_html {
[m[32m+            let state_key = if format_as_html {
[m                 htmlize::escape_text(other_state.state_key())
             } else {
                 Cow::Borrowed(other_state.state_key())
Diff in /app/src/event_preview.rs:504:
             Some(format!("set this room's parent space to \"{state_key}\"."))
         }
         AnyOtherFullStateEventContent::SpaceChild(_) => {
[31m-            let state_key  = if format_as_html {
[m[32m+            let state_key = if format_as_html {
[m                 htmlize::escape_text(other_state.state_key())
             } else {
                 Cow::Borrowed(other_state.state_key())
Diff in /app/src/event_preview.rs:519:
     text.map(|t| TextPreview::from((t, BeforeText::UsernameWithoutColon)))
 }

[31m-
[m /// Returns a text preview of the given member profile change
 /// as a plaintext or HTML-formatted string.
 pub fn text_preview_of_member_profile_change(
Diff in /app/src/event_preview.rs:529:
 ) -> TextPreview {
     let name_text = if let Some(name_change) = change.displayname_change() {
         let old = name_change.old.as_deref().unwrap_or(username);
[31m-        let old_un = if format_as_html { htmlize::escape_text(old) } else { old.into() };
[m[32m+        let old_un = if format_as_html {
[m[32m+            htmlize::escape_text(old)
[m[32m+        } else {
[m[32m+            old.into()
[m[32m+        };
[m         if let Some(new) = name_change.new.as_ref() {
[31m-            let new_un = if format_as_html { htmlize::escape_text(new) } else { new.into() };
[m[32m+            let new_un = if format_as_html {
[m[32m+                htmlize::escape_text(new)
[m[32m+            } else {
[m[32m+                new.into()
[m[32m+            };
[m             format!("{old_un} changed their display name to \"{new_un}\"")
         } else {
             format!("{old_un} removed their display name")
Diff in /app/src/event_preview.rs:560:
     ))
 }

[31m-
[m /// Returns a text preview of the given room membership change
 /// as a plaintext or HTML-formatted string.
 pub fn text_preview_of_room_membership_change(
Diff in /app/src/event_preview.rs:568:
     format_as_html: bool,
 ) -> Option<TextPreview> {
     let dn = change.display_name();
[31m-    let change_user_id = dn.as_deref()
[m[31m-        .unwrap_or_else(|| change.user_id().as_str());
[m[32m+    let change_user_id = dn.as_deref().unwrap_or_else(|| change.user_id().as_str());
[m     let change_user_id = if format_as_html {
         htmlize::escape_text(change_user_id)
     } else {
Diff in /app/src/event_preview.rs:583:
             // Don't actually display anything for nonexistent/unimportant membership changes.
             return None;
         }
[31m-        Some(MembershipChange::Joined) =>
[m[31m-            String::from("joined this room."),
[m[31m-        Some(MembershipChange::Left) =>
[m[31m-            String::from("left this room."),
[m[31m-        Some(MembershipChange::Banned) =>
[m[31m-            format!("banned {} from this room.", change_user_id),
[m[31m-        Some(MembershipChange::Unbanned) =>
[m[31m-            format!("unbanned {} from this room.", change_user_id),
[m[31m-        Some(MembershipChange::Kicked) =>
[m[31m-            format!("kicked {} from this room.", change_user_id),
[m[31m-        Some(MembershipChange::Invited) =>
[m[31m-            format!("invited {} to this room.", change_user_id),
[m[31m-        Some(MembershipChange::KickedAndBanned) =>
[m[31m-            format!("kicked and banned {} from this room.", change_user_id),
[m[31m-        Some(MembershipChange::InvitationAccepted) =>
[m[31m-            String::from("accepted an invitation to this room."),
[m[31m-        Some(MembershipChange::InvitationRejected) =>
[m[31m-            String::from("rejected an invitation to this room."),
[m[31m-        Some(MembershipChange::InvitationRevoked) =>
[m[31m-            format!("revoked {}'s invitation to this room.", change_user_id),
[m[31m-        Some(MembershipChange::Knocked) =>
[m[31m-            String::from("requested to join this room."),
[m[31m-        Some(MembershipChange::KnockAccepted) =>
[m[31m-            format!("accepted {}'s request to join this room.", change_user_id),
[m[31m-        Some(MembershipChange::KnockRetracted) =>
[m[31m-            String::from("retracted their request to join this room."),
[m[31m-        Some(MembershipChange::KnockDenied) =>
[m[31m-            format!("denied {}'s request to join this room.", change_user_id),
[m[32m+        Some(MembershipChange::Joined) => String::from("joined this room."),
[m[32m+        Some(MembershipChange::Left) => String::from("left this room."),
[m[32m+        Some(MembershipChange::Banned) => format!("banned {} from this room.", change_user_id),
[m[32m+        Some(MembershipChange::Unbanned) => format!("unbanned {} from this room.", change_user_id),
[m[32m+        Some(MembershipChange::Kicked) => format!("kicked {} from this room.", change_user_id),
[m[32m+        Some(MembershipChange::Invited) => format!("invited {} to this room.", change_user_id),
[m[32m+        Some(MembershipChange::KickedAndBanned) => {
[m[32m+            format!("kicked and banned {} from this room.", change_user_id)
[m[32m+        }
[m[32m+        Some(MembershipChange::InvitationAccepted) => {
[m[32m+            String::from("accepted an invitation to this room.")
[m[32m+        }
[m[32m+        Some(MembershipChange::InvitationRejected) => {
[m[32m+            String::from("rejected an invitation to this room.")
[m[32m+        }
[m[32m+        Some(MembershipChange::InvitationRevoked) => {
[m[32m+            format!("revoked {}'s invitation to this room.", change_user_id)
[m[32m+        }
[m[32m+        Some(MembershipChange::Knocked) => String::from("requested to join this room."),
[m[32m+        Some(MembershipChange::KnockAccepted) => {
[m[32m+            format!("accepted {}'s request to join this room.", change_user_id)
[m[32m+        }
[m[32m+        Some(MembershipChange::KnockRetracted) => {
[m[32m+            String::from("retracted their request to join this room.")
[m[32m+        }
[m[32m+        Some(MembershipChange::KnockDenied) => {
[m[32m+            format!("denied {}'s request to join this room.", change_user_id)
[m[32m+        }
[m     };
     Some(TextPreview::from((text, BeforeText::UsernameWithoutColon)))
 }
Diff in /app/src/home/add_room.rs:1:
 //! A top-level view for adding (joining) or exploring new rooms and spaces.

[31m-
[m use makepad_widgets::*;
 use matrix_sdk::RoomState;
[31m-use ruma::{IdParseError, MatrixToUri, MatrixUri, OwnedRoomOrAliasId, OwnedServerName, matrix_uri::MatrixId, room::{JoinRuleSummary, RoomType}};
[m[32m+use ruma::{
[m[32m+    IdParseError, MatrixToUri, MatrixUri, OwnedRoomOrAliasId, OwnedServerName,
[m[32m+    matrix_uri::MatrixId,
[m[32m+    room::{JoinRuleSummary, RoomType},
[m[32m+};
[m
[31m-use crate::{app::AppStateAction, home::invite_screen::JoinRoomResultAction, room::{FetchedRoomAvatar, FetchedRoomPreview, RoomPreviewAction}, shared::{avatar::AvatarWidgetRefExt, popup_list::{PopupKind, enqueue_popup_notification}}, sliding_sync::{MatrixRequest, submit_async_request}, utils};
[m[32m+use crate::{
[m[32m+    app::AppStateAction,
[m[32m+    home::invite_screen::JoinRoomResultAction,
[m[32m+    room::{FetchedRoomAvatar, FetchedRoomPreview, RoomPreviewAction},
[m[32m+    shared::{
[m[32m+        avatar::AvatarWidgetRefExt,
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    },
[m[32m+    sliding_sync::{MatrixRequest, submit_async_request},
[m[32m+    utils,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/add_room.rs:42:
                 text_style: {font_size: 18},
             }
         }
[31m-
[m[32m+
[m         <LineH> { padding: 10, margin: {top: 10, right: 2} }

         <SubsectionLabel> {
Diff in /app/src/home/add_room.rs:290:
                 }
             }
         }
[31m-
[m[32m+
[m     }
 }

Diff in /app/src/home/add_room.rs:297:
 #[derive(Live, LiveHook, Widget)]
 pub struct AddRoomScreen {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: AddRoomState,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: AddRoomState,
[m     /// The function to perform when the user clicks the `join_room_button`.
[31m-    #[rust(JoinButtonFunction::None)] join_function: JoinButtonFunction,
[m[32m+    #[rust(JoinButtonFunction::None)]
[m[32m+    join_function: JoinButtonFunction,
[m }

 #[derive(Default)]
Diff in /app/src/home/add_room.rs:328:
     FetchError(String),
     /// We successfully knocked on the room or space, and are waiting for
     /// a member of that room/space to acknowledge our knock by inviting us.
[31m-    Knocked {
[m[31m-        frp: FetchedRoomPreview,
[m[31m-    },
[m[32m+    Knocked { frp: FetchedRoomPreview },
[m     /// We successfully joined the room or space, and are waiting for it
     /// to be loaded from the homeserver.
[31m-    Joined {
[m[31m-        frp: FetchedRoomPreview,
[m[31m-    },
[m[32m+    Joined { frp: FetchedRoomPreview },
[m     /// The fetched room or space has been loaded from the homeserver,
     /// so we can allow the user to jump to it via the `join_room_button`.
     Loaded {
Diff in /app/src/home/add_room.rs:342:
         frp: FetchedRoomPreview,
         is_invite: bool,
[31m-    }
[m[32m+    },
[m }
 impl AddRoomState {
     fn fetched_room_preview(&self) -> Option<&FetchedRoomPreview> {
Diff in /app/src/home/add_room.rs:375:
     fn transition_to_loaded(&mut self, is_invite: bool) {
         let prev = std::mem::take(self);
         match prev {
[31m-            Self::FetchedRoomPreview { frp, .. }
[m[31m-            | Self::Joined { frp }
[m[31m-            | Self::Knocked { frp } => {
[m[32m+            Self::FetchedRoomPreview { frp, .. } | Self::Joined { frp } | Self::Knocked { frp } => {
[m                 *self = Self::Loaded { frp, is_invite };
             }
             _ => {
Diff in /app/src/home/add_room.rs:390:
 impl Widget for AddRoomScreen {
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);
[31m-
[m[32m+
[m         if let Event::Actions(actions) = event {
             let room_alias_id_input = self.view.text_input(ids!(room_alias_id_input));
             let search_for_room_button = self.view.button(ids!(search_for_room_button));
Diff in /app/src/home/add_room.rs:397:
[31m-            let cancel_button = self.view.button(ids!(fetched_room_summary.buttons_view.cancel_button));
[m[31m-            let join_room_button = self.view.button(ids!(fetched_room_summary.buttons_view.join_room_button));
[m[32m+            let cancel_button = self
[m[32m+                .view
[m[32m+                .button(ids!(fetched_room_summary.buttons_view.cancel_button));
[m[32m+            let join_room_button = self
[m[32m+                .view
[m[32m+                .button(ids!(fetched_room_summary.buttons_view.join_room_button));
[m
             // Enable or disable the button based on if the text input is empty.
             if let Some(text) = room_alias_id_input.changed(actions) {
Diff in /app/src/home/add_room.rs:414:
                 match (&self.join_function, &self.state) {
                     (
                         JoinButtonFunction::NavigateOrJoin,
[31m-                        AddRoomState::FetchedRoomPreview { frp, .. } | AddRoomState::Loaded { frp, .. }
[m[32m+                        AddRoomState::FetchedRoomPreview { frp, .. }
[m[32m+                        | AddRoomState::Loaded { frp, .. },
[m                     ) => {
                         cx.action(AppStateAction::NavigateToRoom {
                             room_to_close: None,
Diff in /app/src/home/add_room.rs:423:
                     }
                     (
                         JoinButtonFunction::Knock,
[31m-                        AddRoomState::FetchedRoomPreview { frp, room_or_alias_id, via }
[m[32m+                        AddRoomState::FetchedRoomPreview {
[m[32m+                            frp,
[m[32m+                            room_or_alias_id,
[m[32m+                            via,
[m[32m+                        },
[m                     ) => {
                         submit_async_request(MatrixRequest::Knock {
[31m-                            room_or_alias_id: frp.canonical_alias.clone().map_or_else(
[m[31m-                                || room_or_alias_id.clone(),
[m[31m-                                Into::into
[m[31m-                            ),
[m[32m+                            room_or_alias_id: frp
[m[32m+                                .canonical_alias
[m[32m+                                .clone()
[m[32m+                                .map_or_else(|| room_or_alias_id.clone(), Into::into),
[m                             reason: None,
                             server_names: via.clone(),
                         });
Diff in /app/src/home/add_room.rs:436:
                     }
[31m-                    _ => { }
[m[32m+                    _ => {}
[m                 }
             }

Diff in /app/src/home/add_room.rs:441:
             // If the button was clicked or enter was pressed, try to parse the room address.
[31m-            let new_room_query = search_for_room_button.clicked(actions)
[m[32m+            let new_room_query = search_for_room_button
[m[32m+                .clicked(actions)
[m                 .then(|| room_alias_id_input.text())
                 .or_else(|| room_alias_id_input.returned(actions).map(|(t, _)| t));
             if let Some(t) = new_room_query {
Diff in /app/src/home/add_room.rs:449:
                             room_or_alias_id: room_or_alias_id.clone(),
                             via: via.clone(),
                         };
[31m-                        submit_async_request(MatrixRequest::GetRoomPreview { room_or_alias_id, via });
[m[32m+                        submit_async_request(MatrixRequest::GetRoomPreview {
[m[32m+                            room_or_alias_id,
[m[32m+                            via,
[m[32m+                        });
[m                     }
                     Err(e) => {
[31m-                        let err_str = format!("Could not parse the text as a valid room address.\nError: {e}.");
[m[31m-                        enqueue_popup_notification(
[m[31m-                            err_str.clone(),
[m[31m-                            PopupKind::Error,
[m[31m-                            None,
[m[32m+                        let err_str = format!(
[m[32m+                            "Could not parse the text as a valid room address.\nError: {e}."
[m                         );
[32m+                        enqueue_popup_notification(err_str.clone(), PopupKind::Error, None);
[m                         self.state = AddRoomState::ParseError(err_str);
                     }
                 }
Diff in /app/src/home/add_room.rs:466:

             // If we're waiting for the room preview to be fetched (i.e., in the Parsed state),
             // then check if we've received it via an action.
[31m-            if let AddRoomState::Parsed { room_or_alias_id, via } = &self.state {
[m[32m+            if let AddRoomState::Parsed {
[m[32m+                room_or_alias_id,
[m[32m+                via,
[m[32m+            } = &self.state
[m[32m+            {
[m                 for action in actions {
                     match action.downcast_ref() {
                         Some(RoomPreviewAction::Fetched(Ok(frp))) => {
Diff in /app/src/home/add_room.rs:482:
                         }
                         Some(RoomPreviewAction::Fetched(Err(e))) => {
                             let err_str = format!("Failed to fetch room info.\n\nError: {e}.");
[31m-                            enqueue_popup_notification(
[m[31m-                                err_str.clone(),
[m[31m-                                PopupKind::Error,
[m[31m-                                None,
[m[31m-                            );
[m[32m+                            enqueue_popup_notification(err_str.clone(), PopupKind::Error, None);
[m                             self.state = AddRoomState::FetchError(err_str);
                             self.redraw(cx);
                             break;
Diff in /app/src/home/add_room.rs:496:
                 }
             }

[31m-
[m             // If we've fetched and displayed the room preview, handle any responses to
             // the user clicking the join button (e.g., knocked on or joined the room/space).
             let mut transition_to_knocked = false;
Diff in /app/src/home/add_room.rs:503:
[31m-            let mut transition_to_joined  = false;
[m[31m-            if let AddRoomState::FetchedRoomPreview { frp, room_or_alias_id, .. } = &self.state {
[m[32m+            let mut transition_to_joined = false;
[m[32m+            if let AddRoomState::FetchedRoomPreview {
[m[32m+                frp,
[m[32m+                room_or_alias_id,
[m[32m+                ..
[m[32m+            } = &self.state
[m[32m+            {
[m                 for action in actions {
                     match action.downcast_ref() {
[31m-                        Some(KnockResultAction::Knocked { room, .. }) if room.room_id() == frp.room_name_id.room_id() => {
[m[32m+                        Some(KnockResultAction::Knocked { room, .. })
[m[32m+                            if room.room_id() == frp.room_name_id.room_id() =>
[m[32m+                        {
[m                             let room_type = match room.room_type() {
                                 Some(RoomType::Space) => "space",
                                 _ => "room",
Diff in /app/src/home/add_room.rs:511:
                             };
                             enqueue_popup_notification(
[31m-                                format!("Successfully knocked on {room_type} {}.", frp.room_name_id),
[m[32m+                                format!(
[m[32m+                                    "Successfully knocked on {room_type} {}.",
[m[32m+                                    frp.room_name_id
[m[32m+                                ),
[m                                 PopupKind::Success,
                                 Some(4.0),
                             );
Diff in /app/src/home/add_room.rs:517:
                             transition_to_knocked = true;
                             break;
                         }
[31m-                        Some(KnockResultAction::Failed { error, room_or_alias_id: roai }) if room_or_alias_id == roai => {
[m[32m+                        Some(KnockResultAction::Failed {
[m[32m+                            error,
[m[32m+                            room_or_alias_id: roai,
[m[32m+                        }) if room_or_alias_id == roai => {
[m                             enqueue_popup_notification(
                                 format!("Failed to knock on room.\n\nError: {error}."),
                                 PopupKind::Error,
Diff in /app/src/home/add_room.rs:525:
                             );
                             break;
                         }
[31m-                        _ => { }
[m[32m+                        _ => {}
[m                     }

                     match action.downcast_ref() {
Diff in /app/src/home/add_room.rs:532:
[31m-                        Some(JoinRoomResultAction::Joined { room_id }) if room_id == frp.room_name_id.room_id() => {
[m[32m+                        Some(JoinRoomResultAction::Joined { room_id })
[m[32m+                            if room_id == frp.room_name_id.room_id() =>
[m[32m+                        {
[m                             let room_type = match &frp.room_type {
                                 Some(RoomType::Space) => "space",
                                 _ => "room",
Diff in /app/src/home/add_room.rs:542:
                             transition_to_joined = true;
                             break;
                         }
[31m-                        Some(JoinRoomResultAction::Failed { room_id, error }) if room_id == frp.room_name_id.room_id() => {
[m[32m+                        Some(JoinRoomResultAction::Failed { room_id, error })
[m[32m+                            if room_id == frp.room_name_id.room_id() =>
[m[32m+                        {
[m                             enqueue_popup_notification(
                                 format!("Failed to join room.\n\nError: {error}."),
                                 PopupKind::Error,
Diff in /app/src/home/add_room.rs:566:
             for action in actions {
                 // If the room/space the user is searching for has been loaded from the homeserver
                 // (e.g., by getting invited to it, or joining it in another client),
[31m-                // then update the state of
[m[31m-                if let Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, is_invite }) = action.downcast_ref() {
[m[31m-                    if self.state.fetched_room_preview().is_some_and(|frp| frp.room_name_id.room_id() == room_name_id.room_id()) {
[m[32m+                // then update the state of
[m[32m+                if let Some(AppStateAction::RoomLoadedSuccessfully {
[m[32m+                    room_name_id,
[m[32m+                    is_invite,
[m[32m+                }) = action.downcast_ref()
[m[32m+                {
[m[32m+                    if self
[m[32m+                        .state
[m[32m+                        .fetched_room_preview()
[m[32m+                        .is_some_and(|frp| frp.room_name_id.room_id() == room_name_id.room_id())
[m[32m+                    {
[m                         self.state.transition_to_loaded(*is_invite);
                         self.redraw(cx);
                     }
Diff in /app/src/home/add_room.rs:577:
         }
     }

[31m-
[m     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         let loading_room_view = self.view.view(ids!(loading_room_view));
         let fetched_room_summary = self.view.view(ids!(fetched_room_summary));
Diff in /app/src/home/add_room.rs:591:
             }
             AddRoomState::ParseError(err_str) | AddRoomState::FetchError(err_str) => {
                 loading_room_view.set_visible(cx, false);
[31m-                fetched_room_summary.set_visible(cx, false);
[m[32m+                fetched_room_summary.set_visible(cx, false);
[m                 error_view.set_visible(cx, true);
                 error_view.label(ids!(error_text)).set_text(cx, err_str);
             }
Diff in /app/src/home/add_room.rs:598:
[31m-            AddRoomState::Parsed { room_or_alias_id, .. } => {
[m[32m+            AddRoomState::Parsed {
[m[32m+                room_or_alias_id, ..
[m[32m+            } => {
[m                 loading_room_view.set_visible(cx, true);
[31m-                loading_room_view.label(ids!(loading_text)).set_text(
[m[31m-                    cx,
[m[31m-                    &format!("Fetching {room_or_alias_id}..."),
[m[31m-                );
[m[31m-                fetched_room_summary.set_visible(cx, false);
[m[32m+                loading_room_view
[m[32m+                    .label(ids!(loading_text))
[m[32m+                    .set_text(cx, &format!("Fetching {room_or_alias_id}..."));
[m[32m+                fetched_room_summary.set_visible(cx, false);
[m                 error_view.set_visible(cx, false);
             }
[31m-            ars @ AddRoomState::FetchedRoomPreview { frp, .. }
[m[32m+            ars @ AddRoomState::FetchedRoomPreview { frp, .. }
[m             | ars @ AddRoomState::Knocked { frp }
[31m-            | ars @ AddRoomState::Joined { frp }
[m[32m+            | ars @ AddRoomState::Joined { frp }
[m             | ars @ AddRoomState::Loaded { frp, .. } => {
                 loading_room_view.set_visible(cx, false);
                 fetched_room_summary.set_visible(cx, true);
Diff in /app/src/home/add_room.rs:619:
                         room_avatar.show_text(cx, None, None, text);
                     }
                     FetchedRoomAvatar::Image(image_data) => {
[31m-                        let res = room_avatar.show_image(
[m[31m-                            cx,
[m[31m-                            None,
[m[31m-                            |cx, img_ref| utils::load_png_or_jpg(&img_ref, cx, image_data),
[m[31m-                        );
[m[32m+                        let res = room_avatar.show_image(cx, None, |cx, img_ref| {
[m[32m+                            utils::load_png_or_jpg(&img_ref, cx, image_data)
[m[32m+                        });
[m                         if res.is_err() {
                             room_avatar.show_text(
                                 cx,
Diff in /app/src/home/add_room.rs:642:
                 let room_name = fetched_room_summary.label(ids!(room_name));
                 match frp.room_name_id.name_for_avatar().as_deref() {
                     Some(n) => room_name.set_text(cx, n),
[31m-                    _ => room_name.set_text(cx, &format!("Unnamed {room_or_space_uc}, ID: {}", frp.room_name_id.room_id())),
[m[32m+                    _ => room_name.set_text(
[m[32m+                        cx,
[m[32m+                        &format!(
[m[32m+                            "Unnamed {room_or_space_uc}, ID: {}",
[m[32m+                            frp.room_name_id.room_id()
[m[32m+                        ),
[m[32m+                    ),
[m                 }

[31m-                fetched_room_summary.label(ids!(subsection_alias_id)).set_text(
[m[31m-                    cx,
[m[31m-                    &format!("Main {room_or_space_uc} Alias and ID"),
[m[31m-                );
[m[32m+                fetched_room_summary
[m[32m+                    .label(ids!(subsection_alias_id))
[m[32m+                    .set_text(cx, &format!("Main {room_or_space_uc} Alias and ID"));
[m                 fetched_room_summary.label(ids!(room_alias)).set_text(
                     cx,
[31m-                    &format!("Alias: {}", frp.canonical_alias.as_ref().map_or("not set", |a| a.as_str())),
[m[32m+                    &format!(
[m[32m+                        "Alias: {}",
[m[32m+                        frp.canonical_alias
[m[32m+                            .as_ref()
[m[32m+                            .map_or("not set", |a| a.as_str())
[m[32m+                    ),
[m                 );
[31m-                fetched_room_summary.label(ids!(room_id)).set_text(
[m[31m-                    cx,
[m[31m-                    &format!("ID: {}", frp.room_name_id.room_id().as_str()),
[m[31m-                );
[m[31m-                fetched_room_summary.label(ids!(subsection_topic)).set_text(
[m[31m-                    cx,
[m[31m-                    &format!("{room_or_space_uc} Topic"),
[m[31m-                );
[m[31m-                fetched_room_summary.html(ids!(room_topic)).set_text(
[m[31m-                    cx,
[m[31m-                    frp.topic.as_deref().unwrap_or("<i>No topic set</i>"),
[m[31m-                );
[m[32m+                fetched_room_summary
[m[32m+                    .label(ids!(room_id))
[m[32m+                    .set_text(cx, &format!("ID: {}", frp.room_name_id.room_id().as_str()));
[m[32m+                fetched_room_summary
[m[32m+                    .label(ids!(subsection_topic))
[m[32m+                    .set_text(cx, &format!("{room_or_space_uc} Topic"));
[m[32m+                fetched_room_summary
[m[32m+                    .html(ids!(room_topic))
[m[32m+                    .set_text(cx, frp.topic.as_deref().unwrap_or("<i>No topic set</i>"));
[m
                 let room_summary = fetched_room_summary.label(ids!(room_summary));
                 let join_room_button = fetched_room_summary.button(ids!(join_room_button));
Diff in /app/src/home/add_room.rs:671:
                 let join_function = match (&frp.state, &frp.join_rule) {
                     (Some(RoomState::Joined), _) => {
[31m-                        room_summary.set_text(cx, &format!("You have already joined this {room_or_space_lc}."));
[m[32m+                        room_summary.set_text(
[m[32m+                            cx,
[m[32m+                            &format!("You have already joined this {room_or_space_lc}."),
[m[32m+                        );
[m                         join_room_button.set_text(cx, &format!("Go to {room_or_space_lc}"));
                         JoinButtonFunction::NavigateOrJoin
                     }
Diff in /app/src/home/add_room.rs:677:
                     (Some(RoomState::Banned), _) => {
[31m-                        room_summary.set_text(cx, &format!("You have been banned from this {room_or_space_lc}."));
[m[32m+                        room_summary.set_text(
[m[32m+                            cx,
[m[32m+                            &format!("You have been banned from this {room_or_space_lc}."),
[m[32m+                        );
[m                         join_room_button.set_text(cx, "Cannot join until un-banned");
                         JoinButtonFunction::None
                     }
Diff in /app/src/home/add_room.rs:682:
                     (Some(RoomState::Invited), _) => {
[31m-                        room_summary.set_text(cx, &format!("You have already been invited to this {room_or_space_lc}."));
[m[32m+                        room_summary.set_text(
[m[32m+                            cx,
[m[32m+                            &format!("You have already been invited to this {room_or_space_lc}."),
[m[32m+                        );
[m                         join_room_button.set_text(cx, "Go to invitation");
                         JoinButtonFunction::NavigateOrJoin
                     }
Diff in /app/src/home/add_room.rs:687:
                     (Some(RoomState::Knocked), _) => {
[31m-                        room_summary.set_text(cx, &format!("You have already knocked on this {room_or_space_lc}."));
[m[32m+                        room_summary.set_text(
[m[32m+                            cx,
[m[32m+                            &format!("You have already knocked on this {room_or_space_lc}."),
[m[32m+                        );
[m                         join_room_button.set_text(cx, "Knock again (be nice!)");
                         JoinButtonFunction::Knock
                     }
Diff in /app/src/home/add_room.rs:692:
                     (Some(RoomState::Left), join_rule) => {
[31m-                        room_summary.set_text(cx, &format!("You previously left this {room_or_space_lc}."));
[m[32m+                        room_summary
[m[32m+                            .set_text(cx, &format!("You previously left this {room_or_space_lc}."));
[m                         let (join_room_text, join_function) = match join_rule {
                             Some(JoinRuleSummary::Public) => (
                                 format!("Re-join this {room_or_space_lc}"),
Diff in /app/src/home/add_room.rs:706:
                             ),
                             // TODO: handle this after we update matrix-sdk to the new `JoinRule` enum.
                             Some(JoinRuleSummary::Restricted(_)) => (
[31m-                                format!("Re-joining {room_or_space_lc} requires an invite or other room membership"),
[m[32m+                                format!(
[m[32m+                                    "Re-joining {room_or_space_lc} requires an invite or other room membership"
[m[32m+                                ),
[m                                 JoinButtonFunction::None,
                             ),
                             _ => (
Diff in /app/src/home/add_room.rs:719:
                     }
                     // This room is not yet known to the user.
                     (None, join_rule) => {
[31m-                        let direct = if frp.is_direct == Some(true) { "direct" } else { "regular" };
[m[31m-                        room_summary.set_text(cx, &format!(
[m[31m-                            "This is a {direct} {room_or_space_lc} with {} {}.",
[m[31m-                            frp.num_joined_members,
[m[31m-                            match frp.num_joined_members {
[m[31m-                                1 => "member",
[m[31m-                                _ => "members",
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        let direct = if frp.is_direct == Some(true) {
[m[32m+                            "direct"
[m[32m+                        } else {
[m[32m+                            "regular"
[m[32m+                        };
[m[32m+                        room_summary.set_text(
[m[32m+                            cx,
[m[32m+                            &format!(
[m[32m+                                "This is a {direct} {room_or_space_lc} with {} {}.",
[m[32m+                                frp.num_joined_members,
[m[32m+                                match frp.num_joined_members {
[m[32m+                                    1 => "member",
[m[32m+                                    _ => "members",
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m
                         let (join_room_text, join_function) = match join_rule {
                             Some(JoinRuleSummary::Public) => (
Diff in /app/src/home/add_room.rs:744:
                             ),
                             // TODO: handle this after we update matrix-sdk to the new `JoinRule` enum.
                             Some(JoinRuleSummary::Restricted(_)) => (
[31m-                                format!("Joining {room_or_space_lc} requires an invite or other room membership"),
[m[32m+                                format!(
[m[32m+                                    "Joining {room_or_space_lc} requires an invite or other room membership"
[m[32m+                                ),
[m                                 JoinButtonFunction::None,
                             ),
[31m-                            _ => (
[m[32m+                            _ => (
[m                                 format!("Not allowed to join this {room_or_space_lc}"),
                                 JoinButtonFunction::None,
                             ),
Diff in /app/src/home/add_room.rs:759:

                 match ars {
                     AddRoomState::FetchedRoomPreview { .. } => {
[31m-                        join_room_button.set_enabled(cx, !matches!(join_function, JoinButtonFunction::None));
[m[32m+                        join_room_button
[m[32m+                            .set_enabled(cx, !matches!(join_function, JoinButtonFunction::None));
[m                         self.join_function = join_function;
                         join_room_button.reset_hover(cx);
[31m-                        fetched_room_summary.button(ids!(cancel_button)).reset_hover(cx);
[m[32m+                        fetched_room_summary
[m[32m+                            .button(ids!(cancel_button))
[m[32m+                            .reset_hover(cx);
[m                     }
                     AddRoomState::Knocked { .. } => {
                         room_summary.set_text(cx, &format!("You have knocked on this {room_or_space_lc} and must now wait for someone to invite you in."));
Diff in /app/src/home/add_room.rs:775:
                         join_room_button.set_enabled(cx, false);
                     }
                     AddRoomState::Loaded { is_invite, .. } => {
[31m-                        let verb = if *is_invite { "been invited to" } else { "fully joined" };
[m[31m-                        room_summary.set_text(cx, &format!("You have {verb} this {room_or_space_lc}."));
[m[32m+                        let verb = if *is_invite {
[m[32m+                            "been invited to"
[m[32m+                        } else {
[m[32m+                            "fully joined"
[m[32m+                        };
[m[32m+                        room_summary
[m[32m+                            .set_text(cx, &format!("You have {verb} this {room_or_space_lc}."));
[m                         let adj = if *is_invite { "invited" } else { "joined" };
                         join_room_button.set_text(cx, &format!("Go to {adj} {room_or_space_lc}"));
                         join_room_button.set_enabled(cx, true);
Diff in /app/src/home/add_room.rs:791:
     }
 }

[31m-
[m /// The function to perform when the user clicks the join button in the fetched room preview.
 enum JoinButtonFunction {
     None,
Diff in /app/src/home/add_room.rs:800:
     /// Knock on (request to join) a room/space.
     Knock,
 }
[31m-
[m
 /// Actions sent from the backend task as a result of a [`MatrixRequest::Knock`].
 #[derive(Debug)]
Diff in /app/src/home/add_room.rs:817:
         /// The room alias/ID that was originally sent with the knock request.
         room_or_alias_id: OwnedRoomOrAliasId,
         error: matrix_sdk::Error,
[31m-    }
[m[32m+    },
[m }

[31m-
[m /// Tries to extract a room address (Alias or ID) from the given text.
 ///
 /// This function is quite flexible and will attempt to parse `text` as:
Diff in /app/src/home/add_room.rs:834:
         Err(e) => {
             let uri_result = MatrixToUri::parse(text)
                 .map(|uri| (uri.id().clone(), uri.via().to_owned()))
[31m-                .or_else(|_| MatrixUri::parse(text).map(|uri| (uri.id().clone(), uri.via().to_owned())));
[m[31m-
[m[32m+                .or_else(|_| {
[m[32m+                    MatrixUri::parse(text).map(|uri| (uri.id().clone(), uri.via().to_owned()))
[m[32m+                });
[m[32m+
[m             if let Ok((matrix_id, via)) = uri_result {
                 if let Some(room_or_alias_id) = match matrix_id {
                     MatrixId::Room(room_id) => Some(room_id.into()),
Diff in /app/src/home/add_room.rs:848:
             }
             Err(e)
         }
[31m-    }
[m[32m+    }
[m }

Diff in /app/src/home/edited_indicator.rs:11:
 use makepad_widgets::*;
 use matrix_sdk_ui::timeline::EventTimelineItem;

[31m-use crate::{shared::callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition}, utils::unix_time_millis_to_datetime};
[m[32m+use crate::{
[m[32m+    shared::callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition},
[m[32m+    utils::unix_time_millis_to_datetime,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/edited_indicator.rs:49:
 /// A interactive label that indicates a message has been edited.
 #[derive(Live, LiveHook, Widget)]
 pub struct EditedIndicator {
[31m-    #[deref] view: View,
[m[31m-    #[rust] latest_edit_ts: Option<DateTime<Local>>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    latest_edit_ts: Option<DateTime<Local>>,
[m }

 impl Widget for EditedIndicator {
Diff in /app/src/home/edited_indicator.rs:59:

         let area = self.view.area();
         let should_hover_in = match event.hits(cx, area) {
[31m-            Hit::FingerLongPress(_)
[m[31m-            | Hit::FingerHoverIn(..) => true,
[m[32m+            Hit::FingerLongPress(_) | Hit::FingerHoverIn(..) => true,
[m             // TODO: show edit history modal on click
             // Hit::FingerUp(fue) if fue.is_over && fue.is_primary_hit() => {
             //     log!("todo: show edit history.");
Diff in /app/src/home/edited_indicator.rs:74:
         };
         if should_hover_in {
             // TODO: use pure_rust_locales crate to format the time based on the chosen Locale.
[31m-            let locale_extended_fmt_en_us= "%a %b %-d, %Y, %r";
[m[32m+            let locale_extended_fmt_en_us = "%a %b %-d, %Y, %r";
[m             let text = if let Some(ts) = self.latest_edit_ts {
                 format!("Last edited {}", ts.format(locale_extended_fmt_en_us))
             } else {
Diff in /app/src/home/edited_indicator.rs:89:
                     options: CalloutTooltipOptions {
                         position: TooltipPosition::Right,
                         ..Default::default()
[31m-                    }
[m[32m+                    },
[m                 },
             );
         }
Diff in /app/src/home/edited_indicator.rs:122:
         }
     }
 }
[31m-
[m
 /// Actions emitted by an `EditedIndicator` widget.
 #[derive(Clone, Debug, DefaultNone)]
Diff in /app/src/home/editing_pane.rs:9:
         },
     },
 };
[31m-use matrix_sdk_ui::timeline::{EventTimelineItem, MsgLikeKind, TimelineEventItemId, TimelineItemContent};
[m[32m+use matrix_sdk_ui::timeline::{
[m[32m+    EventTimelineItem, MsgLikeKind, TimelineEventItemId, TimelineItemContent,
[m[32m+};
[m
 use crate::shared::mentionable_text_input::MentionableTextInputWidgetExt;
 use crate::{
Diff in /app/src/home/editing_pane.rs:16:
[31m-    shared::popup_list::{enqueue_popup_notification, PopupKind}, sliding_sync::{submit_async_request, MatrixRequest}
[m[32m+    shared::popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest},
[m };

 live_design! {
Diff in /app/src/home/editing_pane.rs:171:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);

[31m-        if !self.visible { return; }
[m[32m+        if !self.visible {
[m[32m+            return;
[m[32m+        }
[m
         let animator_action = self.animator_handle_event(cx, event);
         if animator_action.must_redraw() {
Diff in /app/src/home/editing_pane.rs:188:
                     cx.revert_key_focus();
                     self.redraw(cx);
                     return;
[31m-                },
[m[32m+                }
[m                 (false, true) => {
                     self.is_animating_out = true;
                     return;
Diff in /app/src/home/editing_pane.rs:195:
[31m-                },
[m[31m-                _ => {},
[m[32m+                }
[m[32m+                _ => {}
[m             }
         }

Diff in /app/src/home/editing_pane.rs:200:
         if let Event::Actions(actions) = event {
[32m+            let edit_text_input = self
[m[32m+                .mentionable_text_input(ids!(editing_content.edit_text_input))
[m[32m+                .text_input_ref();
[m
[31m-            let edit_text_input = self.mentionable_text_input(ids!(editing_content.edit_text_input)).text_input_ref();
[m[31m-
[m             // Hide the editing pane if the cancel button was clicked
             // or if the `Escape` key was pressed within the edit text input.
[31m-            if self.button(ids!(cancel_button)).clicked(actions)
[m[31m-                || edit_text_input.escaped(actions)
[m[32m+            if self.button(ids!(cancel_button)).clicked(actions) || edit_text_input.escaped(actions)
[m             {
                 self.animator_play(cx, ids!(panel.hide));
                 self.redraw(cx);
Diff in /app/src/home/editing_pane.rs:211:
                 return;
             }

[31m-            let Some(info) = self.info.as_ref() else { return };
[m[32m+            let Some(info) = self.info.as_ref() else {
[m[32m+                return;
[m[32m+            };
[m
             if self.button(ids!(accept_button)).clicked(actions)
[31m-                || edit_text_input.returned(actions).is_some_and(|(_, m)| m.is_primary())
[m[32m+                || edit_text_input
[m[32m+                    .returned(actions)
[m[32m+                    .is_some_and(|(_, m)| m.is_primary())
[m             {
                 let edited_text = edit_text_input.text().trim().to_string();
                 let edited_content = match info.event_tl_item.content() {
Diff in /app/src/home/editing_pane.rs:229:

                                     // TODO: also handle "/html" or "/plain" prefixes, just like when sending new messages.
                                     MessageType::Text(_text) => EditedContent::RoomMessage(
[31m-                                        RoomMessageEventContentWithoutRelation::text_markdown(&edited_text),
[m[32m+                                        RoomMessageEventContentWithoutRelation::text_markdown(
[m[32m+                                            &edited_text,
[m[32m+                                        ),
[m                                     ),
                                     MessageType::Emote(_emote) => EditedContent::RoomMessage(
                                         RoomMessageEventContentWithoutRelation::emote_markdown(
Diff in /app/src/home/editing_pane.rs:243:
                                     MessageType::Image(image) => {
                                         let mut new_image_msg = image.clone();
                                         if image.formatted.is_some() {
[31m-                                            new_image_msg.formatted = FormattedBody::markdown(&edited_text);
[m[32m+                                            new_image_msg.formatted =
[m[32m+                                                FormattedBody::markdown(&edited_text);
[m                                         }
                                         new_image_msg.body = edited_text.clone();
                                         EditedContent::RoomMessage(
Diff in /app/src/home/editing_pane.rs:251:
                                                 MessageType::Image(new_image_msg),
                                             ),
                                         )
[31m-                                    },
[m[32m+                                    }
[m                                     MessageType::Audio(audio) => {
                                         let mut new_audio_msg = audio.clone();
                                         if audio.formatted.is_some() {
Diff in /app/src/home/editing_pane.rs:258:
[31m-                                            new_audio_msg.formatted = FormattedBody::markdown(&edited_text);
[m[32m+                                            new_audio_msg.formatted =
[m[32m+                                                FormattedBody::markdown(&edited_text);
[m                                         }
                                         new_audio_msg.body = edited_text.clone();
                                         EditedContent::RoomMessage(
Diff in /app/src/home/editing_pane.rs:263:
                                                 MessageType::Audio(new_audio_msg),
                                             ),
                                         )
[31m-                                    },
[m[32m+                                    }
[m                                     MessageType::File(file) => {
                                         let mut new_file_msg = file.clone();
                                         if file.formatted.is_some() {
Diff in /app/src/home/editing_pane.rs:270:
[31m-                                            new_file_msg.formatted = FormattedBody::markdown(&edited_text);
[m[32m+                                            new_file_msg.formatted =
[m[32m+                                                FormattedBody::markdown(&edited_text);
[m                                         }
                                         new_file_msg.body = edited_text.clone();
                                         EditedContent::RoomMessage(
Diff in /app/src/home/editing_pane.rs:274:
[31m-                                            RoomMessageEventContentWithoutRelation::new(MessageType::File(
[m[31m-                                                new_file_msg,
[m[31m-                                            )),
[m[32m+                                            RoomMessageEventContentWithoutRelation::new(
[m[32m+                                                MessageType::File(new_file_msg),
[m[32m+                                            ),
[m                                         )
[31m-                                    },
[m[32m+                                    }
[m                                     MessageType::Video(video) => {
                                         let mut new_video_msg = video.clone();
                                         if video.formatted.is_some() {
Diff in /app/src/home/editing_pane.rs:282:
[31m-                                            new_video_msg.formatted = FormattedBody::markdown(&edited_text);
[m[32m+                                            new_video_msg.formatted =
[m[32m+                                                FormattedBody::markdown(&edited_text);
[m                                         }
                                         new_video_msg.body = edited_text.clone();
                                         EditedContent::RoomMessage(
Diff in /app/src/home/editing_pane.rs:287:
                                                 MessageType::Video(new_video_msg),
                                             ),
                                         )
[31m-                                    },
[m[32m+                                    }
[m                                     _non_editable => {
                                         enqueue_popup_notification(
                                             "That message type cannot be edited.",
Diff in /app/src/home/editing_pane.rs:297:
                                         self.animator_play(cx, ids!(panel.hide));
                                         self.redraw(cx);
                                         return;
[31m-                                    },
[m[32m+                                    }
[m                                 };

                                 // TODO: extract mentions out of the new edited text and use them here.
Diff in /app/src/home/editing_pane.rs:305:
                                     if let EditedContent::RoomMessage(new_message_content) =
                                         &mut edited_content
                                     {
[31m-                                        new_message_content.mentions = Some(existing_mentions.clone());
[m[32m+                                        new_message_content.mentions =
[m[32m+                                            Some(existing_mentions.clone());
[m                                     }
                                     // TODO: once we update the matrix-sdk dependency, uncomment this.
                                     // EditedContent::MediaCaption { mentions, .. }) => {
Diff in /app/src/home/editing_pane.rs:346:
                                     fallback_text: edited_text,
                                     new_content: new_content_block,
                                 }
[31m-
[m                             }
                             _ => {
                                 enqueue_popup_notification(
Diff in /app/src/home/editing_pane.rs:365:
                             None,
                         );
                         return;
[31m-                    },
[m[32m+                    }
[m                 };

                 submit_async_request(MatrixRequest::EditMessage {
Diff in /app/src/home/editing_pane.rs:414:
         match edit_result {
             Ok(()) => {
                 self.animator_play(cx, ids!(panel.hide));
[31m-            },
[m[32m+            }
[m             Err(e) => {
                 enqueue_popup_notification(
                     format!("Failed to edit message: {}", e),
Diff in /app/src/home/editing_pane.rs:421:
                     PopupKind::Error,
                     None,
                 );
[31m-            },
[m[32m+            }
[m         }
     }

Diff in /app/src/home/editing_pane.rs:428:
     /// Shows the editing pane and sets it up to edit the given `event`'s content.
     pub fn show(&mut self, cx: &mut Cx, event_tl_item: EventTimelineItem, room_id: OwnedRoomId) {
         if !event_tl_item.is_editable() {
[31m-            enqueue_popup_notification(
[m[31m-                "That message cannot be edited.",
[m[31m-                PopupKind::Error,
[m[31m-                None,
[m[31m-            );
[m[32m+            enqueue_popup_notification("That message cannot be edited.", PopupKind::Error, None);
[m             return;
         }

Diff in /app/src/home/editing_pane.rs:443:
         } else if let Some(poll) = event_tl_item.content().as_poll() {
             edit_text_input.set_text(cx, &poll.results().question);
         } else {
[31m-            enqueue_popup_notification(
[m[31m-                "That message cannot be edited.",
[m[31m-                PopupKind::Error,
[m[31m-                None,
[m[31m-            );
[m[32m+            enqueue_popup_notification("That message cannot be edited.", PopupKind::Error, None);
[m             return;
         }

Diff in /app/src/home/editing_pane.rs:454:
[32m+        self.info = Some(EditingPaneInfo {
[m[32m+            event_tl_item,
[m[32m+            room_id: room_id.clone(),
[m[32m+        });
[m
[31m-        self.info = Some(EditingPaneInfo { event_tl_item, room_id: room_id.clone() });
[m[31m-
[m         self.visible = true;
         self.button(ids!(accept_button)).reset_hover(cx);
         self.button(ids!(cancel_button)).reset_hover(cx);
Diff in /app/src/home/editing_pane.rs:464:
         let text_len = edit_text_input.text().len();
         inner_text_input.set_cursor(
             cx,
[31m-            Cursor { index: text_len, prefer_next_row: false },
[m[32m+            Cursor {
[m[32m+                index: text_len,
[m[32m+                prefer_next_row: false,
[m[32m+            },
[m             false,
         );
         inner_text_input.set_key_focus(cx);
Diff in /app/src/home/editing_pane.rs:489:
         editing_pane_state: EditingPaneState,
         room_id: OwnedRoomId,
     ) {
[31m-        let EditingPaneState { event_tl_item, text_input_state } = editing_pane_state;
[m[32m+        let EditingPaneState {
[m[32m+            event_tl_item,
[m[32m+            text_input_state,
[m[32m+        } = editing_pane_state;
[m         self.mentionable_text_input(ids!(editing_content.edit_text_input))
             .text_input_ref()
             .restore_state(cx, text_input_state);
Diff in /app/src/home/editing_pane.rs:496:
[31m-        self.info = Some(EditingPaneInfo { event_tl_item, room_id: room_id.clone() });
[m[32m+        self.info = Some(EditingPaneInfo {
[m[32m+            event_tl_item,
[m[32m+            room_id: room_id.clone(),
[m[32m+        });
[m         self.visible = true;
         self.button(ids!(accept_button)).reset_hover(cx);
         self.button(ids!(cancel_button)).reset_hover(cx);
Diff in /app/src/home/editing_pane.rs:523:
         timeline_event_item_id: TimelineEventItemId,
         edit_result: Result<(), matrix_sdk_ui::timeline::Error>,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.handle_edit_result(cx, timeline_event_item_id, edit_result);
     }

Diff in /app/src/home/editing_pane.rs:558:
         editing_pane_state: EditingPaneState,
         room_id: OwnedRoomId,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.restore_state(cx, editing_pane_state, room_id);
     }

Diff in /app/src/home/editing_pane.rs:566:
     ///
     /// This function *DOES NOT* emit an [`EditingPaneAction::Hidden`] action.
     pub fn force_reset_hide(&self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.visible = false;
         inner.animator_cut(cx, ids!(panel.hide));
         inner.is_animating_out = false;
Diff in /app/src/home/event_reaction_list.rs:183:
                         let (bg_color, border_color) = if !reaction_data.includes_user {
                             (EMOJI_BG_COLOR_INCLUDE_SELF, EMOJI_BORDER_COLOR_INCLUDE_SELF)
                         } else {
[31m-                            (EMOJI_BG_COLOR_NOT_INCLUDE_SELF, EMOJI_BORDER_COLOR_NOT_INCLUDE_SELF)
[m[32m+                            (
[m[32m+                                EMOJI_BG_COLOR_NOT_INCLUDE_SELF,
[m[32m+                                EMOJI_BORDER_COLOR_NOT_INCLUDE_SELF,
[m[32m+                            )
[m                         };
                         button_ref.apply_over(cx, live! {
                             draw_bg: { reaction_bg_color: (bg_color) , reaction_border_color: (border_color) }
Diff in /app/src/home/event_reaction_list.rs:224:
     }

     /// Deals with to any event/hit that triggers a hover-out action.
[31m-    fn do_hover_out(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        scope: &mut Scope,
[m[31m-        button_ref: &ButtonRef,
[m[31m-    ) {
[m[31m-        cx.widget_action(self.widget_uid(), &scope.path, RoomScreenTooltipActions::HoverOut);
[m[32m+    fn do_hover_out(&self, cx: &mut Cx, scope: &mut Scope, button_ref: &ButtonRef) {
[m[32m+        cx.widget_action(
[m[32m+            self.widget_uid(),
[m[32m+            &scope.path,
[m[32m+            RoomScreenTooltipActions::HoverOut,
[m[32m+        );
[m         button_ref.apply_over(cx, live!(draw_bg: {hover: 0.0}));
         cx.set_cursor(MouseCursor::Default);
     }
Diff in /app/src/home/event_reaction_list.rs:237:
 }

[31m-
[m impl ReactionListRef {
     /// Set the list of reactions and their counts to display in the ReactionList widget,
     /// along with the room ID and event ID that these reactions are for.
Diff in /app/src/home/event_reaction_list.rs:279:
                     includes_user = true;
                 }
                 // Prefill each reactor's user profile into the cache so the tooltip will show their display name.
[31m-                let _ = user_profile_cache::with_user_profile(cx, sender.clone(), Some(&room_id), true, |_, _| { });
[m[32m+                let _ = user_profile_cache::with_user_profile(
[m[32m+                    cx,
[m[32m+                    sender.clone(),
[m[32m+                    Some(&room_id),
[m[32m+                    true,
[m[32m+                    |_, _| {},
[m[32m+                );
[m             }

             let reaction_data = ReactionData {
Diff in /app/src/home/event_reaction_list.rs:291:
             let button = WidgetRef::new_from_ptr(cx, inner.item).as_button();
             button.set_text(
                 cx,
[31m-                &format!(
[m[31m-                    "{}  {}",
[m[31m-                    reaction_data.reaction,
[m[31m-                    reaction_senders.len()
[m[31m-                ),
[m[32m+                &format!("{}  {}", reaction_data.reaction, reaction_senders.len()),
[m             );
             let (bg_color, border_color) = if reaction_data.includes_user {
                 (EMOJI_BG_COLOR_INCLUDE_SELF, EMOJI_BORDER_COLOR_INCLUDE_SELF)
Diff in /app/src/home/event_source_modal.rs:6:

 use crate::shared::popup_list::{PopupKind, enqueue_popup_notification};

[31m-
[m live_design! {
     use link::theme::*;
     use link::widgets::*;
Diff in /app/src/home/event_source_modal.rs:70:
         height: Fill // { max: 1400 }
         margin: 40,
         align: {x: 0.5, y: 0}
[31m-
[m[32m+
[m         flow: Down
         padding: {top: 20, right: 25, bottom: 20, left: 25}

Diff in /app/src/home/event_source_modal.rs:159:
         code_block = <View> {
             width: Fill,
             height: Fit,
[31m-            flow: Overlay
[m[32m+            flow: Overlay
[m             // align the left side of the border frame with the left side of the room id / event id rows
             padding: 6

Diff in /app/src/home/event_source_modal.rs:209:

                     fn pixel(self) -> vec4 {
                         let sdf = Sdf2d::viewport(self.pos * self.rect_size);
[31m-
[m[32m+
[m                         // Draw rounded box - but only the stroke, no fill
                         sdf.box(
                             self.border_size * 0.5,
Diff in /app/src/home/event_source_modal.rs:218:
                             self.rect_size.y - self.border_size,
                             self.border_radius
                         );
[31m-
[m[32m+
[m                         // Fill with transparent (let content show through)
                         sdf.fill_keep(vec4(0.0, 0.0, 0.0, 0.0));
[31m-
[m[32m+
[m                         // Draw the border stroke
                         sdf.stroke(self.border_color, self.border_size);
[31m-
[m[32m+
[m                         return sdf.result;
                     }
                 }
Diff in /app/src/home/event_source_modal.rs:251:
     Close,
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct EventSourceModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] room_id: Option<OwnedRoomId>,
[m[31m-    #[rust] event_id: Option<OwnedEventId>,
[m[31m-    #[rust] original_json: Option<String>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    room_id: Option<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    event_id: Option<OwnedEventId>,
[m[32m+    #[rust]
[m[32m+    original_json: Option<String>,
[m }

 impl Widget for EventSourceModal {
Diff in /app/src/home/event_source_modal.rs:277:

         // Handle canceling/closing the modal.
         let close_clicked = close_button.clicked(actions);
[31m-        if close_clicked ||
[m[31m-            actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m[32m+        if close_clicked
[m[32m+            || actions
[m[32m+                .iter()
[m[32m+                .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m         {
             // If the modal was dismissed by clicking outside of it, we MUST NOT emit
             // an EventSourceModalAction::Close action, as that would cause
Diff in /app/src/home/event_source_modal.rs:289:
             return;
         }

[31m-        if self.view.button(ids!(room_id_row.copy_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(room_id_row.copy_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             if let Some(room_id) = &self.room_id {
                 cx.copy_to_clipboard(room_id.as_str());
                 enqueue_popup_notification(
Diff in /app/src/home/event_source_modal.rs:300:
             }
         }

[31m-        if self.view.button(ids!(event_id_row.copy_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(event_id_row.copy_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             if let Some(event_id) = &self.event_id {
                 cx.copy_to_clipboard(event_id.as_str());
                 enqueue_popup_notification(
Diff in /app/src/home/event_source_modal.rs:337:
         self.event_id = event_id.clone();
         self.original_json = original_json.clone();

[31m-        self.view.label(ids!(room_id_row.value)).set_text(cx, room_id.as_str());
[m[32m+        self.view
[m[32m+            .label(ids!(room_id_row.value))
[m[32m+            .set_text(cx, room_id.as_str());
[m         self.view.label(ids!(event_id_row.value)).set_text(
             cx,
[31m-            event_id.as_ref().map(|e| e.as_str()).unwrap_or("<Event ID Unknown>"),
[m[32m+            event_id
[m[32m+                .as_ref()
[m[32m+                .map(|e| e.as_str())
[m[32m+                .unwrap_or("<Event ID Unknown>"),
[m         );

         self.view.code_view(ids!(code_view)).set_text(
Diff in /app/src/home/event_source_modal.rs:347:
             cx,
[31m-            original_json.as_deref().unwrap_or("<Unable to load event source JSON>"),
[m[32m+            original_json
[m[32m+                .as_deref()
[m[32m+                .unwrap_or("<Unable to load event source JSON>"),
[m         );

         self.view.button(ids!(close_button)).reset_hover(cx);
Diff in /app/src/home/event_source_modal.rs:352:
[31m-        self.view.button(ids!(room_id_row.copy_button)).reset_hover(cx);
[m[31m-        self.view.button(ids!(event_id_row.copy_button)).reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(room_id_row.copy_button))
[m[32m+            .reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(event_id_row.copy_button))
[m[32m+            .reset_hover(cx);
[m         self.view.button(ids!(copy_source_button)).reset_hover(cx);
         self.view.redraw(cx);
     }
Diff in /app/src/home/event_source_modal.rs:365:
         event_id: Option<OwnedEventId>,
         original_json: Option<String>,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx, room_id, event_id, original_json);
     }
 }
Diff in /app/src/home/home_screen.rs:1:
 use makepad_widgets::*;

[31m-use crate::{app::AppState, home::navigation_tab_bar::{NavigationBarAction, SelectedTab}, settings::settings_screen::SettingsScreenWidgetRefExt};
[m[32m+use crate::{
[m[32m+    app::AppState,
[m[32m+    home::navigation_tab_bar::{NavigationBarAction, SelectedTab},
[m[32m+    settings::settings_screen::SettingsScreenWidgetRefExt,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/home_screen.rs:202:
                             // We wrap it in the SpacesBarWrapper in order to animate it in or out,
                             // and wrap *that* in a CachedWidget in order to maintain its shown/hidden state
                             // across AdaptiveView transitions between Mobile view mode and Desktop view mode.
[31m-                            //
[m[32m+                            //
[m                             // ... Then we wrap *that* in a ... <https://www.youtube.com/watch?v=evUWersr7pc>
                             <CachedWidget> {
                                 spaces_bar_wrapper = <SpacesBarWrapper> {}
Diff in /app/src/home/home_screen.rs:222:
                                 // a special view, the `StackViewHeader`.
                                 clip_x:false,
                                 clip_y:false,
[31m-
[m[32m+
[m                                 show_bg: true,
                                 draw_bg: {
                                     uniform color_dither: 1.0
Diff in /app/src/home/home_screen.rs:229:
[31m-                                    uniform gradient_border_horizontal: 0.0;
[m[31m-                                    uniform gradient_fill_horizontal: 0.0;
[m[32m+                                    uniform gradient_border_horizontal: 0.0;
[m[32m+                                    uniform gradient_fill_horizontal: 0.0;
[m
                                     color: (COLOR_PRIMARY_DARKER)
                                     uniform color_2: vec4(-1.0, -1.0, -1.0, -1.0)
Diff in /app/src/home/home_screen.rs:240:
                                     uniform shadow_color: #0005
                                     uniform shadow_radius: 9.0,
                                     uniform shadow_offset: vec2(1.0, 0.0)
[31m-
[m[32m+
[m                                     varying rect_size2: vec2,
                                     varying rect_size3: vec2,
[31m-                                    varying rect_pos2: vec2,
[m[31m-                                    varying rect_shift: vec2,
[m[32m+                                    varying rect_pos2: vec2,
[m[32m+                                    varying rect_shift: vec2,
[m                                     varying sdf_rect_pos: vec2,
                                     varying sdf_rect_size: vec2,
[31m-
[m[32m+
[m                                     fn vertex(self) -> vec4 {
                                         let min_offset = min(self.shadow_offset,vec2(0));
                                         self.rect_size2 = self.rect_size + 2.0*vec2(self.shadow_radius);
Diff in /app/src/home/home_screen.rs:256:
                                         self.sdf_rect_size = self.rect_size2 - vec2(self.shadow_radius * 2.0 + self.border_size * 2.0)
                                         self.sdf_rect_pos = -min_offset + vec2(self.border_size + self.shadow_radius);
                                         self.rect_shift = -min_offset;
[31m-
[m[32m+
[m                                         return self.clip_and_transform_vertex(self.rect_pos2, self.rect_size3)
                                     }
[31m-
[m[31m-                                    fn pixel(self) -> vec4 {
[m[32m+
[m[32m+                                    fn pixel(self) -> vec4 {
[m                                         let sdf = Sdf2d::viewport(self.pos * self.rect_size3)
                                         let dither = Math::random_2d(self.pos.xy) * 0.04 * self.color_dither;

Diff in /app/src/home/home_screen.rs:288:
                                             self.sdf_rect_pos.x,
                                             self.sdf_rect_pos.y,
                                             self.sdf_rect_size.x,
[31m-                                            self.sdf_rect_size.y,
[m[32m+                                            self.sdf_rect_size.y,
[m                                             max(1.0, self.border_radius)
                                         )
                                         if sdf.shape > -1.0{ // try to skip the expensive gauss shadow
Diff in /app/src/home/home_screen.rs:297:
                                             let v = GaussShadow::rounded_box_shadow(vec2(m) + o, self.rect_size2+o, self.pos * (self.rect_size3+vec2(m)), self.shadow_radius*0.5, self.border_radius*2.0);
                                             sdf.clear(self.shadow_color*v)
                                         }
[31m-
[m[32m+
[m                                         sdf.fill_keep(mix(self.color, color_2, gradient_fill_dir))

                                         if self.border_size > 0.0 {
Diff in /app/src/home/home_screen.rs:352:
     }
 }

[31m-
[m /// A simple wrapper around the SpacesBar that allows us to animate showing or hiding it.
 #[derive(Live, LiveHook, Widget)]
 pub struct SpacesBarWrapper {
Diff in /app/src/home/home_screen.rs:359:
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m }

 impl Widget for SpacesBarWrapper {
Diff in /app/src/home/home_screen.rs:382:
 impl SpacesBarWrapperRef {
     /// Shows or hides the spaces bar by animating it in or out.
     fn show_or_hide(&self, cx: &mut Cx, show: bool) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         if show {
             inner.animator_play(cx, ids!(spaces_bar_animator.show));
         } else {
Diff in /app/src/home/home_screen.rs:392:
     }
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct HomeScreen {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// The previously-selected navigation tab, used to determine which tab
     /// and top-level view we return to after closing the settings screen.
Diff in /app/src/home/home_screen.rs:402:
     ///
     /// Note that the current selected tap is stored in `AppState` so that
     /// other widgets can easily access it.
[31m-    #[rust] previous_selection: SelectedTab,
[m[31m-    #[rust] is_spaces_bar_shown: bool,
[m[32m+    #[rust]
[m[32m+    previous_selection: SelectedTab,
[m[32m+    #[rust]
[m[32m+    is_spaces_bar_shown: bool,
[m }

 impl Widget for HomeScreen {
Diff in /app/src/home/home_screen.rs:416:
                         if !matches!(app_state.selected_tab, SelectedTab::Home) {
                             self.previous_selection = app_state.selected_tab.clone();
                             app_state.selected_tab = SelectedTab::Home;
[31m-                            cx.action(NavigationBarAction::TabSelected(app_state.selected_tab.clone()));
[m[32m+                            cx.action(NavigationBarAction::TabSelected(
[m[32m+                                app_state.selected_tab.clone(),
[m[32m+                            ));
[m                             self.update_active_page_from_selection(cx, app_state);
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/home_screen.rs:425:
                         if !matches!(app_state.selected_tab, SelectedTab::AddRoom) {
                             self.previous_selection = app_state.selected_tab.clone();
                             app_state.selected_tab = SelectedTab::AddRoom;
[31m-                            cx.action(NavigationBarAction::TabSelected(app_state.selected_tab.clone()));
[m[32m+                            cx.action(NavigationBarAction::TabSelected(
[m[32m+                                app_state.selected_tab.clone(),
[m[32m+                            ));
[m                             self.update_active_page_from_selection(cx, app_state);
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/home_screen.rs:432:
                     }
                     Some(NavigationBarAction::GoToSpace { space_name_id }) => {
[31m-                        let new_space_selection = SelectedTab::Space { space_name_id: space_name_id.clone() };
[m[32m+                        let new_space_selection = SelectedTab::Space {
[m[32m+                            space_name_id: space_name_id.clone(),
[m[32m+                        };
[m                         if app_state.selected_tab != new_space_selection {
                             self.previous_selection = app_state.selected_tab.clone();
                             app_state.selected_tab = new_space_selection;
Diff in /app/src/home/home_screen.rs:438:
[31m-                            cx.action(NavigationBarAction::TabSelected(app_state.selected_tab.clone()));
[m[32m+                            cx.action(NavigationBarAction::TabSelected(
[m[32m+                                app_state.selected_tab.clone(),
[m[32m+                            ));
[m                             self.update_active_page_from_selection(cx, app_state);
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/home_screen.rs:445:
                         if !matches!(app_state.selected_tab, SelectedTab::Settings) {
                             self.previous_selection = app_state.selected_tab.clone();
                             app_state.selected_tab = SelectedTab::Settings;
[31m-                            cx.action(NavigationBarAction::TabSelected(app_state.selected_tab.clone()));
[m[31m-                            if let Some(settings_page) = self.update_active_page_from_selection(cx, app_state) {
[m[32m+                            cx.action(NavigationBarAction::TabSelected(
[m[32m+                                app_state.selected_tab.clone(),
[m[32m+                            ));
[m[32m+                            if let Some(settings_page) =
[m[32m+                                self.update_active_page_from_selection(cx, app_state)
[m[32m+                            {
[m                                 settings_page
                                     .settings_screen(ids!(settings_screen))
                                     .populate(cx, None);
Diff in /app/src/home/home_screen.rs:459:
                     Some(NavigationBarAction::CloseSettings) => {
                         if matches!(app_state.selected_tab, SelectedTab::Settings) {
                             app_state.selected_tab = self.previous_selection.clone();
[31m-                            cx.action(NavigationBarAction::TabSelected(app_state.selected_tab.clone()));
[m[32m+                            cx.action(NavigationBarAction::TabSelected(
[m[32m+                                app_state.selected_tab.clone(),
[m[32m+                            ));
[m                             self.update_active_page_from_selection(cx, app_state);
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/home_screen.rs:466:
                     }
                     Some(NavigationBarAction::ToggleSpacesBar) => {
                         self.is_spaces_bar_shown = !self.is_spaces_bar_shown;
[31m-                        self.view.spaces_bar_wrapper(ids!(spaces_bar_wrapper))
[m[32m+                        self.view
[m[32m+                            .spaces_bar_wrapper(ids!(spaces_bar_wrapper))
[m                             .show_or_hide(cx, self.is_spaces_bar_shown);
                     }
                     // We're the ones who emitted this action, so we don't need to handle it again.
Diff in /app/src/home/home_screen.rs:473:
[31m-                    Some(NavigationBarAction::TabSelected(_))
[m[31m-                    | None => { }
[m[32m+                    Some(NavigationBarAction::TabSelected(_)) | None => {}
[m                 }
             }
         }
Diff in /app/src/home/home_screen.rs:502:
             .set_active_page(
                 cx,
                 match app_state.selected_tab {
[31m-                    SelectedTab::Space { .. }
[m[31m-                    | SelectedTab::Home => id!(home_page),
[m[32m+                    SelectedTab::Space { .. } | SelectedTab::Home => id!(home_page),
[m                     SelectedTab::Settings => id!(settings_page),
                     SelectedTab::AddRoom => id!(add_room_page),
                 },
Diff in /app/src/home/home_screen.rs:515:
 /// that simply forwards stack view actions to it.
 #[derive(Live, LiveHook, Widget)]
 pub struct StackNavigationWrapper {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 impl Widget for StackNavigationWrapper {
Diff in /app/src/home/invite_modal.rs:8:
 use crate::sliding_sync::{MatrixRequest, submit_async_request};
 use crate::utils::RoomNameId;

[31m-
[m live_design! {
     use link::theme::*;
     use link::widgets::*;
Diff in /app/src/home/invite_modal.rs:178:
     InviteError,
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct InviteModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: InviteModalState,
[m[31m-    #[rust] room_name_id: Option<RoomNameId>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: InviteModalState,
[m[32m+    #[rust]
[m[32m+    room_name_id: Option<RoomNameId>,
[m }

 impl Widget for InviteModal {
Diff in /app/src/home/invite_modal.rs:203:

         // Handle canceling/closing the modal.
         let cancel_clicked = cancel_button.clicked(actions);
[31m-        if cancel_clicked ||
[m[31m-            actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m[32m+        if cancel_clicked
[m[32m+            || actions
[m[32m+                .iter()
[m[32m+                .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m         {
             // If the modal was dismissed by clicking outside of it, we MUST NOT emit
             // a `InviteModalAction::Close` action, as that would cause
Diff in /app/src/home/invite_modal.rs:228:
         let status_label_view = self.view.label(ids!(status_label_view.status_label));

         // Handle return key or invite button click.
[31m-        if let Some(user_id_str) = confirm_button.clicked(actions)
[m[32m+        if let Some(user_id_str) = confirm_button
[m[32m+            .clicked(actions)
[m             .then(|| user_id_input.text())
             .or_else(|| user_id_input.returned(actions).map(|(t, _)| t))
         {
Diff in /app/src/home/invite_modal.rs:235:
             // Validate the user ID
             if user_id_str.is_empty() {
[31m-                status_label_view.apply_over(cx, live!{
[m[31m-                    text: "Please enter a user ID.",
[m[31m-                    draw_text: {
[m[31m-                        color: (COLOR_FG_DANGER_RED),
[m[32m+                status_label_view.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        text: "Please enter a user ID.",
[m[32m+                        draw_text: {
[m[32m+                            color: (COLOR_FG_DANGER_RED),
[m[32m+                        },
[m                     },
[31m-                });
[m[32m+                );
[m                 status_view.set_visible(cx, true);
                 self.view.redraw(cx);
                 return;
Diff in /app/src/home/invite_modal.rs:254:
                             user_id: user_id.to_owned(),
                         });
                         self.state = InviteModalState::WaitingForInvite(user_id.to_owned());
[31m-                        status_label_view.apply_over(cx, live!(
[m[31m-                            text: "Sending invite...",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_ACTIVE_PRIMARY_DARKER),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label_view.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Sending invite...",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_ACTIVE_PRIMARY_DARKER),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                         status_view.set_visible(cx, true);
                         confirm_button.set_enabled(cx, false);
                         user_id_input.set_is_read_only(cx, true);
Diff in /app/src/home/invite_modal.rs:266:
                     }
                 }
                 Err(_) => {
[31m-                    status_label_view.apply_over(cx, live!(
[m[31m-                        text: "Invalid User ID. Expected format: @user:server.xyz",
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_FG_DANGER_RED),
[m[31m-                        },
[m[31m-                    ));
[m[32m+                    status_label_view.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            text: "Invalid User ID. Expected format: @user:server.xyz",
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_FG_DANGER_RED),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m                     status_view.set_visible(cx, true);
                     user_id_input.set_key_focus(cx);
                 }
Diff in /app/src/home/invite_modal.rs:284:
             for action in actions {
                 let new_state = match action.downcast_ref() {
                     Some(InviteResultAction::Sent { room_id, user_id })
[31m-                        if self.room_name_id.as_ref().is_some_and(|rni| rni.room_id() == room_id)
[m[31m-                            && invited_user_id == user_id
[m[31m-                    => {
[m[32m+                        if self
[m[32m+                            .room_name_id
[m[32m+                            .as_ref()
[m[32m+                            .is_some_and(|rni| rni.room_id() == room_id)
[m[32m+                            && invited_user_id == user_id =>
[m[32m+                    {
[m                         let status = format!("Successfully invited {user_id}!");
[31m-                        status_label_view.apply_over(cx, live!{
[m[31m-                            text: (status),
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_FG_ACCEPT_GREEN)
[m[31m-                            }
[m[31m-                        });
[m[32m+                        status_label_view.apply_over(
[m[32m+                            cx,
[m[32m+                            live! {
[m[32m+                                text: (status),
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_FG_ACCEPT_GREEN)
[m[32m+                                }
[m[32m+                            },
[m[32m+                        );
[m                         status_view.set_visible(cx, true);
                         confirm_button.set_visible(cx, false);
                         cancel_button.set_visible(cx, false);
Diff in /app/src/home/invite_modal.rs:300:
                         okay_button.set_visible(cx, true);
                         Some(InviteModalState::InviteSuccess)
                     }
[31m-                    Some(InviteResultAction::Failed { room_id, user_id, error })
[m[31m-                        if self.room_name_id.as_ref().is_some_and(|rni| rni.room_id() == room_id)
[m[31m-                            && invited_user_id == user_id
[m[31m-                    => {
[m[32m+                    Some(InviteResultAction::Failed {
[m[32m+                        room_id,
[m[32m+                        user_id,
[m[32m+                        error,
[m[32m+                    }) if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|rni| rni.room_id() == room_id)
[m[32m+                        && invited_user_id == user_id =>
[m[32m+                    {
[m                         let status = format!("Failed to send invite: {error}");
[31m-                        status_label_view.apply_over(cx, live!{
[m[31m-                            text: (status),
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_FG_DANGER_RED),
[m[31m-                            }
[m[31m-                        });
[m[32m+                        status_label_view.apply_over(
[m[32m+                            cx,
[m[32m+                            live! {
[m[32m+                                text: (status),
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_FG_DANGER_RED),
[m[32m+                                }
[m[32m+                            },
[m[32m+                        );
[m                         status_view.set_visible(cx, true);
                         confirm_button.set_enabled(cx, true);
                         user_id_input.set_is_read_only(cx, false);
Diff in /app/src/home/invite_modal.rs:331:

 impl InviteModal {
     pub fn show(&mut self, cx: &mut Cx, room_name_id: RoomNameId) {
[31m-        self.view.label(ids!(title)).set_text(
[m[31m-            cx,
[m[31m-            &format!("Invite to {room_name_id}"),
[m[31m-        );
[m[32m+        self.view
[m[32m+            .label(ids!(title))
[m[32m+            .set_text(cx, &format!("Invite to {room_name_id}"));
[m         self.state = InviteModalState::WaitingForUserInput;
         self.room_name_id = Some(room_name_id);

Diff in /app/src/home/invite_modal.rs:353:
         okay_button.reset_hover(cx);
         user_id_input.set_is_read_only(cx, false);
         user_id_input.set_text(cx, "");
[31m-        self.view.view(ids!(status_label_view)).set_visible(cx, false);
[m[31m-        self.view.label(ids!(status_label_view.status_label)).set_text(cx, "");
[m[32m+        self.view
[m[32m+            .view(ids!(status_label_view))
[m[32m+            .set_visible(cx, false);
[m[32m+        self.view
[m[32m+            .label(ids!(status_label_view.status_label))
[m[32m+            .set_text(cx, "");
[m         self.view.redraw(cx);
     }
 }
Diff in /app/src/home/invite_modal.rs:361:

 impl InviteModalRef {
     pub fn show(&self, cx: &mut Cx, room_name_id: RoomNameId) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx, room_name_id);
     }
 }
Diff in /app/src/home/invite_screen.rs:8:
 use makepad_widgets::*;
 use matrix_sdk::ruma::OwnedRoomId;

[31m-use crate::{app::AppStateAction, home::rooms_list::RoomsListRef, join_leave_room_modal::{JoinLeaveModalKind, JoinLeaveRoomModalAction}, room::{BasicRoomDetails, FetchedRoomAvatar}, shared::{avatar::AvatarWidgetRefExt, popup_list::{enqueue_popup_notification, PopupKind}, restore_status_view::RestoreStatusViewWidgetExt}, sliding_sync::{submit_async_request, MatrixRequest}, utils::{self, RoomNameId}};
[m[32m+use crate::{
[m[32m+    app::AppStateAction,
[m[32m+    home::rooms_list::RoomsListRef,
[m[32m+    join_leave_room_modal::{JoinLeaveModalKind, JoinLeaveRoomModalAction},
[m[32m+    room::{BasicRoomDetails, FetchedRoomAvatar},
[m[32m+    shared::{
[m[32m+        avatar::AvatarWidgetRefExt,
[m[32m+        popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+        restore_status_view::RestoreStatusViewWidgetExt,
[m[32m+    },
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest},
[m[32m+    utils::{self, RoomNameId},
[m[32m+};
[m
 use super::rooms_list::{InviteState, InviterInfo};

Diff in /app/src/home/invite_screen.rs:15:
[31m-
[m live_design! {
     use link::theme::*;
     use link::shaders::*;
Diff in /app/src/home/invite_screen.rs:226:
 #[derive(Debug)]
 pub enum JoinRoomResultAction {
     /// The user has successfully joined the room.
[31m-    Joined {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    Joined { room_id: OwnedRoomId },
[m     /// There was an error attempting to join the room.
     Failed {
         room_id: OwnedRoomId,
Diff in /app/src/home/invite_screen.rs:235:
         error: matrix_sdk::Error,
[31m-    }
[m[32m+    },
[m }

 /// Actions sent from the backend task as a result of a [`MatrixRequest::LeaveRoom`].
Diff in /app/src/home/invite_screen.rs:242:
 #[derive(Debug)]
 pub enum LeaveRoomResultAction {
     /// The user has successfully left the room.
[31m-    Left {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    Left { room_id: OwnedRoomId },
[m     /// There was an error attempting to leave the room.
     Failed {
         room_id: OwnedRoomId,
Diff in /app/src/home/invite_screen.rs:251:
         error: matrix_sdk::Error,
[31m-    }
[m[32m+    },
[m }

[31m-
[m /// A view that shows information about a room that the user has been invited to.
 #[derive(Live, LiveHook, Widget)]
 pub struct InviteScreen {
Diff in /app/src/home/invite_screen.rs:259:
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
[31m-    #[rust] invite_state: InviteState,
[m[31m-    #[rust] info: Option<InviteDetails>,
[m[32m+    #[rust]
[m[32m+    invite_state: InviteState,
[m[32m+    #[rust]
[m[32m+    info: Option<InviteDetails>,
[m     /// Whether a JoinLeaveRoomModal dialog has been displayed
     /// to allow the user to confirm their join/reject action.
     /// This is used to prevent showing multiple popup notifications
Diff in /app/src/home/invite_screen.rs:266:
     /// (one from the JoinLeaveRoomModal, and one from this invite screen).
[31m-    #[rust] has_shown_confirmation: bool,
[m[32m+    #[rust]
[m[32m+    has_shown_confirmation: bool,
[m     /// The name and ID of the invited room.
[31m-    #[rust] room_name_id: Option<RoomNameId>,
[m[31m-    #[rust] is_loaded: bool,
[m[31m-    #[rust] all_rooms_loaded: bool,
[m[32m+    #[rust]
[m[32m+    room_name_id: Option<RoomNameId>,
[m[32m+    #[rust]
[m[32m+    is_loaded: bool,
[m[32m+    #[rust]
[m[32m+    all_rooms_loaded: bool,
[m }

 impl Widget for InviteScreen {
Diff in /app/src/home/invite_screen.rs:276:
         // Currently, a Signal event is only used to tell this widget
         // to check if the room has been loaded from the homeserver yet.
         if let Event::Signal = event {
[31m-            if let (false, Some(room_name_id), true) = (self.is_loaded, self.room_name_id.as_ref(), cx.has_global::<RoomsListRef>()) {
[m[32m+            if let (false, Some(room_name_id), true) = (
[m[32m+                self.is_loaded,
[m[32m+                self.room_name_id.as_ref(),
[m[32m+                cx.has_global::<RoomsListRef>(),
[m[32m+            ) {
[m                 let rooms_list_ref = cx.get_global::<RoomsListRef>();
                 if !rooms_list_ref.is_room_loaded(room_name_id.room_id()) {
                     self.all_rooms_loaded = rooms_list_ref.all_rooms_loaded();
Diff in /app/src/home/invite_screen.rs:297:
             // First, we quickly loop over the actions up front to handle the case
             // where this room was restored and has now been successfully loaded from the homeserver.
             for action in actions {
[31m-                if let Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, .. }) = action.downcast_ref() {
[m[31m-                    if self.room_name_id.as_ref().is_some_and(|current| current.room_id() == room_name_id.room_id()) {
[m[32m+                if let Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, .. }) =
[m[32m+                    action.downcast_ref()
[m[32m+                {
[m[32m+                    if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|current| current.room_id() == room_name_id.room_id())
[m[32m+                    {
[m                         self.set_displayed_invite(cx, room_name_id);
                         break;
                     }
Diff in /app/src/home/invite_screen.rs:305:
                 }
             }

[31m-            let Some(info) = self.info.as_ref() else { return; };
[m[31m-            if let Some(modifiers) = self.view.button(ids!(cancel_button)).clicked_modifiers(actions) {
[m[32m+            let Some(info) = self.info.as_ref() else {
[m[32m+                return;
[m[32m+            };
[m[32m+            if let Some(modifiers) = self
[m[32m+                .view
[m[32m+                .button(ids!(cancel_button))
[m[32m+                .clicked_modifiers(actions)
[m[32m+            {
[m                 self.invite_state = InviteState::WaitingForLeaveResult;
                 if modifiers.shift {
                     submit_async_request(MatrixRequest::LeaveRoom {
Diff in /app/src/home/invite_screen.rs:321:
                     self.has_shown_confirmation = true;
                 }
             }
[31m-            if let Some(modifiers) = self.view.button(ids!(accept_button)).clicked_modifiers(actions) {
[m[32m+            if let Some(modifiers) = self
[m[32m+                .view
[m[32m+                .button(ids!(accept_button))
[m[32m+                .clicked_modifiers(actions)
[m[32m+            {
[m                 self.invite_state = InviteState::WaitingForJoinResult;
                 if modifiers.shift {
                     submit_async_request(MatrixRequest::JoinRoom {
Diff in /app/src/home/invite_screen.rs:342:
                     Some(JoinRoomResultAction::Joined { room_id }) if room_id == info.room_id() => {
                         self.invite_state = InviteState::WaitingForJoinedRoom;
                         if !self.has_shown_confirmation {
[31m-                            enqueue_popup_notification("Successfully joined room.", PopupKind::Success, Some(5.0));
[m[32m+                            enqueue_popup_notification(
[m[32m+                                "Successfully joined room.",
[m[32m+                                PopupKind::Success,
[m[32m+                                Some(5.0),
[m[32m+                            );
[m                         }
                         continue;
                     }
Diff in /app/src/home/invite_screen.rs:349:
[31m-                    Some(JoinRoomResultAction::Failed { room_id, error }) if room_id == info.room_id() => {
[m[32m+                    Some(JoinRoomResultAction::Failed { room_id, error })
[m[32m+                        if room_id == info.room_id() =>
[m[32m+                    {
[m                         self.invite_state = InviteState::WaitingOnUserInput;
                         if !self.has_shown_confirmation {
[31m-                            let msg = utils::stringify_join_leave_error(error, info.room_name_id(), true, true);
[m[32m+                            let msg = utils::stringify_join_leave_error(
[m[32m+                                error,
[m[32m+                                info.room_name_id(),
[m[32m+                                true,
[m[32m+                                true,
[m[32m+                            );
[m                             enqueue_popup_notification(msg, PopupKind::Error, None);
                         }
                         continue;
Diff in /app/src/home/invite_screen.rs:361:
                     Some(LeaveRoomResultAction::Left { room_id }) if room_id == info.room_id() => {
                         self.invite_state = InviteState::RoomLeft;
                         if !self.has_shown_confirmation {
[31m-                            enqueue_popup_notification("Successfully rejected invite.", PopupKind::Success, Some(5.0));
[m[32m+                            enqueue_popup_notification(
[m[32m+                                "Successfully rejected invite.",
[m[32m+                                PopupKind::Success,
[m[32m+                                Some(5.0),
[m[32m+                            );
[m                         }
                         continue;
                     }
Diff in /app/src/home/invite_screen.rs:368:
[31m-                    Some(LeaveRoomResultAction::Failed { room_id, error }) if room_id == info.room_id() => {
[m[32m+                    Some(LeaveRoomResultAction::Failed { room_id, error })
[m[32m+                        if room_id == info.room_id() =>
[m[32m+                    {
[m                         self.invite_state = InviteState::WaitingOnUserInput;
                         if !self.has_shown_confirmation {
[31m-                            enqueue_popup_notification(format!("Failed to reject invite: {error}"), PopupKind::Error, None);
[m[32m+                            enqueue_popup_notification(
[m[32m+                                format!("Failed to reject invite: {error}"),
[m[32m+                                PopupKind::Error,
[m[32m+                                None,
[m[32m+                            );
[m                         }
                         continue;
                     }
Diff in /app/src/home/invite_screen.rs:375:
                     _ => {}
                 }

[31m-                if let Some(JoinLeaveRoomModalAction::Close { successful, .. }) = action.downcast_ref() {
[m[32m+                if let Some(JoinLeaveRoomModalAction::Close { successful, .. }) =
[m[32m+                    action.downcast_ref()
[m[32m+                {
[m                     // If the modal didn't result in a successful join/leave,
                     // then we must reset the invite state to waiting for user input.
                     if !*successful {
Diff in /app/src/home/invite_screen.rs:391:
         }
     }

[31m-
[m     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         if !self.is_loaded {
             let mut restore_status_view = self.view.restore_status_view(ids!(restore_status_view));
Diff in /app/src/home/invite_screen.rs:411:
             let inviter_avatar = inviter_view.avatar(ids!(inviter_avatar));
             let mut drew_avatar = false;
             if let Some(avatar_bytes) = inviter.avatar.as_ref() {
[31m-                drew_avatar = inviter_avatar.show_image(
[m[31m-                    cx,
[m[31m-                    None, // don't make this avatar clickable.
[m[31m-                    |cx, img| utils::load_png_or_jpg(&img, cx, avatar_bytes),
[m[31m-                ).is_ok();
[m[32m+                drew_avatar = inviter_avatar
[m[32m+                    .show_image(
[m[32m+                        cx,
[m[32m+                        None, // don't make this avatar clickable.
[m[32m+                        |cx, img| utils::load_png_or_jpg(&img, cx, avatar_bytes),
[m[32m+                    )
[m[32m+                    .is_ok();
[m             }
             if !drew_avatar {
                 inviter_avatar.show_text(
Diff in /app/src/home/invite_screen.rs:422:
                     cx,
                     None,
                     None, // don't make this avatar clickable.
[31m-                    inviter.display_name.as_deref().unwrap_or_else(|| inviter.user_id.as_str()),
[m[32m+                    inviter
[m[32m+                        .display_name
[m[32m+                        .as_deref()
[m[32m+                        .unwrap_or_else(|| inviter.user_id.as_str()),
[m                 );
             }
             let inviter_name = inviter_view.label(ids!(inviter_name));
Diff in /app/src/home/invite_screen.rs:432:
                 inviter_name.set_text(cx, inviter_user_name);
                 inviter_user_id.set_visible(cx, true);
                 inviter_user_id.set_text(cx, inviter.user_id.as_str());
[31m-            }
[m[31m-            else {
[m[32m+            } else {
[m                 // If we only have a user ID, show it in the user_name field,
                 // and hide the user ID field.
                 inviter_name.set_text(cx, inviter.user_id.as_str());
Diff in /app/src/home/invite_screen.rs:440:
                 inviter_user_id.set_visible(cx, false);
             }
             (true, "has invited you to join:")
[31m-        }
[m[31m-        else {
[m[32m+        } else {
[m             (false, "You have been invited to join:")
         };
         inviter_view.set_visible(cx, is_visible);
Diff in /app/src/home/invite_screen.rs:448:
[31m-        self.view.label(ids!(invite_message)).set_text(cx, invite_text);
[m[32m+        self.view
[m[32m+            .label(ids!(invite_message))
[m[32m+            .set_text(cx, invite_text);
[m
         // Second, populate the room info, if we have it.
         let room_view = self.view.view(ids!(room_view));
Diff in /app/src/home/invite_screen.rs:453:
         match &info.room_avatar() {
             FetchedRoomAvatar::Text(text) => {
                 room_avatar.show_text(
[31m-                    cx,
[m[31m-                    None,
[m[31m-                    None, // don't make this avatar clickable.
[m[32m+                    cx, None, None, // don't make this avatar clickable.
[m                     text,
                 );
             }
Diff in /app/src/home/invite_screen.rs:468:
             }
         }
         let invite_room_label = info.room_name_id().to_string();
[31m-        room_view.label(ids!(room_name)).set_text(cx, &invite_room_label);
[m[32m+        room_view
[m[32m+            .label(ids!(room_name))
[m[32m+            .set_text(cx, &invite_room_label);
[m
         // Third, set the buttons' text based on the invite state.
         let cancel_button = self.view.button(ids!(cancel_button));
Diff in /app/src/home/invite_screen.rs:536:

         let restore_status_view = self.view.restore_status_view(ids!(restore_status_view));
         if !self.is_loaded {
[31m-            restore_status_view.set_content(
[m[31m-                cx,
[m[31m-                self.all_rooms_loaded,
[m[31m-                room_name_id,
[m[31m-            );
[m[32m+            restore_status_view.set_content(cx, self.all_rooms_loaded, room_name_id);
[m             restore_status_view.set_visible(cx, true);
         } else {
             restore_status_view.set_visible(cx, false);
Diff in /app/src/home/link_preview.rs:7:
 };

 use makepad_widgets::*;
[31m-use matrix_sdk::ruma::{events::room::{ImageInfo, MediaSource}, OwnedMxcUri, UInt};
[m[32m+use matrix_sdk::ruma::{
[m[32m+    events::room::{ImageInfo, MediaSource},
[m[32m+    OwnedMxcUri, UInt,
[m[32m+};
[m use serde::Deserialize;
 use url::Url;

Diff in /app/src/home/link_preview.rs:192:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         // Handle collapsible button clicks
         if let Event::Actions(actions) = event {
[31m-            let expand_button = self.view.button(ids!(collapsible_button.expand_collapse_button));
[m[32m+            let expand_button = self
[m[32m+                .view
[m[32m+                .button(ids!(collapsible_button.expand_collapse_button));
[m             if expand_button.clicked(actions) {
                 self.is_expanded = !self.is_expanded;
                 self.update_button_and_visibility(cx);
Diff in /app/src/home/link_preview.rs:203:
         for view in self.children.iter() {
             match event.hits(cx, view.area()) {
                 Hit::FingerHoverIn(_) | Hit::FingerDown(_) => {
[31m-                    view.apply_over(cx, live! {
[m[31m-                        draw_bg: { color: (COLOR_BG_PREVIEW_HOVER) }
[m[31m-                    });
[m[32m+                    view.apply_over(
[m[32m+                        cx,
[m[32m+                        live! {
[m[32m+                            draw_bg: { color: (COLOR_BG_PREVIEW_HOVER) }
[m[32m+                        },
[m[32m+                    );
[m                 }
                 Hit::FingerHoverOut(_) => {
[31m-                    view.apply_over(cx, live! {
[m[31m-                        draw_bg: { color: (COLOR_BG_PREVIEW) }
[m[31m-                    });
[m[32m+                    view.apply_over(
[m[32m+                        cx,
[m[32m+                        live! {
[m[32m+                            draw_bg: { color: (COLOR_BG_PREVIEW) }
[m[32m+                        },
[m[32m+                    );
[m                 }
                 Hit::FingerUp(fe) => {
                     // return to normal bg color
Diff in /app/src/home/link_preview.rs:217:
[31m-                    view.apply_over(cx, live! {
[m[31m-                        draw_bg: { color: (COLOR_BG_PREVIEW) }
[m[31m-                    });
[m[32m+                    view.apply_over(
[m[32m+                        cx,
[m[32m+                        live! {
[m[32m+                            draw_bg: { color: (COLOR_BG_PREVIEW) }
[m[32m+                        },
[m[32m+                    );
[m                     if fe.is_over && fe.is_primary_hit() && fe.was_tap() {
[31m-                        if let Some(html_link) = view.link_label(ids!(content_view.title_label)).borrow() {
[m[32m+                        if let Some(html_link) =
[m[32m+                            view.link_label(ids!(content_view.title_label)).borrow()
[m[32m+                        {
[m                             if !html_link.url.is_empty() {
                                 cx.widget_action(
                                     html_link.widget_uid(),
Diff in /app/src/home/link_preview.rs:241:

     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         // Draw children (link preview items)
[31m-        let max_visible = if self.is_expanded { self.children.len() } else { 2 };
[m[32m+        let max_visible = if self.is_expanded {
[m[32m+            self.children.len()
[m[32m+        } else {
[m[32m+            2
[m[32m+        };
[m         for (index, view) in self.children.iter_mut().enumerate() {
             if index < max_visible {
                 let _ = view.draw(cx, scope);
Diff in /app/src/home/link_preview.rs:260:

     fn update_button_and_visibility(&mut self, cx: &mut Cx) {
         if self.show_collapsible_button {
[31m-            self.view.view(ids!(collapsible_button)).set_visible(cx, true);
[m[31m-            let button_ref = self.view.button(ids!(collapsible_button.expand_collapse_button));
[m[32m+            self.view
[m[32m+                .view(ids!(collapsible_button))
[m[32m+                .set_visible(cx, true);
[m[32m+            let button_ref = self
[m[32m+                .view
[m[32m+                .button(ids!(collapsible_button.expand_collapse_button));
[m             if self.is_expanded {
                 button_ref.set_text(cx, "▲ Show fewer links");
             } else {
Diff in /app/src/home/link_preview.rs:268:
[31m-                button_ref.set_text(cx, &format!("▼ Show {} more links", self.hidden_links_count));
[m[32m+                button_ref.set_text(
[m[32m+                    cx,
[m[32m+                    &format!("▼ Show {} more links", self.hidden_links_count),
[m[32m+                );
[m             }
         } else {
[31m-            self.view.view(ids!(collapsible_button)).set_visible(cx, false);
[m[32m+            self.view
[m[32m+                .view(ids!(collapsible_button))
[m[32m+                .set_visible(cx, false);
[m         }
     }
 }
Diff in /app/src/home/link_preview.rs:294:
     }

     /// Shows the collapsible button for the link preview.
[31m-    ///
[m[32m+    ///
[m     /// This function is usually called when the link preview is updated.
     /// If the link preview is updated, and the collapsible button should be shown,
     /// this function should be called.
Diff in /app/src/home/link_preview.rs:301:
     fn show_collapsible_button(&mut self, cx: &mut Cx, hidden_count: usize) {
[31m-         if let Some(mut inner) = self.borrow_mut() {
[m[32m+        if let Some(mut inner) = self.borrow_mut() {
[m             inner.show_collapsible_button = true;
             inner.hidden_links_count = hidden_count;
[31m-            let button_ref = inner.view.button(ids!(collapsible_button.expand_collapse_button));
[m[31m-            button_ref.set_text(cx, &format!("▼ Show {} more links", inner.hidden_links_count));
[m[31m-            inner.view.view(ids!(collapsible_button)).set_visible(cx, true);
[m[32m+            let button_ref = inner
[m[32m+                .view
[m[32m+                .button(ids!(collapsible_button.expand_collapse_button));
[m[32m+            button_ref.set_text(
[m[32m+                cx,
[m[32m+                &format!("▼ Show {} more links", inner.hidden_links_count),
[m[32m+            );
[m[32m+            inner
[m[32m+                .view
[m[32m+                .view(ids!(collapsible_button))
[m[32m+                .set_visible(cx, true);
[m         }
     }

Diff in /app/src/home/link_preview.rs:319:
         image_populate_fn: F,
     ) -> (ViewRef, bool)
     where
[31m-        F: FnOnce(&mut Cx, &TextOrImageRef, Option<Box<ImageInfo>>, MediaSource, &str, &mut MediaCache) -> bool,
[m[32m+        F: FnOnce(
[m[32m+            &mut Cx,
[m[32m+            &TextOrImageRef,
[m[32m+            Option<Box<ImageInfo>>,
[m[32m+            MediaSource,
[m[32m+            &str,
[m[32m+            &mut MediaCache,
[m[32m+        ) -> bool,
[m     {
         let view_ref = WidgetRef::new_from_ptr(cx, self.item_template()).as_view();
         let mut fully_drawn = true;
Diff in /app/src/home/link_preview.rs:396:
     /// The given `media_cache` is used to fetch the thumbnails from cache.
     ///
     /// The given `link_preview_cache` is used to fetch the link previews from cache.
[31m-    ///
[m[32m+    ///
[m     /// Return true when the link preview is fully drawn
     pub fn populate_below_message<F>(
         &mut self,
Diff in /app/src/home/link_preview.rs:405:
         media_cache: &mut MediaCache,
         link_preview_cache: &mut LinkPreviewCache,
         populate_image_fn: &F,
[31m-    ) -> bool
[m[32m+    ) -> bool
[m     where
[31m-        F: Fn(&mut Cx, &TextOrImageRef, Option<Box<ImageInfo>>, MediaSource, &str, &mut MediaCache) -> bool,
[m[32m+        F: Fn(
[m[32m+            &mut Cx,
[m[32m+            &TextOrImageRef,
[m[32m+            Option<Box<ImageInfo>>,
[m[32m+            MediaSource,
[m[32m+            &str,
[m[32m+            &mut MediaCache,
[m[32m+        ) -> bool,
[m     {
         const SKIPPED_DOMAINS: &[&str] = &["matrix.to", "matrix.io"];
         const MAX_LINK_PREVIEWS_BY_EXPAND: usize = 2;
Diff in /app/src/home/link_preview.rs:415:
         let mut accepted_link_count = 0;
         let mut views = Vec::new();
         let mut seen_urls = std::collections::HashSet::new();
[31m-
[m[32m+
[m         for link in links {
             let url_string = link.to_string();
             if seen_urls.contains(&url_string) {
Diff in /app/src/home/link_preview.rs:422:
                 continue;
             }
[31m-
[m[32m+
[m             if let Some(domain) = link.host_str() {
                 if SKIPPED_DOMAINS
                     .iter()
Diff in /app/src/home/link_preview.rs:430:
                     continue;
                 }
             }
[31m-
[m[32m+
[m             seen_urls.insert(url_string.clone());
             accepted_link_count += 1;
             let (view_ref, was_image_drawn) = self.populate_view(
Diff in /app/src/home/link_preview.rs:439:
                 link,
                 media_cache,
                 |cx, text_or_image_ref, image_info_source, original_source, body, media_cache| {
[31m-                    populate_image_fn(cx, text_or_image_ref, image_info_source, original_source, body, media_cache)
[m[32m+                    populate_image_fn(
[m[32m+                        cx,
[m[32m+                        text_or_image_ref,
[m[32m+                        image_info_source,
[m[32m+                        original_source,
[m[32m+                        body,
[m[32m+                        media_cache,
[m[32m+                    )
[m                 },
             );
             fully_drawn_count += was_image_drawn as usize;
Diff in /app/src/home/link_preview.rs:625:
                 UrlPreviewError::HttpStatus(404) => LinkPreviewError::NotFound,
                 UrlPreviewError::HttpStatus(429) => LinkPreviewError::RateLimited,
                 UrlPreviewError::Json(_) => LinkPreviewError::ParseError(e.to_string()),
[31m-                UrlPreviewError::Request(_) |
[m[31m-                UrlPreviewError::ClientNotAvailable |
[m[31m-                UrlPreviewError::AccessTokenNotAvailable |
[m[31m-                UrlPreviewError::UrlParse(_) |
[m[31m-                UrlPreviewError::HttpStatus(_) => LinkPreviewError::NetworkError(e.to_string()),
[m[32m+                UrlPreviewError::Request(_)
[m[32m+                | UrlPreviewError::ClientNotAvailable
[m[32m+                | UrlPreviewError::AccessTokenNotAvailable
[m[32m+                | UrlPreviewError::UrlParse(_)
[m[32m+                | UrlPreviewError::HttpStatus(_) => LinkPreviewError::NetworkError(e.to_string()),
[m             };
             if let LinkPreviewError::RateLimited = error_type {
                 LinkPreviewCacheEntry::Requested
Diff in /app/src/home/link_preview.rs:639:
             }
         }
     };
[31m-
[m[32m+
[m     if let Ok(mut timestamped_entry) = value_ref.lock() {
         timestamped_entry.entry = new_entry;
         timestamped_entry.timestamp = Instant::now();
Diff in /app/src/home/link_preview.rs:646:
     }
[31m-
[m[32m+
[m     if let Some(sender) = update_sender {
         // Reuse TimelineUpdate MediaFetched to trigger redraw in the timeline.
         let _ = sender.send(TimelineUpdate::LinkPreviewFetched);
Diff in /app/src/home/link_preview.rs:651:
     }
     SignalToUI::set_ui_signal();
 }
[31m-
[m
Diff in /app/src/home/loading_pane.rs:3:

 use crate::sliding_sync::TimelineRequestSender;

[31m-
[m live_design! {
     use link::theme::*;
     use link::shaders::*;
Diff in /app/src/home/loading_pane.rs:105:
     }
 }

[31m-
[m[31m-
[m /// The state of a LoadingPane: the possible tasks that it may be performing.
 #[derive(Clone, DefaultNone)]
 pub enum LoadingPaneState {
Diff in /app/src/home/loading_pane.rs:126:
     None,
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct LoadingPane {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: LoadingPaneState,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: LoadingPaneState,
[m }
 impl Drop for LoadingPane {
     fn drop(&mut self) {
Diff in /app/src/home/loading_pane.rs:137:
[31m-        if let LoadingPaneState::BackwardsPaginateUntilEvent { target_event_id, request_sender, .. } = &self.state {
[m[31m-            warning!("Dropping LoadingPane with target_event_id: {}", target_event_id);
[m[32m+        if let LoadingPaneState::BackwardsPaginateUntilEvent {
[m[32m+            target_event_id,
[m[32m+            request_sender,
[m[32m+            ..
[m[32m+        } = &self.state
[m[32m+        {
[m[32m+            warning!(
[m[32m+                "Dropping LoadingPane with target_event_id: {}",
[m[32m+                target_event_id
[m[32m+            );
[m             request_sender.send_if_modified(|requests| {
                 let initial_len = requests.len();
                 requests.retain(|r| &r.target_event_id != target_event_id);
Diff in /app/src/home/loading_pane.rs:147:
     }
 }

[31m-
[m impl Widget for LoadingPane {
     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         self.visible = true;
Diff in /app/src/home/loading_pane.rs:160:
     }

     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
[31m-        if !self.visible { return; }
[m[32m+        if !self.visible {
[m[32m+            return;
[m[32m+        }
[m         self.view.handle_event(cx, event, scope);

         let area = self.view.area();
Diff in /app/src/home/loading_pane.rs:175:
             matches!(
                 event,
                 Event::Actions(actions) if self.button(ids!(cancel_button)).clicked(actions)
[31m-            )
[m[31m-            || event.back_pressed()
[m[31m-            || match event.hits_with_capture_overload(cx, area, true) {
[m[31m-                Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[31m-                Hit::FingerDown(_fde) => {
[m[31m-                    cx.set_key_focus(area);
[m[31m-                    false
[m[32m+            ) || event.back_pressed()
[m[32m+                || match event.hits_with_capture_overload(cx, area, true) {
[m[32m+                    Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[32m+                    Hit::FingerDown(_fde) => {
[m[32m+                        cx.set_key_focus(area);
[m[32m+                        false
[m[32m+                    }
[m[32m+                    Hit::FingerUp(fue) if fue.is_over => {
[m[32m+                        fue.mouse_button().is_some_and(|b| b.is_back())
[m[32m+                            || !self
[m[32m+                                .view(ids!(main_content))
[m[32m+                                .area()
[m[32m+                                .rect(cx)
[m[32m+                                .contains(fue.abs)
[m[32m+                    }
[m[32m+                    _ => false,
[m                 }
[31m-                Hit::FingerUp(fue) if fue.is_over => {
[m[31m-                    fue.mouse_button().is_some_and(|b| b.is_back())
[m[31m-                    || !self.view(ids!(main_content)).area().rect(cx).contains(fue.abs)
[m[31m-                }
[m[31m-                _ => false,
[m[31m-            }
[m         };
         if close_pane {
[31m-            if let LoadingPaneState::BackwardsPaginateUntilEvent { target_event_id, request_sender, .. } = &self.state {
[m[32m+            if let LoadingPaneState::BackwardsPaginateUntilEvent {
[m[32m+                target_event_id,
[m[32m+                request_sender,
[m[32m+                ..
[m[32m+            } = &self.state
[m[32m+            {
[m                 let _did_send = request_sender.send_if_modified(|requests| {
                     let initial_len = requests.len();
                     requests.retain(|r| &r.target_event_id != target_event_id);
Diff in /app/src/home/loading_pane.rs:199:
                     // such that they can stop looking for the target event.
                     requests.len() != initial_len
                 });
[31m-                log!("LoadingPane: {} cancel request for target_event_id: {target_event_id}",
[m[32m+                log!(
[m[32m+                    "LoadingPane: {} cancel request for target_event_id: {target_event_id}",
[m                     if _did_send { "Sent" } else { "Did not send" },
                 );
             }
Diff in /app/src/home/loading_pane.rs:210:
     }
 }

[31m-
[m impl LoadingPane {
     /// Returns `true` if this pane is currently being shown.
     pub fn is_currently_shown(&self, _cx: &mut Cx) -> bool {
Diff in /app/src/home/loading_pane.rs:232:
                 ..
             } => {
                 self.set_title(cx, "Searching older messages...");
[31m-                self.set_status(cx, &format!(
[m[31m-                    "Looking for event {target_event_id}\n\n\
[m[32m+                self.set_status(
[m[32m+                    cx,
[m[32m+                    &format!(
[m[32m+                        "Looking for event {target_event_id}\n\n\
[m                     Fetched {events_paginated} messages so far...",
[31m-                ));
[m[32m+                    ),
[m[32m+                );
[m                 cancel_button.set_text(cx, "Cancel");
             }
             LoadingPaneState::Error(error_message) => {
Diff in /app/src/home/loading_pane.rs:243:
                 self.set_status(cx, error_message);
                 cancel_button.set_text(cx, "Okay");
             }
[31m-            LoadingPaneState::None => { }
[m[32m+            LoadingPaneState::None => {}
[m         }

         self.state = state;
Diff in /app/src/home/loading_pane.rs:262:
 impl LoadingPaneRef {
     /// See [`LoadingPane::is_currently_shown()`]
     pub fn is_currently_shown(&self, cx: &mut Cx) -> bool {
[31m-        let Some(inner) = self.borrow() else { return false };
[m[32m+        let Some(inner) = self.borrow() else {
[m[32m+            return false;
[m[32m+        };
[m         inner.is_currently_shown(cx)
     }

Diff in /app/src/home/loading_pane.rs:269:
     /// See [`LoadingPane::show()`]
     pub fn show(&self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx);
     }

Diff in /app/src/home/loading_pane.rs:279:
     }

     pub fn set_state(&self, cx: &mut Cx, state: LoadingPaneState) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_state(cx, state);
     }

Diff in /app/src/home/loading_pane.rs:286:
     pub fn set_status(&self, cx: &mut Cx, status: &str) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_status(cx, status);
     }

Diff in /app/src/home/loading_pane.rs:291:
     pub fn set_title(&self, cx: &mut Cx, title: &str) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_title(cx, title);
     }
 }
Diff in /app/src/home/location_preview.rs:10:
 use makepad_widgets::*;
 use robius_location::Coordinates;

[31m-use crate::location::{get_latest_location, request_location_update, LocationAction, LocationRequest, LocationUpdate};
[m[32m+use crate::location::{
[m[32m+    get_latest_location, request_location_update, LocationAction, LocationRequest, LocationUpdate,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/location_preview.rs:112:
     }
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 struct LocationPreview {
[31m-    #[deref] view: View,
[m[31m-    #[rust] coords: Option<Result<Coordinates, robius_location::Error>>,
[m[31m-    #[rust] timestamp: Option<SystemTime>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    coords: Option<Result<Coordinates, robius_location::Error>>,
[m[32m+    #[rust]
[m[32m+    timestamp: Option<SystemTime>,
[m }

 impl Widget for LocationPreview {
Diff in /app/src/home/location_preview.rs:129:
                     Some(LocationAction::Update(LocationUpdate { coordinates, time })) => {
                         self.coords = Some(Ok(*coordinates));
                         self.timestamp = *time;
[31m-                        self.button(ids!(send_location_button)).set_enabled(cx, true);
[m[32m+                        self.button(ids!(send_location_button))
[m[32m+                            .set_enabled(cx, true);
[m                         needs_redraw = true;
                     }
                     Some(LocationAction::Error(e)) => {
Diff in /app/src/home/location_preview.rs:136:
                         self.coords = Some(Err(*e));
                         self.timestamp = None;
[31m-                        self.button(ids!(send_location_button)).set_enabled(cx, false);
[m[32m+                        self.button(ids!(send_location_button))
[m[32m+                            .set_enabled(cx, false);
[m                         needs_redraw = true;
                     }
[31m-                    _ => { }
[m[32m+                    _ => {}
[m                 }
             }

Diff in /app/src/home/location_preview.rs:171:
         self.view.draw_walk(cx, scope, walk)
     }
 }
[31m-
[m
 impl LocationPreview {
     fn show(&mut self) {
Diff in /app/src/home/main_desktop_ui.rs:3:
 use tokio::sync::Notify;
 use std::{collections::HashMap, sync::Arc};

[31m-use crate::{app::{AppState, AppStateAction, SavedDockState, SelectedRoom}, home::{navigation_tab_bar::{NavigationBarAction, SelectedTab}, rooms_list::RoomsListRef, space_lobby::SpaceLobbyScreenWidgetRefExt}, utils::RoomNameId};
[m[31m-use super::{invite_screen::InviteScreenWidgetRefExt, room_screen::RoomScreenWidgetRefExt, rooms_list::RoomsListAction};
[m[32m+use crate::{
[m[32m+    app::{AppState, AppStateAction, SavedDockState, SelectedRoom},
[m[32m+    home::{
[m[32m+        navigation_tab_bar::{NavigationBarAction, SelectedTab},
[m[32m+        rooms_list::RoomsListRef,
[m[32m+        space_lobby::SpaceLobbyScreenWidgetRefExt,
[m[32m+    },
[m[32m+    utils::RoomNameId,
[m[32m+};
[m[32m+use super::{
[m[32m+    invite_screen::InviteScreenWidgetRefExt, room_screen::RoomScreenWidgetRefExt,
[m[32m+    rooms_list::RoomsListAction,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/main_desktop_ui.rs:71:
     /// The default layout that should be loaded into the dock
     /// when there is no previously-saved content to restore.
     /// This is a Rust-level instance of the dock content defined in the above live DSL.
[31m-    #[rust] default_layout: SavedDockState,
[m[32m+    #[rust]
[m[32m+    default_layout: SavedDockState,
[m
     /// The rooms that are currently open, keyed by the LiveId of their tab.
     #[rust]
Diff in /app/src/home/main_desktop_ui.rs:95:
     ///
     /// This determines which set of rooms this dock is currently showing.
     /// If `None`, we're displaying the main home view of all rooms from any space.
[31m-    #[rust] selected_space: Option<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    selected_space: Option<OwnedRoomId>,
[m
     /// Boolean to indicate if we've drawn the MainDesktopUi previously in the desktop view.
     ///
Diff in /app/src/home/main_desktop_ui.rs:137:
     /// Focuses on a room if it is already open, otherwise creates a new tab for the room.
     fn focus_or_create_tab(&mut self, cx: &mut Cx, room: SelectedRoom) {
         // Do nothing if the room to select is already created and focused.
[31m-        if self.most_recently_selected_room.as_ref().is_some_and(|r| r == &room) {
[m[32m+        if self
[m[32m+            .most_recently_selected_room
[m[32m+            .as_ref()
[m[32m+            .is_some_and(|r| r == &room)
[m[32m+        {
[m             return;
         }

Diff in /app/src/home/main_desktop_ui.rs:153:

         // Create a new tab for the room
         let (kind, name) = match &room {
[31m-            SelectedRoom::JoinedRoom { room_name_id }  => (
[m[31m-                id!(room_screen),
[m[31m-                room_name_id.to_string(),
[m[31m-            ),
[m[31m-            SelectedRoom::InvitedRoom { room_name_id } => (
[m[31m-                id!(invite_screen),
[m[31m-                room_name_id.to_string(),
[m[31m-            ),
[m[32m+            SelectedRoom::JoinedRoom { room_name_id } => {
[m[32m+                (id!(room_screen), room_name_id.to_string())
[m[32m+            }
[m[32m+            SelectedRoom::InvitedRoom { room_name_id } => {
[m[32m+                (id!(invite_screen), room_name_id.to_string())
[m[32m+            }
[m             SelectedRoom::Space { space_name_id } => (
                 id!(space_lobby_screen),
                 format!("[Space] {}", space_name_id),
Diff in /app/src/home/main_desktop_ui.rs:169:

         // Insert the tab after the currently-selected room's tab, if possible.
         // Otherwise, insert it after the home tab, which should always exist.
[31m-        let (tab_bar, insert_after) = self.most_recently_selected_room.as_ref()
[m[32m+        let (tab_bar, insert_after) = self
[m[32m+            .most_recently_selected_room
[m[32m+            .as_ref()
[m             .and_then(|curr_room| {
                 let curr_room_id = LiveId::from_str(curr_room.room_id().as_str());
                 dock.find_tab_bar_of_tab(curr_room_id)
Diff in /app/src/home/main_desktop_ui.rs:190:
         if let Some(new_widget) = new_tab_widget {
             self.room_order.push(room.clone());
             match &room {
[31m-                SelectedRoom::JoinedRoom { room_name_id }  => {
[m[31m-                    new_widget.as_room_screen().set_displayed_room(
[m[31m-                        cx,
[m[31m-                        room_name_id,
[m[31m-                    );
[m[32m+                SelectedRoom::JoinedRoom { room_name_id } => {
[m[32m+                    new_widget
[m[32m+                        .as_room_screen()
[m[32m+                        .set_displayed_room(cx, room_name_id);
[m                 }
                 SelectedRoom::InvitedRoom { room_name_id } => {
[31m-                    new_widget.as_invite_screen().set_displayed_invite(
[m[31m-                        cx,
[m[31m-                        room_name_id,
[m[31m-                    );
[m[32m+                    new_widget
[m[32m+                        .as_invite_screen()
[m[32m+                        .set_displayed_invite(cx, room_name_id);
[m                 }
                 SelectedRoom::Space { space_name_id } => {
[31m-                    new_widget.as_space_lobby_screen().set_displayed_space(
[m[31m-                        cx,
[m[31m-                        space_name_id,
[m[31m-                    );
[m[32m+                    new_widget
[m[32m+                        .as_space_lobby_screen()
[m[32m+                        .set_displayed_space(cx, space_name_id);
[m                 }
             }
             cx.action(MainDesktopUiAction::SaveDockIntoAppState);
Diff in /app/src/home/main_desktop_ui.rs:254:
     /// Closes all tabs
     pub fn close_all_tabs(&mut self, cx: &mut Cx) {
         let dock = self.view.dock(ids!(dock));
[31m-        for tab_id in self.open_rooms.keys() {
[m[32m+        for tab_id in self.open_rooms.keys() {
[m             dock.close_tab(cx, *tab_id);
         }

Diff in /app/src/home/main_desktop_ui.rs:295:

         // Go through all existing `SelectedRoom` instances and replace the
         // `SelectedRoom::InvitedRoom`s with `SelectedRoom::JoinedRoom`s.
[31m-        for selected_room in self.most_recently_selected_room.iter_mut()
[m[32m+        for selected_room in self
[m[32m+            .most_recently_selected_room
[m[32m+            .iter_mut()
[m             .chain(self.room_order.iter_mut())
             .chain(self.open_rooms.values_mut())
         {
Diff in /app/src/home/main_desktop_ui.rs:303:
         }

         // Finally, emit an action to update the AppState with the new room.
[31m-        cx.action(AppStateAction::UpgradedInviteToJoinedRoom(room_name_id.room_id().clone()));
[m[32m+        cx.action(AppStateAction::UpgradedInviteToJoinedRoom(
[m[32m+            room_name_id.room_id().clone(),
[m[32m+        ));
[m     }

     /// Saves a copy of the current UI state of the dock into the given app state,
Diff in /app/src/home/main_desktop_ui.rs:311:
     fn save_dock_state_to(&mut self, app_state: &mut AppState) {
         if self.open_rooms.is_empty() {
             return;
[31m-        }
[m[32m+        }
[m         let saved_dock_state = self.save_dock_state();
         if let Some(space_id) = self.selected_space.as_ref() {
[31m-            app_state.saved_dock_state_per_space.insert(
[m[31m-                space_id.clone(),
[m[31m-                saved_dock_state,
[m[31m-            );
[m[32m+            app_state
[m[32m+                .saved_dock_state_per_space
[m[32m+                .insert(space_id.clone(), saved_dock_state);
[m         } else {
             app_state.saved_dock_state_home = saved_dock_state;
         }
Diff in /app/src/home/main_desktop_ui.rs:324:
     }

[31m-    /// An inner function that creates a `SavedDockState` from the current contents of this widget.
[m[32m+    /// An inner function that creates a `SavedDockState` from the current contents of this widget.
[m     fn save_dock_state(&self) -> SavedDockState {
         let dock = self.view.dock(ids!(dock));
         SavedDockState {
Diff in /app/src/home/main_desktop_ui.rs:350:
             Some(sds) if sds.open_rooms.is_empty() => &self.default_layout,
             Some(sds) => sds,
         };
[31m-        let SavedDockState { dock_items, open_rooms, room_order, selected_room } = to_restore;
[m[32m+        let SavedDockState {
[m[32m+            dock_items,
[m[32m+            open_rooms,
[m[32m+            room_order,
[m[32m+            selected_room,
[m[32m+        } = to_restore;
[m
         self.room_order = room_order.clone();
         self.open_rooms = open_rooms.clone();
Diff in /app/src/home/main_desktop_ui.rs:362:
                 for (head_live_id, (_, widget)) in dock.items().iter() {
                     match self.open_rooms.get(head_live_id) {
                         Some(SelectedRoom::JoinedRoom { room_name_id }) => {
[31m-                            widget.as_room_screen().set_displayed_room(
[m[31m-                                cx,
[m[31m-                                room_name_id,
[m[31m-                            );
[m[32m+                            widget.as_room_screen().set_displayed_room(cx, room_name_id);
[m                         }
                         Some(SelectedRoom::InvitedRoom { room_name_id }) => {
[31m-                            widget.as_invite_screen().set_displayed_invite(
[m[31m-                                cx,
[m[31m-                                room_name_id,
[m[31m-                            );
[m[32m+                            widget
[m[32m+                                .as_invite_screen()
[m[32m+                                .set_displayed_invite(cx, room_name_id);
[m                         }
                         Some(SelectedRoom::Space { space_name_id }) => {
[31m-                            widget.as_space_lobby_screen().set_displayed_space(
[m[31m-                                cx,
[m[31m-                                space_name_id,
[m[31m-                            );
[m[32m+                            widget
[m[32m+                                .as_space_lobby_screen()
[m[32m+                                .set_displayed_space(cx, space_name_id);
[m                         }
[31m-                        None => { }
[m[32m+                        None => {}
[m                     }
                 }
             }
Diff in /app/src/home/main_desktop_ui.rs:386:
         } else {
[31m-            error!("BUG: failed to borrow dock widget to restore state upon LoadDockFromAppState action.");
[m[32m+            error!(
[m[32m+                "BUG: failed to borrow dock widget to restore state upon LoadDockFromAppState action."
[m[32m+            );
[m             return;
         }
         // Note: the borrow of `dock` must end here *before* we call `self.focus_or_create_tab()`.
Diff in /app/src/home/main_desktop_ui.rs:405:
         for action in actions {
             let widget_action = action.as_widget_action();

[31m-            if let Some(MainDesktopUiAction::CloseAllTabs { on_close_all }) = action.downcast_ref() {
[m[32m+            if let Some(MainDesktopUiAction::CloseAllTabs { on_close_all }) = action.downcast_ref()
[m[32m+            {
[m                 self.close_all_tabs(cx);
                 on_close_all.notify_one();
                 continue;
Diff in /app/src/home/main_desktop_ui.rs:416:
             if let Some(NavigationBarAction::TabSelected(tab)) = action.downcast_ref() {
                 let new_space = match (tab, self.selected_space.as_ref()) {
                     (SelectedTab::Space { space_name_id }, space_id_opt)
[31m-                        if space_id_opt.is_none_or(|id| id != space_name_id.room_id()) =>
[m[32m+                        if space_id_opt.is_none_or(|id| id != space_name_id.room_id()) =>
[m                     {
                         Some(space_name_id.room_id().clone())
                     }
Diff in /app/src/home/main_desktop_ui.rs:438:
                     if tab_id == id!(home_tab) {
                         cx.action(AppStateAction::FocusNone);
                         self.most_recently_selected_room = None;
[31m-                    }
[m[31m-                    else if let Some(selected_room) = self.open_rooms.get(&tab_id) {
[m[32m+                    } else if let Some(selected_room) = self.open_rooms.get(&tab_id) {
[m                         cx.action(AppStateAction::RoomFocused(selected_room.clone()));
                         self.most_recently_selected_room = Some(selected_room.clone());
                     }
Diff in /app/src/home/main_desktop_ui.rs:465:
                 // When dragging a tab, allow it to be dragged
                 DockAction::Drag(drag_event) => {
                     if drag_event.items.len() == 1 {
[31m-                        self.view.dock(ids!(dock)).accept_drag(cx, drag_event, DragResponse::Move);
[m[32m+                        self.view
[m[32m+                            .dock(ids!(dock))
[m[32m+                            .accept_drag(cx, drag_event, DragResponse::Move);
[m                     }
                 }
                 // When dropping a tab, move it to the new position
Diff in /app/src/home/main_desktop_ui.rs:474:
                     if let DragItem::FilePath {
                         internal_id: Some(internal_id),
                         ..
[31m-                    } = &drop_event.items[0] {
[m[31m-                        self.view.dock(ids!(dock)).drop_move(cx, drop_event.abs, *internal_id);
[m[32m+                    } = &drop_event.items[0]
[m[32m+                    {
[m[32m+                        self.view
[m[32m+                            .dock(ids!(dock))
[m[32m+                            .drop_move(cx, drop_event.abs, *internal_id);
[m                     }
                     should_save_dock_action = true;
                 }
Diff in /app/src/home/main_desktop_ui.rs:494:
                     self.replace_invite_with_joined_room(cx, scope, room_name_id);
                 }
                 RoomsListAction::OpenRoomContextMenu { .. } => {}
[31m-                RoomsListAction::None => { }
[m[32m+                RoomsListAction::None => {}
[m             }

             // Handle our own actions related to dock updates that we have previously emitted.
Diff in /app/src/home/main_desktop_ui.rs:525:
     /// Load the room panel state from the AppState to the dock.
     LoadDockFromAppState,
     /// Close all tabs; see [`MainDesktopUI::close_all_tabs()`]
[31m-    CloseAllTabs {
[m[31m-        on_close_all: Arc<Notify>,
[m[31m-    },
[m[32m+    CloseAllTabs { on_close_all: Arc<Notify> },
[m }

Diff in /app/src/home/main_mobile_ui.rs:1:
 use makepad_widgets::*;

 use crate::{
[31m-    app::{AppState, AppStateAction, SelectedRoom}, home::{room_screen::RoomScreenWidgetExt, rooms_list::RoomsListAction, space_lobby::SpaceLobbyScreenWidgetExt}
[m[32m+    app::{AppState, AppStateAction, SelectedRoom},
[m[32m+    home::{
[m[32m+        room_screen::RoomScreenWidgetExt, rooms_list::RoomsListAction,
[m[32m+        space_lobby::SpaceLobbyScreenWidgetExt,
[m[32m+    },
[m };

 use super::invite_screen::InviteScreenWidgetExt;
Diff in /app/src/home/main_mobile_ui.rs:63:
                     RoomsListAction::Selected(_selected_room) => {}
                     // Because the MainMobileUI is drawn based on the AppState only,
                     // all we need to do is update the AppState here.
[31m-                    RoomsListAction::InviteAccepted { room_name_id: room_name } => {
[m[31m-                        cx.action(AppStateAction::UpgradedInviteToJoinedRoom(room_name.room_id().clone()));
[m[32m+                    RoomsListAction::InviteAccepted {
[m[32m+                        room_name_id: room_name,
[m[32m+                    } => {
[m[32m+                        cx.action(AppStateAction::UpgradedInviteToJoinedRoom(
[m[32m+                            room_name.room_id().clone(),
[m[32m+                        ));
[m                     }
                     RoomsListAction::OpenRoomContextMenu { .. } => {}
                     RoomsListAction::None => {}
Diff in /app/src/home/main_mobile_ui.rs:119:

         self.view.view(ids!(welcome)).set_visible(cx, show_welcome);
         self.view.view(ids!(room_view)).set_visible(cx, show_room);
[31m-        self.view.view(ids!(invite_view)).set_visible(cx, show_invite);
[m[31m-        self.view.view(ids!(space_lobby_view)).set_visible(cx, show_space_lobby);
[m[32m+        self.view
[m[32m+            .view(ids!(invite_view))
[m[32m+            .set_visible(cx, show_invite);
[m[32m+        self.view
[m[32m+            .view(ids!(space_lobby_view))
[m[32m+            .set_visible(cx, show_space_lobby);
[m         self.view.draw_walk(cx, scope, walk)
     }
 }
Diff in /app/src/home/navigation_tab_bar.rs:9:
 //! 2. Add Room (plus sign icon): a separate view that allows adding (joining) existing rooms,
 //!    exploring public rooms, or creating new rooms/spaces.
 //! 3. Spaces: a button that toggles the `SpacesBar` (shows/hides it).
[31m-//!    * This is NOT a regular radio button, it's a separate toggle.
[m[32m+//!    * This is NOT a regular radio button, it's a separate toggle.
[m //!    * This is only shown in Mobile view mode, because the `SpacesBar` is always shown
 //!      within the NavigationTabBar itself in Desktop view mode.
 //! 4. Activity (an inbox, alert bell, or notifications icon): a separate view that shows
Diff in /app/src/home/navigation_tab_bar.rs:30:

 use makepad_widgets::*;
 use crate::{
[31m-    avatar_cache::{self, AvatarCacheEntry}, login::login_screen::LoginAction, logout::logout_confirm_modal::LogoutAction, profile::{
[m[32m+    avatar_cache::{self, AvatarCacheEntry},
[m[32m+    login::login_screen::LoginAction,
[m[32m+    logout::logout_confirm_modal::LogoutAction,
[m[32m+    profile::{
[m         user_profile::UserProfile,
         user_profile_cache::{self, UserProfileUpdate},
[31m-    }, shared::{
[m[31m-        avatar::{AvatarState, AvatarWidgetExt}, callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition}, styles::*, verification_badge::VerificationBadgeWidgetExt
[m[31m-    }, sliding_sync::{current_user_id, AccountDataAction}, utils::{self, RoomNameId}
[m[32m+    },
[m[32m+    shared::{
[m[32m+        avatar::{AvatarState, AvatarWidgetExt},
[m[32m+        callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition},
[m[32m+        styles::*,
[m[32m+        verification_badge::VerificationBadgeWidgetExt,
[m[32m+    },
[m[32m+    sliding_sync::{current_user_id, AccountDataAction},
[m[32m+    utils::{self, RoomNameId},
[m };

 live_design! {
Diff in /app/src/home/navigation_tab_bar.rs:55:
         width: Fill,
         height: (NAVIGATION_TAB_BAR_SIZE - 5),
         padding: 5,
[31m-        margin: 3,
[m[32m+        margin: 3,
[m         align: {x: 0.5, y: 0.5}
         flow: Down,
[31m-
[m[32m+
[m         icon_walk: {margin: 0, width: (NAVIGATION_TAB_BAR_SIZE/2.2), height: Fit}
         // Fully hide the text with zero size, zero margin, and zero spacing
         label_walk: {margin: 0, width: 0, height: 0}
Diff in /app/src/home/navigation_tab_bar.rs:214:
             flow: Down,
             align: {x: 0.5}
             padding: {top: 40., bottom: 8}
[31m-            width: (NAVIGATION_TAB_BAR_SIZE),
[m[32m+            width: (NAVIGATION_TAB_BAR_SIZE),
[m             height: Fill

             show_bg: true
Diff in /app/src/home/navigation_tab_bar.rs:241:
             }

             <Separator> {}
[31m-
[m[32m+
[m             <CachedWidget> {
                 settings_button = <SettingsButton> {}
             }
Diff in /app/src/home/navigation_tab_bar.rs:285:
 /// Clicking on this icon will open the settings screen.
 #[derive(Live, Widget)]
 pub struct ProfileIcon {
[31m-    #[deref] view: View,
[m[31m-    #[rust] own_profile: Option<UserProfile>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    own_profile: Option<UserProfile>,
[m }

 impl LiveHook for ProfileIcon {
Diff in /app/src/home/navigation_tab_bar.rs:309:
                 needs_redraw = true;
             }
             // If we're waiting for an avatar image, process avatar updates.
[31m-            if let Some(p) = self.own_profile.as_mut() && p.avatar_state.uri().is_some() {
[m[32m+            if let Some(p) = self.own_profile.as_mut()
[m[32m+                && p.avatar_state.uri().is_some()
[m[32m+            {
[m                 avatar_cache::process_avatar_updates(cx);
                 let new_data = p.avatar_state.update_from_cache(cx);
                 needs_redraw |= new_data.is_some();
Diff in /app/src/home/navigation_tab_bar.rs:316:
                 if new_data.is_some() {
                     user_profile_cache::enqueue_user_profile_update(
[31m-                        UserProfileUpdate::UserProfileOnly(p.clone())
[m[32m+                        UserProfileUpdate::UserProfileOnly(p.clone()),
[m                     );
                 }
             }
Diff in /app/src/home/navigation_tab_bar.rs:347:
                         if let Some(p) = self.own_profile.as_mut() {
                             p.avatar_state = AvatarState::Known(None);
                             user_profile_cache::enqueue_user_profile_update(
[31m-                                UserProfileUpdate::UserProfileOnly(p.clone())
[m[32m+                                UserProfileUpdate::UserProfileOnly(p.clone()),
[m                             );
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/navigation_tab_bar.rs:358:
                             p.avatar_state = AvatarState::Known(Some(new_uri.clone()));
                             p.avatar_state.update_from_cache(cx);
                             user_profile_cache::enqueue_user_profile_update(
[31m-                                UserProfileUpdate::UserProfileOnly(p.clone())
[m[32m+                                UserProfileUpdate::UserProfileOnly(p.clone()),
[m                             );
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/navigation_tab_bar.rs:372:
                         if let Some(p) = self.own_profile.as_mut() {
                             p.username = new_display_name.clone();
                             user_profile_cache::enqueue_user_profile_update(
[31m-                                UserProfileUpdate::UserProfileOnly(p.clone())
[m[32m+                                UserProfileUpdate::UserProfileOnly(p.clone()),
[m                             );
                             self.view.redraw(cx);
                         }
Diff in /app/src/home/navigation_tab_bar.rs:390:
         let area = self.view.area();
         match event.hits(cx, area) {
             Hit::FingerLongPress(_) | Hit::FingerHoverIn(_) => {
[31m-                let (verification_str, bg_color) = self.view
[m[32m+                let (verification_str, bg_color) = self
[m[32m+                    .view
[m                     .verification_badge(ids!(verification_badge))
                     .tooltip_content();
                 let text = self.own_profile.as_ref().map_or_else(
Diff in /app/src/home/navigation_tab_bar.rs:397:
                     || format!("Not logged in.\n\n{}", verification_str),
[31m-                    |p| format!("Logged in as \"{}\".\n\n{}", p.displayable_name(), verification_str)
[m[32m+                    |p| {
[m[32m+                        format!(
[m[32m+                            "Logged in as \"{}\".\n\n{}",
[m[32m+                            p.displayable_name(),
[m[32m+                            verification_str
[m[32m+                        )
[m[32m+                    },
[m                 );
                 let mut options = CalloutTooltipOptions {
[31m-                    position: if cx.display_context.is_desktop() { TooltipPosition::Right} else { TooltipPosition::Top},
[m[32m+                    position: if cx.display_context.is_desktop() {
[m[32m+                        TooltipPosition::Right
[m[32m+                    } else {
[m[32m+                        TooltipPosition::Top
[m[32m+                    },
[m                     ..Default::default()
                 };
                 if let Some(c) = bg_color {
Diff in /app/src/home/navigation_tab_bar.rs:417:
             Hit::FingerHoverOut(_) => {
                 cx.widget_action(self.widget_uid(), &scope.path, TooltipAction::HoverOut);
             }
[31m-            _ => { }
[m[32m+            _ => {}
[m         };

         self.view.handle_event(cx, event, scope);
Diff in /app/src/home/navigation_tab_bar.rs:438:

         let mut drew_avatar = false;
         if let Some(avatar_img_data) = own_profile.avatar_state.data() {
[31m-            drew_avatar = our_own_avatar.show_image(
[m[31m-                cx,
[m[31m-                None, // don't make this avatar clickable; we handle clicks on this ProfileIcon widget directly.
[m[31m-                |cx, img| utils::load_png_or_jpg(&img, cx, avatar_img_data),
[m[31m-            ).is_ok();
[m[32m+            drew_avatar = our_own_avatar
[m[32m+                .show_image(
[m[32m+                    cx,
[m[32m+                    None, // don't make this avatar clickable; we handle clicks on this ProfileIcon widget directly.
[m[32m+                    |cx, img| utils::load_png_or_jpg(&img, cx, avatar_img_data),
[m[32m+                )
[m[32m+                .is_ok();
[m         }
         if !drew_avatar {
             our_own_avatar.show_text(
Diff in /app/src/home/navigation_tab_bar.rs:457:
     }
 }

[31m-
[m /// The tab bar with buttons that navigate through top-level app pages.
 ///
 /// * In the "desktop" (wide) layout, this is a vertical bar on the left.
Diff in /app/src/home/navigation_tab_bar.rs:464:
 /// * In the "mobile" (narrow) layout, this is a horizontal bar on the bottom.
 #[derive(Live, LiveHook, Widget)]
 pub struct NavigationTabBar {
[31m-    #[deref] view: AdaptiveView,
[m[32m+    #[deref]
[m[32m+    view: AdaptiveView,
[m
[31m-    #[rust] is_spaces_bar_shown: bool,
[m[32m+    #[rust]
[m[32m+    is_spaces_bar_shown: bool,
[m }

 impl Widget for NavigationTabBar {
Diff in /app/src/home/navigation_tab_bar.rs:484:
                 Some(0) => cx.action(NavigationBarAction::GoToHome),
                 Some(1) => cx.action(NavigationBarAction::GoToAddRoom),
                 Some(2) => cx.action(NavigationBarAction::OpenSettings),
[31m-                _ => { }
[m[32m+                _ => {}
[m             }

[31m-            if self.view.button(ids!(toggle_spaces_bar_button)).clicked(actions) {
[m[32m+            if self
[m[32m+                .view
[m[32m+                .button(ids!(toggle_spaces_bar_button))
[m[32m+                .clicked(actions)
[m[32m+            {
[m                 self.is_spaces_bar_shown = !self.is_spaces_bar_shown;
                 cx.action(NavigationBarAction::ToggleSpacesBar);
             }
Diff in /app/src/home/navigation_tab_bar.rs:497:
                 // update our radio buttons accordingly.
                 if let Some(NavigationBarAction::TabSelected(tab)) = action.downcast_ref() {
                     match tab {
[31m-                        SelectedTab::Home     => self.view.radio_button(ids!(home_button)).select(cx, scope),
[m[31m-                        SelectedTab::AddRoom  => self.view.radio_button(ids!(add_room_button)).select(cx, scope),
[m[31m-                        SelectedTab::Settings => self.view.radio_button(ids!(settings_button)).select(cx, scope),
[m[32m+                        SelectedTab::Home => {
[m[32m+                            self.view.radio_button(ids!(home_button)).select(cx, scope)
[m[32m+                        }
[m[32m+                        SelectedTab::AddRoom => self
[m[32m+                            .view
[m[32m+                            .radio_button(ids!(add_room_button))
[m[32m+                            .select(cx, scope),
[m[32m+                        SelectedTab::Settings => self
[m[32m+                            .view
[m[32m+                            .radio_button(ids!(settings_button))
[m[32m+                            .select(cx, scope),
[m                         SelectedTab::Space { .. } => {
                             for rb in radio_button_set.iter() {
                                 if let Some(mut rb_inner) = rb.borrow_mut() {
Diff in /app/src/home/navigation_tab_bar.rs:519:
     }
 }

[31m-
[m /// Which top-level view is currently shown, and which navigation tab is selected.
 #[derive(Clone, Debug, Default, PartialEq, Eq)]
 pub enum SelectedTab {
Diff in /app/src/home/navigation_tab_bar.rs:528:
     AddRoom,
     Settings,
     // AlertsInbox,
[31m-    Space { space_name_id: RoomNameId },
[m[32m+    Space {
[m[32m+        space_name_id: RoomNameId,
[m[32m+    },
[m }

[31m-
[m /// Actions for navigating through the top-level views of the app,
 /// e.g., when the user clicks/taps on a button in the NavigationTabBar.
 ///
Diff in /app/src/home/navigation_tab_bar.rs:574:
     GoToSpace { space_name_id: RoomNameId },

     // TODO: add GoToAlertsInbox, once we add that button/screen
[31m-
[m     /// The given tab was selected as the active top-level view.
[31m-    /// This is needed to ensure that the proper tab is marked as selected.
[m[32m+    /// This is needed to ensure that the proper tab is marked as selected.
[m     TabSelected(SelectedTab),
     /// Toggle whether the SpacesBar is shown, i.e., show/hide it.
     /// This is only applicable in the Mobile view mode, because the SpacesBar
Diff in /app/src/home/navigation_tab_bar.rs:584:
     ToggleSpacesBar,
 }

[31m-
[m /// Returns the current user's profile and avatar, if available.
 pub fn get_own_profile(cx: &mut Cx) -> Option<UserProfile> {
     let mut own_profile = None;
Diff in /app/src/home/navigation_tab_bar.rs:602:
         );
         // If we have an avatar URI to fetch, try to fetch it.
         if let Some(Some(avatar_uri)) = avatar_uri_to_fetch {
[31m-            if let AvatarCacheEntry::Loaded(data) = avatar_cache::get_or_fetch_avatar(cx, &avatar_uri) {
[m[32m+            if let AvatarCacheEntry::Loaded(data) =
[m[32m+                avatar_cache::get_or_fetch_avatar(cx, &avatar_uri)
[m[32m+            {
[m                 if let Some(p) = own_profile.as_mut() {
                     p.avatar_state = AvatarState::Loaded(data);
                     // Update the user profile cache with the new avatar data.
Diff in /app/src/home/navigation_tab_bar.rs:609:
                     user_profile_cache::enqueue_user_profile_update(
[31m-                        UserProfileUpdate::UserProfileOnly(p.clone())
[m[32m+                        UserProfileUpdate::UserProfileOnly(p.clone()),
[m                     );
                 }
             }
Diff in /app/src/home/new_message_context_menu.rs:11:
 use super::room_screen::MessageAction;

 const BUTTON_HEIGHT: f64 = 35.0; // KEEP IN SYNC WITH BUTTON_HEIGHT BELOW
[31m-const MENU_WIDTH: f64 = 215.0;   // KEEP IN SYNC WITH MENU_WIDTH BELOW
[m[32m+const MENU_WIDTH: f64 = 215.0; // KEEP IN SYNC WITH MENU_WIDTH BELOW
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/new_message_context_menu.rs:219:
     }
 }

[31m-
[m bitflags! {
     /// Possible actions that the user can perform on a message.
     ///
Diff in /app/src/home/new_message_context_menu.rs:259:
             abilities.set(Self::CanDelete, user_power_levels.can_redact_own());
         }
         abilities.set(Self::CanReplyTo, event_tl_item.can_be_replied_to());
[31m-        if let Some(event_id) = event_tl_item.event_id() && user_power_levels.can_pin() {
[m[32m+        if let Some(event_id) = event_tl_item.event_id()
[m[32m+            && user_power_levels.can_pin()
[m[32m+        {
[m             if pinned_events.iter().any(|ev| ev == event_id) {
                 abilities.set(Self::CanUnpin, true);
             } else {
Diff in /app/src/home/new_message_context_menu.rs:270:
         abilities.set(Self::HasHtml, has_html);
         abilities
     }
[31m-
[m }

 /// Details about the message that define its context menu content.
Diff in /app/src/home/new_message_context_menu.rs:303:

 #[derive(Live, LiveHook, Widget)]
 pub struct NewMessageContextMenu {
[31m-    #[deref] view: View,
[m[31m-    #[rust] details: Option<MessageDetails>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    details: Option<MessageDetails>,
[m }

 impl Widget for NewMessageContextMenu {
Diff in /app/src/home/new_message_context_menu.rs:317:
     }

     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
[31m-        if !self.visible { return; }
[m[32m+        if !self.visible {
[m[32m+            return;
[m[32m+        }
[m         self.view.handle_event(cx, event, scope);

         let area = self.view.area();
Diff in /app/src/home/new_message_context_menu.rs:329:
         // 4. The user scrolls anywhere.
         let close_menu = {
             event.back_pressed()
[31m-            || match event.hits_with_capture_overload(cx, area, true) {
[m[31m-                Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[31m-                Hit::FingerDown(fde) => {
[m[31m-                    let reaction_text_input = self.view.text_input(ids!(reaction_input_view.reaction_text_input));
[m[31m-                    if reaction_text_input.area().rect(cx).contains(fde.abs) {
[m[31m-                        reaction_text_input.set_key_focus(cx);
[m[31m-                    } else {
[m[31m-                        cx.set_key_focus(area);
[m[32m+                || match event.hits_with_capture_overload(cx, area, true) {
[m[32m+                    Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[32m+                    Hit::FingerDown(fde) => {
[m[32m+                        let reaction_text_input = self
[m[32m+                            .view
[m[32m+                            .text_input(ids!(reaction_input_view.reaction_text_input));
[m[32m+                        if reaction_text_input.area().rect(cx).contains(fde.abs) {
[m[32m+                            reaction_text_input.set_key_focus(cx);
[m[32m+                        } else {
[m[32m+                            cx.set_key_focus(area);
[m[32m+                        }
[m[32m+                        false
[m                     }
[31m-                    false
[m[32m+                    Hit::FingerUp(fue) if fue.is_over => !self
[m[32m+                        .view(ids!(main_content))
[m[32m+                        .area()
[m[32m+                        .rect(cx)
[m[32m+                        .contains(fue.abs),
[m[32m+                    Hit::FingerScroll(_) => true,
[m[32m+                    _ => false,
[m                 }
[31m-                Hit::FingerUp(fue) if fue.is_over => {
[m[31m-                    !self.view(ids!(main_content)).area().rect(cx).contains(fue.abs)
[m[31m-                }
[m[31m-                Hit::FingerScroll(_) => true,
[m[31m-                _ => false,
[m[31m-            }
[m         };
         if close_menu {
             self.close(cx);
Diff in /app/src/home/new_message_context_menu.rs:358:

 impl WidgetMatchEvent for NewMessageContextMenu {
     fn handle_actions(&mut self, cx: &mut Cx, actions: &Actions, scope: &mut Scope) {
[31m-        let Some(details) = self.details.as_ref() else { return };
[m[32m+        let Some(details) = self.details.as_ref() else {
[m[32m+            return;
[m[32m+        };
[m         let mut close_menu = false;

[31m-        let reaction_text_input = self.view.text_input(ids!(reaction_input_view.reaction_text_input));
[m[31m-        let reaction_send_button = self.view.button(ids!(reaction_input_view.reaction_send_button));
[m[31m-        if reaction_send_button.clicked(actions)
[m[31m-            || reaction_text_input.returned(actions).is_some()
[m[32m+        let reaction_text_input = self
[m[32m+            .view
[m[32m+            .text_input(ids!(reaction_input_view.reaction_text_input));
[m[32m+        let reaction_send_button = self
[m[32m+            .view
[m[32m+            .button(ids!(reaction_input_view.reaction_send_button));
[m[32m+        if reaction_send_button.clicked(actions) || reaction_text_input.returned(actions).is_some()
[m         {
             cx.widget_action(
                 details.room_screen_widget_uid,
Diff in /app/src/home/new_message_context_menu.rs:375:
                 },
             );
             close_menu = true;
[31m-        }
[m[31m-        else if reaction_text_input.escaped(actions) {
[m[32m+        } else if reaction_text_input.escaped(actions) {
[m             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(react_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(react_button)).clicked(actions) {
[m             // Show a box to allow the user to input the reaction.
             // In the future, we'll show an emoji chooser.
             self.view.button(ids!(react_button)).set_visible(cx, false);
Diff in /app/src/home/new_message_context_menu.rs:386:
[31m-            self.view.view(ids!(reaction_input_view)).set_visible(cx, true);
[m[31m-            self.text_input(ids!(reaction_input_view.reaction_text_input)).set_key_focus(cx);
[m[32m+            self.view
[m[32m+                .view(ids!(reaction_input_view))
[m[32m+                .set_visible(cx, true);
[m[32m+            self.text_input(ids!(reaction_input_view.reaction_text_input))
[m[32m+                .set_key_focus(cx);
[m             self.redraw(cx);
             close_menu = false;
[31m-        }
[m[31m-        else if self.button(ids!(reply_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(reply_button)).clicked(actions) {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:395:
                 MessageAction::Reply(details.clone()),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(edit_message_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(edit_message_button)).clicked(actions) {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:403:
                 MessageAction::Edit(details.clone()),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(pin_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(pin_button)).clicked(actions) {
[m             if details.abilities.contains(MessageAbilities::CanPin) {
                 cx.widget_action(
                     details.room_screen_widget_uid,
Diff in /app/src/home/new_message_context_menu.rs:419:
                 );
             }
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(copy_text_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(copy_text_button)).clicked(actions) {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:427:
                 MessageAction::CopyText(details.clone()),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(copy_html_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(copy_html_button)).clicked(actions) {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:435:
                 MessageAction::CopyHtml(details.clone()),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(copy_link_to_message_button)).clicked(actions) {
[m[32m+        } else if self
[m[32m+            .button(ids!(copy_link_to_message_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:443:
                 MessageAction::CopyLink(details.clone()),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(view_source_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(view_source_button)).clicked(actions) {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:451:
                 MessageAction::ViewSource(details.clone()),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(jump_to_related_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(jump_to_related_button)).clicked(actions) {
[m             cx.widget_action(
                 details.room_screen_widget_uid,
                 &scope.path,
Diff in /app/src/home/new_message_context_menu.rs:516:
     ///
     /// Returns the total height of all visible items.
     fn set_button_visibility(&mut self, cx: &mut Cx) -> f64 {
[31m-        let Some(details) = self.details.as_ref() else { return 0.0 };
[m[32m+        let Some(details) = self.details.as_ref() else {
[m[32m+            return 0.0;
[m[32m+        };
[m
         let react_button = self.view.button(ids!(react_button));
         let reply_button = self.view.button(ids!(reply_button));
Diff in /app/src/home/new_message_context_menu.rs:551:
         self.view.view(ids!(react_view)).set_visible(cx, show_react);
         react_button.set_visible(cx, show_react);
         reply_button.set_visible(cx, show_reply_to);
[31m-        self.view.view(ids!(divider_after_react_reply)).set_visible(cx, show_divider_after_react_reply);
[m[32m+        self.view
[m[32m+            .view(ids!(divider_after_react_reply))
[m[32m+            .set_visible(cx, show_divider_after_react_reply);
[m         edit_button.set_visible(cx, show_edit);
         if details.abilities.contains(MessageAbilities::CanPin) {
             pin_button.set_text(cx, "Pin Message");
Diff in /app/src/home/new_message_context_menu.rs:565:
         pin_button.set_visible(cx, show_pin);
         copy_html_button.set_visible(cx, show_copy_html);
         jump_to_related_button.set_visible(cx, show_jump_to_related);
[31m-        self.view.view(ids!(divider_before_report_delete)).set_visible(cx, show_divider_before_report_delete);
[m[32m+        self.view
[m[32m+            .view(ids!(divider_before_report_delete))
[m[32m+            .set_visible(cx, show_divider_before_report_delete);
[m         // report_button.set_visible(cx, show_report);
         delete_button.set_visible(cx, show_delete);

Diff in /app/src/home/new_message_context_menu.rs:583:
         delete_button.reset_hover(cx);

         // Reset reaction input view stuff.
[31m-        self.view.view(ids!(reaction_input_view)).set_visible(cx, false); // hide until the react_button is clicked
[m[31m-        self.text_input(ids!(reaction_input_view.reaction_text_input)).set_text(cx, "");
[m[32m+        self.view
[m[32m+            .view(ids!(reaction_input_view))
[m[32m+            .set_visible(cx, false); // hide until the react_button is clicked
[m[32m+        self.text_input(ids!(reaction_input_view.reaction_text_input))
[m[32m+            .set_text(cx, "");
[m
         self.redraw(cx);

Diff in /app/src/home/new_message_context_menu.rs:591:
[31m-        let num_visible_buttons =
[m[31m-            show_react as u8
[m[32m+        let num_visible_buttons = show_react as u8
[m             + show_reply_to as u8
             + show_edit as u8
             + show_pin as u8
Diff in /app/src/home/new_message_context_menu.rs:606:
             + if show_divider_after_react_reply { 10.0 } else { 0.0 }
             + if show_divider_before_report_delete { 10.0 } else { 0.0 }
             + 20.0  // top and bottom padding
[31m-            + 1.0   // top and bottom border
[m[32m+            + 1.0 // top and bottom border
[m     }

     fn close(&mut self, cx: &mut Cx) {
Diff in /app/src/home/new_message_context_menu.rs:620:
 impl NewMessageContextMenuRef {
     /// See [`NewMessageContextMenu::is_currently_shown()`].
     pub fn is_currently_shown(&self, cx: &mut Cx) -> bool {
[31m-        let Some(inner) = self.borrow() else { return false };
[m[32m+        let Some(inner) = self.borrow() else {
[m[32m+            return false;
[m[32m+        };
[m         inner.is_currently_shown(cx)
     }

Diff in /app/src/home/new_message_context_menu.rs:627:
     /// See [`NewMessageContextMenu::show()`].
     pub fn show(&self, cx: &mut Cx, details: MessageDetails) -> DVec2 {
[31m-        let Some(mut inner) = self.borrow_mut() else { return DVec2::default()};
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return DVec2::default();
[m[32m+        };
[m         inner.show(cx, details)
     }
 }
Diff in /app/src/home/room_context_menu.rs:3:

 use makepad_widgets::*;
 use matrix_sdk::ruma::OwnedRoomId;
[31m-use crate::{home::invite_modal::InviteModalAction, shared::popup_list::{PopupKind, enqueue_popup_notification}, sliding_sync::{MatrixRequest, submit_async_request}, utils::RoomNameId};
[m[32m+use crate::{
[m[32m+    home::invite_modal::InviteModalAction,
[m[32m+    shared::popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    sliding_sync::{MatrixRequest, submit_async_request},
[m[32m+    utils::RoomNameId,
[m[32m+};
[m
 const BUTTON_HEIGHT: f64 = 35.0;
 const MENU_WIDTH: f64 = 215.0;
Diff in /app/src/home/room_context_menu.rs:69:
             }

             priority_button = <ContextMenuButton> {
[31m-                draw_icon: { svg_file: (ICON_TOMBSTONE) }
[m[32m+                draw_icon: { svg_file: (ICON_TOMBSTONE) }
[m                 text: "Set Low Priority"
             }

Diff in /app/src/home/room_context_menu.rs:77:
                 draw_icon: { svg_file: (ICON_LINK) }
                 text: "Copy Link to Room"
             }
[31m-
[m[32m+
[m             divider1 = <LineH> {
                 margin: {top: 3, bottom: 3}
                 width: Fill,
Diff in /app/src/home/room_context_menu.rs:142:

 #[derive(Live, LiveHook, Widget)]
 pub struct RoomContextMenu {
[31m-    #[deref] view: View,
[m[31m-    #[rust] details: Option<RoomContextMenuDetails>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    details: Option<RoomContextMenuDetails>,
[m }

 impl Widget for RoomContextMenu {
Diff in /app/src/home/room_context_menu.rs:155:
     }

     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
[31m-        if !self.visible { return; }
[m[32m+        if !self.visible {
[m[32m+            return;
[m[32m+        }
[m         self.view.handle_event(cx, event, scope);

         // Close logic similar to NewMessageContextMenu
Diff in /app/src/home/room_context_menu.rs:162:
         let area = self.view.area();
         let close_menu = {
             event.back_pressed()
[31m-            || match event.hits_with_capture_overload(cx, area, true) {
[m[31m-                Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[31m-                Hit::FingerUp(fue) if fue.is_over => {
[m[31m-                     !self.view(ids!(main_content)).area().rect(cx).contains(fue.abs)
[m[32m+                || match event.hits_with_capture_overload(cx, area, true) {
[m[32m+                    Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[32m+                    Hit::FingerUp(fue) if fue.is_over => !self
[m[32m+                        .view(ids!(main_content))
[m[32m+                        .area()
[m[32m+                        .rect(cx)
[m[32m+                        .contains(fue.abs),
[m[32m+                    Hit::FingerScroll(_) => true,
[m[32m+                    _ => false,
[m                 }
[31m-                 Hit::FingerScroll(_) => true,
[m[31m-                _ => false,
[m[31m-            }
[m         };

         if close_menu {
Diff in /app/src/home/room_context_menu.rs:183:

 impl WidgetMatchEvent for RoomContextMenu {
     fn handle_actions(&mut self, cx: &mut Cx, actions: &Actions, _scope: &mut Scope) {
[31m-        let Some(details) = self.details.as_ref() else { return };
[m[32m+        let Some(details) = self.details.as_ref() else {
[m[32m+            return;
[m[32m+        };
[m         let mut close_menu = false;
[31m-
[m[32m+
[m         if self.button(ids!(mark_unread_button)).clicked(actions) {
             submit_async_request(MatrixRequest::SetUnreadFlag {
                 room_id: details.room_name_id.room_id().clone(),
Diff in /app/src/home/room_context_menu.rs:192:
                 mark_as_unread: !details.is_marked_unread,
             });
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(favorite_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(favorite_button)).clicked(actions) {
[m             submit_async_request(MatrixRequest::SetIsFavorite {
                 room_id: details.room_name_id.room_id().clone(),
                 is_favorite: !details.is_favorite,
Diff in /app/src/home/room_context_menu.rs:200:
             });
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(priority_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(priority_button)).clicked(actions) {
[m             submit_async_request(MatrixRequest::SetIsLowPriority {
                 room_id: details.room_name_id.room_id().clone(),
                 is_low_priority: !details.is_low_priority,
Diff in /app/src/home/room_context_menu.rs:207:
             });
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(copy_link_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(copy_link_button)).clicked(actions) {
[m             submit_async_request(MatrixRequest::GenerateMatrixLink {
                 room_id: details.room_name_id.room_id().clone(),
                 event_id: None,
Diff in /app/src/home/room_context_menu.rs:215:
                 join_on_click: false,
             });
             close_menu = true;
[31m-        }
[m[31m-         else if self.button(ids!(room_settings_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(room_settings_button)).clicked(actions) {
[m             // TODO: handle/implement this
             enqueue_popup_notification(
                 "The room settings page is not yet implemented.",
Diff in /app/src/home/room_context_menu.rs:224:
                 Some(5.0),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(notifications_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(notifications_button)).clicked(actions) {
[m             // TODO: handle/implement this
             enqueue_popup_notification(
                 "The room notifications page is not yet implemented.",
Diff in /app/src/home/room_context_menu.rs:233:
                 Some(5.0),
             );
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(invite_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(invite_button)).clicked(actions) {
[m             cx.action(InviteModalAction::Open(details.room_name_id.clone()));
             close_menu = true;
[31m-        }
[m[31m-        else if self.button(ids!(leave_button)).clicked(actions) {
[m[32m+        } else if self.button(ids!(leave_button)).clicked(actions) {
[m             use crate::join_leave_room_modal::{JoinLeaveRoomModalAction, JoinLeaveModalKind};
             use crate::room::BasicRoomDetails;
             let room_details = BasicRoomDetails::Name(details.room_name_id.clone());
Diff in /app/src/home/room_context_menu.rs:267:
         cx.set_key_focus(self.view.area());
         dvec2(MENU_WIDTH, height)
     }
[31m-
[m[32m+
[m     fn update_buttons(&mut self, cx: &mut Cx, details: &RoomContextMenuDetails) -> f64 {
         let mark_unread_button = self.button(ids!(mark_unread_button));
         if details.is_marked_unread {
Diff in /app/src/home/room_context_menu.rs:275:
         } else {
             mark_unread_button.set_text(cx, "Mark as Unread");
         }
[31m-
[m[32m+
[m         let favorite_button = self.button(ids!(favorite_button));
         if details.is_favorite {
             favorite_button.set_text(cx, "Un-favorite");
Diff in /app/src/home/room_context_menu.rs:282:
         } else {
[31m-             favorite_button.set_text(cx, "Favorite");
[m[32m+            favorite_button.set_text(cx, "Favorite");
[m         }

         let priority_button = self.button(ids!(priority_button));
Diff in /app/src/home/room_context_menu.rs:289:
         } else {
             priority_button.set_text(cx, "Set Low Priority");
         }
[31m-
[m[32m+
[m         // Reset hover states
         mark_unread_button.reset_hover(cx);
         favorite_button.reset_hover(cx);
Diff in /app/src/home/room_context_menu.rs:299:
         self.button(ids!(notifications_button)).reset_hover(cx);
         self.button(ids!(invite_button)).reset_hover(cx);
         self.button(ids!(leave_button)).reset_hover(cx);
[31m-
[m[32m+
[m         self.redraw(cx);
[31m-
[m[32m+
[m         // Calculate height (rudimentary) - sum of visible buttons + padding
         // 8 buttons * 35.0 + 2 dividers * ~10.0 + padding
         (8.0 * BUTTON_HEIGHT) + 20.0 + 10.0 // approx
Diff in /app/src/home/room_context_menu.rs:317:

 impl RoomContextMenuRef {
     pub fn is_currently_shown(&self, cx: &mut Cx) -> bool {
[31m-        let Some(inner) = self.borrow() else { return false };
[m[32m+        let Some(inner) = self.borrow() else {
[m[32m+            return false;
[m[32m+        };
[m         inner.is_currently_shown(cx)
     }

Diff in /app/src/home/room_context_menu.rs:324:
     pub fn show(&self, cx: &mut Cx, details: RoomContextMenuDetails) -> DVec2 {
[31m-        let Some(mut inner) = self.borrow_mut() else { return DVec2::default()};
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return DVec2::default();
[m[32m+        };
[m         inner.show(cx, details)
     }
 }
Diff in /app/src/home/room_image_viewer.rs:6:
 };
 use reqwest::StatusCode;

[31m-use crate::{media_cache::{MediaCache, MediaCacheEntry}, shared::image_viewer::{ImageViewerAction, ImageViewerError, LoadState}};
[m[32m+use crate::{
[m[32m+    media_cache::{MediaCache, MediaCacheEntry},
[m[32m+    shared::image_viewer::{ImageViewerAction, ImageViewerError, LoadState},
[m[32m+};
[m
 /// Populates the image viewer modal with the given media content.
 ///
Diff in /app/src/home/room_read_receipt.rs:9:

 use std::cmp;

[31m-
[m /// The maximum number of items to display in the read receipts AvatarRow
 /// and its accompanying tooltip.
 pub const MAX_VISIBLE_AVATARS_IN_READ_RECEIPT: usize = 3;
Diff in /app/src/home/room_read_receipt.rs:97:
         let widget_rect = self.area.rect(cx);

         let should_hover_in = match event.hits(cx, self.area) {
[31m-            Hit::FingerLongPress(_)
[m[31m-            | Hit::FingerHoverIn(..) => true,
[m[32m+            Hit::FingerLongPress(_) | Hit::FingerHoverIn(..) => true,
[m             Hit::FingerUp(fue) if fue.is_over && fue.is_primary_hit() => true,
             Hit::FingerHoverOut(_) => {
                 cx.widget_action(uid, &scope.path, RoomScreenTooltipActions::HoverOut);
Diff in /app/src/home/room_read_receipt.rs:178:
             self.buttons.iter_mut().zip(receipts_map.iter().rev())
         {
             if !*drawn {
[31m-                let (_, drawn_status) = avatar_ref.set_avatar_and_get_username(
[m[31m-                    cx,
[m[31m-                    room_id,
[m[31m-                    user_id,
[m[31m-                    None,
[m[31m-                    event_id,
[m[31m-                    true,
[m[31m-                );
[m[32m+                let (_, drawn_status) = avatar_ref
[m[32m+                    .set_avatar_and_get_username(cx, room_id, user_id, None, event_id, true);
[m                 *drawn = drawn_status;
             }
         }
Diff in /app/src/home/room_screen.rs:1:
 //! A room screen is the UI view that displays a single Room's timeline of events/messages
 //! along with a message input bar at the bottom.

[31m-use std::{borrow::Cow, cell::RefCell, collections::BTreeMap, ops::{DerefMut, Range}, sync::Arc};
[m[32m+use std::{
[m[32m+    borrow::Cow,
[m[32m+    cell::RefCell,
[m[32m+    collections::BTreeMap,
[m[32m+    ops::{DerefMut, Range},
[m[32m+    sync::Arc,
[m[32m+};
[m
 use bytesize::ByteSize;
 use imbl::Vector;
Diff in /app/src/home/room_screen.rs:8:
 use makepad_widgets::{image_cache::ImageBuffer, *};
 use matrix_sdk::{
[31m-    OwnedServerName, RoomDisplayName, media::{MediaFormat, MediaRequestParameters}, room::RoomMember, ruma::{
[m[31m-        EventId, MatrixToUri, MatrixUri, OwnedEventId, OwnedMxcUri, OwnedRoomId, UserId, events::{
[m[32m+    OwnedServerName, RoomDisplayName,
[m[32m+    media::{MediaFormat, MediaRequestParameters},
[m[32m+    room::RoomMember,
[m[32m+    ruma::{
[m[32m+        EventId, MatrixToUri, MatrixUri, OwnedEventId, OwnedMxcUri, OwnedRoomId, UserId,
[m[32m+        events::{
[m             receipt::Receipt,
             room::{
[31m-                ImageInfo, MediaSource, message::{
[m[31m-                    AudioMessageEventContent, EmoteMessageEventContent, FileMessageEventContent, FormattedBody, ImageMessageEventContent, KeyVerificationRequestEventContent, LocationMessageEventContent, MessageFormat, MessageType, NoticeMessageEventContent, TextMessageEventContent, VideoMessageEventContent
[m[31m-                }
[m[32m+                ImageInfo, MediaSource,
[m[32m+                message::{
[m[32m+                    AudioMessageEventContent, EmoteMessageEventContent, FileMessageEventContent,
[m[32m+                    FormattedBody, ImageMessageEventContent, KeyVerificationRequestEventContent,
[m[32m+                    LocationMessageEventContent, MessageFormat, MessageType,
[m[32m+                    NoticeMessageEventContent, TextMessageEventContent, VideoMessageEventContent,
[m[32m+                },
[m             },
             sticker::{StickerEventContent, StickerMediaSource},
[31m-        }, matrix_uri::MatrixId, uint
[m[31m-    }
[m[32m+        },
[m[32m+        matrix_uri::MatrixId,
[m[32m+        uint,
[m[32m+    },
[m };
 use matrix_sdk_ui::timeline::{
[31m-    self, EmbeddedEvent, EncryptedMessage, EventTimelineItem, InReplyToDetails, MemberProfileChange, MembershipChange, MsgLikeContent, MsgLikeKind, OtherMessageLike, PollState, RoomMembershipChange, TimelineDetails, TimelineEventItemId, TimelineItem, TimelineItemContent, TimelineItemKind, VirtualTimelineItem
[m[32m+    self, EmbeddedEvent, EncryptedMessage, EventTimelineItem, InReplyToDetails,
[m[32m+    MemberProfileChange, MembershipChange, MsgLikeContent, MsgLikeKind, OtherMessageLike,
[m[32m+    PollState, RoomMembershipChange, TimelineDetails, TimelineEventItemId, TimelineItem,
[m[32m+    TimelineItemContent, TimelineItemKind, VirtualTimelineItem,
[m };
[31m-use ruma::{OwnedUserId, events::{AnySyncMessageLikeEvent, AnySyncTimelineEvent, SyncMessageLikeEvent}};
[m[32m+use ruma::{
[m[32m+    OwnedUserId,
[m[32m+    events::{AnySyncMessageLikeEvent, AnySyncTimelineEvent, SyncMessageLikeEvent},
[m[32m+};
[m
 use crate::{
[31m-    app::{AppStateAction, ConfirmDeleteAction}, avatar_cache, event_preview::{plaintext_body_of_timeline_item, text_preview_of_encrypted_message, text_preview_of_member_profile_change, text_preview_of_other_message_like, text_preview_of_other_state, text_preview_of_room_membership_change, text_preview_of_timeline_item}, home::{edited_indicator::EditedIndicatorWidgetRefExt, link_preview::{LinkPreviewCache, LinkPreviewRef, LinkPreviewWidgetRefExt}, loading_pane::{LoadingPaneState, LoadingPaneWidgetExt}, room_image_viewer::{get_image_name_and_filesize, populate_matrix_image_modal}, rooms_list::RoomsListRef, tombstone_footer::SuccessorRoomDetails}, media_cache::{MediaCache, MediaCacheEntry}, profile::{
[m[31m-        user_profile::{ShowUserProfileAction, UserProfile, UserProfileAndRoomId, UserProfilePaneInfo, UserProfileSlidingPaneRef, UserProfileSlidingPaneWidgetExt},
[m[32m+    app::{AppStateAction, ConfirmDeleteAction},
[m[32m+    avatar_cache,
[m[32m+    event_preview::{
[m[32m+        plaintext_body_of_timeline_item, text_preview_of_encrypted_message,
[m[32m+        text_preview_of_member_profile_change, text_preview_of_other_message_like,
[m[32m+        text_preview_of_other_state, text_preview_of_room_membership_change,
[m[32m+        text_preview_of_timeline_item,
[m[32m+    },
[m[32m+    home::{
[m[32m+        edited_indicator::EditedIndicatorWidgetRefExt,
[m[32m+        link_preview::{LinkPreviewCache, LinkPreviewRef, LinkPreviewWidgetRefExt},
[m[32m+        loading_pane::{LoadingPaneState, LoadingPaneWidgetExt},
[m[32m+        room_image_viewer::{get_image_name_and_filesize, populate_matrix_image_modal},
[m[32m+        rooms_list::RoomsListRef,
[m[32m+        tombstone_footer::SuccessorRoomDetails,
[m[32m+    },
[m[32m+    media_cache::{MediaCache, MediaCacheEntry},
[m[32m+    profile::{
[m[32m+        user_profile::{
[m[32m+            ShowUserProfileAction, UserProfile, UserProfileAndRoomId, UserProfilePaneInfo,
[m[32m+            UserProfileSlidingPaneRef, UserProfileSlidingPaneWidgetExt,
[m[32m+        },
[m         user_profile_cache,
     },
[31m-    room::{BasicRoomDetails, room_input_bar::RoomInputBarState, typing_notice::TypingNoticeWidgetExt},
[m[32m+    room::{
[m[32m+        BasicRoomDetails, room_input_bar::RoomInputBarState, typing_notice::TypingNoticeWidgetExt,
[m[32m+    },
[m     shared::{
[31m-        avatar::{AvatarState, AvatarWidgetRefExt}, callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition}, confirmation_modal::ConfirmationModalContent, html_or_plaintext::{HtmlOrPlaintextRef, HtmlOrPlaintextWidgetRefExt, RobrixHtmlLinkAction}, image_viewer::{ImageViewerAction, ImageViewerMetaData, LoadState}, jump_to_bottom_button::{JumpToBottomButtonWidgetExt, UnreadMessageCount}, popup_list::{PopupKind, enqueue_popup_notification}, restore_status_view::RestoreStatusViewWidgetExt, styles::*, text_or_image::{TextOrImageAction, TextOrImageRef, TextOrImageWidgetRefExt}, timestamp::TimestampWidgetRefExt
[m[32m+        avatar::{AvatarState, AvatarWidgetRefExt},
[m[32m+        callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition},
[m[32m+        confirmation_modal::ConfirmationModalContent,
[m[32m+        html_or_plaintext::{
[m[32m+            HtmlOrPlaintextRef, HtmlOrPlaintextWidgetRefExt, RobrixHtmlLinkAction,
[m[32m+        },
[m[32m+        image_viewer::{ImageViewerAction, ImageViewerMetaData, LoadState},
[m[32m+        jump_to_bottom_button::{JumpToBottomButtonWidgetExt, UnreadMessageCount},
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+        restore_status_view::RestoreStatusViewWidgetExt,
[m[32m+        styles::*,
[m[32m+        text_or_image::{TextOrImageAction, TextOrImageRef, TextOrImageWidgetRefExt},
[m[32m+        timestamp::TimestampWidgetRefExt,
[m     },
[31m-    sliding_sync::{BackwardsPaginateUntilEventRequest, MatrixRequest, PaginationDirection, TimelineEndpoints, TimelineRequestSender, UserPowerLevels, get_client, submit_async_request, take_timeline_endpoints}, utils::{self, ImageFormat, MEDIA_THUMBNAIL_FORMAT, RoomNameId, unix_time_millis_to_datetime}
[m[32m+    sliding_sync::{
[m[32m+        BackwardsPaginateUntilEventRequest, MatrixRequest, PaginationDirection, TimelineEndpoints,
[m[32m+        TimelineRequestSender, UserPowerLevels, get_client, submit_async_request,
[m[32m+        take_timeline_endpoints,
[m[32m+    },
[m[32m+    utils::{self, ImageFormat, MEDIA_THUMBNAIL_FORMAT, RoomNameId, unix_time_millis_to_datetime},
[m };
 use crate::home::event_reaction_list::ReactionListWidgetRefExt;
 use crate::home::room_read_receipt::AvatarRowWidgetRefExt;
Diff in /app/src/home/room_screen.rs:42:

 use rangemap::RangeSet;

[31m-use super::{event_reaction_list::ReactionData, loading_pane::LoadingPaneRef, new_message_context_menu::{MessageAbilities, MessageDetails}, room_read_receipt::{self, populate_read_receipts, MAX_VISIBLE_AVATARS_IN_READ_RECEIPT}};
[m[32m+use super::{
[m[32m+    event_reaction_list::ReactionData,
[m[32m+    loading_pane::LoadingPaneRef,
[m[32m+    new_message_context_menu::{MessageAbilities, MessageDetails},
[m[32m+    room_read_receipt::{self, populate_read_receipts, MAX_VISIBLE_AVATARS_IN_READ_RECEIPT},
[m[32m+};
[m
 /// The maximum number of timeline items to search through
 /// when looking for a particular event.
Diff in /app/src/home/room_screen.rs:576:
 /// The main widget that displays a single Matrix room.
 #[derive(Live, Widget)]
 pub struct RoomScreen {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// The name and ID of the currently-shown room, if any.
[31m-    #[rust] room_name_id: Option<RoomNameId>,
[m[32m+    #[rust]
[m[32m+    room_name_id: Option<RoomNameId>,
[m     /// The persistent UI-relevant states for the room that this widget is currently displaying.
[31m-    #[rust] tl_state: Option<TimelineUiState>,
[m[32m+    #[rust]
[m[32m+    tl_state: Option<TimelineUiState>,
[m     /// The set of pinned events in this room.
[31m-    #[rust] pinned_events: Vec<OwnedEventId>,
[m[32m+    #[rust]
[m[32m+    pinned_events: Vec<OwnedEventId>,
[m     /// Whether this room has been successfully loaded (received from the homeserver).
[31m-    #[rust] is_loaded: bool,
[m[32m+    #[rust]
[m[32m+    is_loaded: bool,
[m     /// Whether or not all rooms have been loaded (received from the homeserver).
[31m-    #[rust] all_rooms_loaded: bool,
[m[32m+    #[rust]
[m[32m+    all_rooms_loaded: bool,
[m }
 impl Drop for RoomScreen {
     fn drop(&mut self) {
Diff in /app/src/home/room_screen.rs:615:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         let room_screen_widget_uid = self.widget_uid();
         let portal_list = self.portal_list(ids!(timeline.list));
[31m-        let user_profile_sliding_pane = self.user_profile_sliding_pane(ids!(user_profile_sliding_pane));
[m[32m+        let user_profile_sliding_pane =
[m[32m+            self.user_profile_sliding_pane(ids!(user_profile_sliding_pane));
[m         let loading_pane = self.loading_pane(ids!(loading_pane));

         // Handle actions here before processing timeline updates.
Diff in /app/src/home/room_screen.rs:630:
                 if let RoomScreenTooltipActions::HoverInReactionButton {
                     widget_rect,
                     reaction_data,
[31m-                } = reaction_list.hovered_in(actions) {
[m[31m-                    let Some(_tl_state) = self.tl_state.as_ref() else { continue };
[m[31m-                    let tooltip_text_arr: Vec<String> = reaction_data.reaction_senders
[m[32m+                } = reaction_list.hovered_in(actions)
[m[32m+                {
[m[32m+                    let Some(_tl_state) = self.tl_state.as_ref() else {
[m[32m+                        continue;
[m[32m+                    };
[m[32m+                    let tooltip_text_arr: Vec<String> = reaction_data
[m[32m+                        .reaction_senders
[m                         .iter()
                         .map(|(sender, _react_info)| {
                             user_profile_cache::get_user_display_name_for_room(
Diff in /app/src/home/room_screen.rs:646:
                         })
                         .collect();

[31m-                    let mut tooltip_text = utils::human_readable_list(&tooltip_text_arr, MAX_VISIBLE_AVATARS_IN_READ_RECEIPT);
[m[32m+                    let mut tooltip_text = utils::human_readable_list(
[m[32m+                        &tooltip_text_arr,
[m[32m+                        MAX_VISIBLE_AVATARS_IN_READ_RECEIPT,
[m[32m+                    );
[m                     tooltip_text.push_str(&format!(" reacted with: {}", reaction_data.reaction));
                     cx.widget_action(
                         room_screen_widget_uid,
Diff in /app/src/home/room_screen.rs:664:

                 // Handle a hover-out action on the reaction list or avatar row.
                 let avatar_row_ref = wr.avatar_row(ids!(avatar_row));
[31m-                if reaction_list.hovered_out(actions)
[m[31m-                    || avatar_row_ref.hover_out(actions)
[m[31m-                {
[m[31m-                    cx.widget_action(
[m[31m-                        room_screen_widget_uid,
[m[31m-                        &scope.path,
[m[31m-                        TooltipAction::HoverOut,
[m[31m-                    );
[m[32m+                if reaction_list.hovered_out(actions) || avatar_row_ref.hover_out(actions) {
[m[32m+                    cx.widget_action(room_screen_widget_uid, &scope.path, TooltipAction::HoverOut);
[m                 }

                 // Handle a hover-in action on the avatar row: show a read receipts summary.
Diff in /app/src/home/room_screen.rs:678:
                 if let RoomScreenTooltipActions::HoverInReadReceipt {
                     widget_rect,
[31m-                    read_receipts
[m[31m-                } = avatar_row_ref.hover_in(actions) {
[m[31m-                    let Some(room_id) = self.room_id() else { return; };
[m[31m-                    let tooltip_text= room_read_receipt::populate_tooltip(cx, read_receipts, room_id);
[m[32m+                    read_receipts,
[m[32m+                } = avatar_row_ref.hover_in(actions)
[m[32m+                {
[m[32m+                    let Some(room_id) = self.room_id() else {
[m[32m+                        return;
[m[32m+                    };
[m[32m+                    let tooltip_text =
[m[32m+                        room_read_receipt::populate_tooltip(cx, read_receipts, room_id);
[m                     cx.widget_action(
                         room_screen_widget_uid,
                         &scope.path,
Diff in /app/src/home/room_screen.rs:697:

                 // Handle an image within the message being clicked.
                 let content_message = wr.text_or_image(ids!(content.message));
[31m-                if let TextOrImageAction::Clicked(mxc_uri) = actions.find_widget_action(content_message.widget_uid()).cast() {
[m[32m+                if let TextOrImageAction::Clicked(mxc_uri) = actions
[m[32m+                    .find_widget_action(content_message.widget_uid())
[m[32m+                    .cast()
[m[32m+                {
[m                     let texture = content_message.get_texture(cx);
[31m-                    self.handle_image_click(
[m[31m-                        cx,
[m[31m-                        mxc_uri,
[m[31m-                        texture,
[m[31m-                        index,
[m[31m-                    );
[m[32m+                    self.handle_image_click(cx, mxc_uri, texture, index);
[m                     continue;
                 }

Diff in /app/src/home/room_screen.rs:711:
                 // Handle the invite_user_button (in a SmallStateEvent) being clicked.
                 if wr.button(ids!(invite_user_button)).clicked(actions) {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { continue };
[m[31m-                    if let Some(event_tl_item) = tl.items.get(index).and_then(|item| item.as_event()) {
[m[31m-                        log!("invite_user_button clicked: index {index}, details: {:?}", event_tl_item);
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        continue;
[m[32m+                    };
[m[32m+                    if let Some(event_tl_item) =
[m[32m+                        tl.items.get(index).and_then(|item| item.as_event())
[m[32m+                    {
[m[32m+                        log!(
[m[32m+                            "invite_user_button clicked: index {index}, details: {:?}",
[m[32m+                            event_tl_item
[m[32m+                        );
[m                         let user_id = event_tl_item.sender().to_owned();
[31m-                        let username = if let TimelineDetails::Ready(profile) = event_tl_item.sender_profile() {
[m[32m+                        let username = if let TimelineDetails::Ready(profile) =
[m[32m+                            event_tl_item.sender_profile()
[m[32m+                        {
[m                             profile.display_name.as_deref().unwrap_or(user_id.as_str())
                         } else {
                             user_id.as_str()
Diff in /app/src/home/room_screen.rs:722:
                         let room_id = tl.room_id.clone();
                         let content = ConfirmationModalContent {
                             title_text: "Send Invitation".into(),
[31m-                            body_text: format!("Are you sure you want to invite {username} to this room?").into(),
[m[32m+                            body_text: format!(
[m[32m+                                "Are you sure you want to invite {username} to this room?"
[m[32m+                            )
[m[32m+                            .into(),
[m                             accept_button_text: Some("Invite".into()),
                             on_accept_clicked: Some(Box::new(move |_cx| {
[31m-                                submit_async_request(MatrixRequest::InviteUser { room_id, user_id });
[m[32m+                                submit_async_request(MatrixRequest::InviteUser {
[m[32m+                                    room_id,
[m[32m+                                    user_id,
[m[32m+                                });
[m                             })),
                             ..Default::default()
                         };
Diff in /app/src/home/room_screen.rs:732:
[31m-                        cx.action(InviteAction::ShowInviteConfirmationModal(RefCell::new(Some(content))));
[m[32m+                        cx.action(InviteAction::ShowInviteConfirmationModal(RefCell::new(
[m[32m+                            Some(content),
[m[32m+                        )));
[m                     }
                 }
             }
Diff in /app/src/home/room_screen.rs:738:

             for action in actions {
                 // Handle actions related to restoring the previously-saved state of rooms.
[31m-                if let Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, ..}) = action.downcast_ref() {
[m[31m-                    if self.room_name_id.as_ref().is_some_and(|rn| rn.room_id() == room_name_id.room_id()) {
[m[32m+                if let Some(AppStateAction::RoomLoadedSuccessfully { room_name_id, .. }) =
[m[32m+                    action.downcast_ref()
[m[32m+                {
[m[32m+                    if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|rn| rn.room_id() == room_name_id.room_id())
[m[32m+                    {
[m                         // `set_displayed_room()` does nothing if the room_name_id is unchanged, so we clear it first.
                         self.room_name_id = None;
                         self.set_displayed_room(cx, room_name_id);
Diff in /app/src/home/room_screen.rs:750:
                 // Handle InviteResultAction to show popup notifications.
                 if let Some(InviteResultAction::Sent { room_id, .. }) = action.downcast_ref() {
                     // Only handle if this is for the current room.
[31m-                    if self.room_name_id.as_ref().is_some_and(|rn| rn.room_id() == room_id) {
[m[32m+                    if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|rn| rn.room_id() == room_id)
[m[32m+                    {
[m                         enqueue_popup_notification(
                             "Sent invite successfully.",
                             PopupKind::Success,
Diff in /app/src/home/room_screen.rs:758:
                         );
                     }
                 }
[31m-                if let Some(InviteResultAction::Failed { room_id, error, .. }) = action.downcast_ref() {
[m[32m+                if let Some(InviteResultAction::Failed { room_id, error, .. }) =
[m[32m+                    action.downcast_ref()
[m[32m+                {
[m                     // Only handle if this is for the current room.
[31m-                    if self.room_name_id.as_ref().is_some_and(|rn| rn.room_id() == room_id) {
[m[32m+                    if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|rn| rn.room_id() == room_id)
[m[32m+                    {
[m                         enqueue_popup_notification(
                             format!("Failed to send invite.\n\nError: {error}"),
                             PopupKind::Error,
Diff in /app/src/home/room_screen.rs:770:
                 }

                 // Handle the highlight animation for a message.
[31m-                let Some(tl) = self.tl_state.as_mut() else { continue };
[m[31m-                if let MessageHighlightAnimationState::Pending { item_id } = tl.message_highlight_animation_state {
[m[32m+                let Some(tl) = self.tl_state.as_mut() else {
[m[32m+                    continue;
[m[32m+                };
[m[32m+                if let MessageHighlightAnimationState::Pending { item_id } =
[m[32m+                    tl.message_highlight_animation_state
[m[32m+                {
[m                     if portal_list.smooth_scroll_reached(actions) {
                         cx.widget_action(
                             room_screen_widget_uid,
Diff in /app/src/home/room_screen.rs:788:
                 // TODO: move this into the `actions_generated_within_this_room_screen.retain(...)` code block,
                 //       where we won't need to bother checking if the room ID is the same as this RoomScreen,
                 //       because that block guarantees that it came from this RoomScreen.
[31m-                if let ShowUserProfileAction::ShowUserProfile(profile_and_room_id) = action.as_widget_action().cast() {
[m[32m+                if let ShowUserProfileAction::ShowUserProfile(profile_and_room_id) =
[m[32m+                    action.as_widget_action().cast()
[m[32m+                {
[m                     // Only show the user profile in room that this avatar belongs to
[31m-                    if self.room_name_id.as_ref().is_some_and(|rn| rn.room_id() == &profile_and_room_id.room_id) {
[m[32m+                    if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|rn| rn.room_id() == &profile_and_room_id.room_id)
[m[32m+                    {
[m                         self.show_user_profile(
                             cx,
                             &user_profile_sliding_pane,
Diff in /app/src/home/room_screen.rs:797:
                             UserProfilePaneInfo {
                                 profile_and_room_id,
[31m-                                room_name: self.room_name_id.as_ref().map_or_else(
[m[31m-                                    || UNNAMED_ROOM.to_string(),
[m[31m-                                    |r| r.to_string(),
[m[31m-                                ),
[m[32m+                                room_name: self
[m[32m+                                    .room_name_id
[m[32m+                                    .as_ref()
[m[32m+                                    .map_or_else(|| UNNAMED_ROOM.to_string(), |r| r.to_string()),
[m                                 room_member: None,
                             },
                         );
Diff in /app/src/home/room_screen.rs:821:
             self.send_user_read_receipts_based_on_scroll_pos(cx, actions, &portal_list);

             // Handle the jump to bottom button: update its visibility, and handle clicks.
[31m-            self.jump_to_bottom_button(ids!(jump_to_bottom)).update_from_actions(
[m[31m-                cx,
[m[31m-                &portal_list,
[m[31m-                actions,
[m[31m-            );
[m[32m+            self.jump_to_bottom_button(ids!(jump_to_bottom))
[m[32m+                .update_from_actions(cx, &portal_list, actions);
[m         }

         // Currently, a Signal event is only used to tell this widget:
Diff in /app/src/home/room_screen.rs:832:
         // 1. to check if the room has been loaded from the homeserver yet, or
         // 2. that its timeline events have been updated in the background.
         if let Event::Signal = event {
[31m-            if let (false, Some(room_name_id), true) = (self.is_loaded, self.room_name_id.as_ref(), cx.has_global::<RoomsListRef>()) {
[m[32m+            if let (false, Some(room_name_id), true) = (
[m[32m+                self.is_loaded,
[m[32m+                self.room_name_id.as_ref(),
[m[32m+                cx.has_global::<RoomsListRef>(),
[m[32m+            ) {
[m                 let rooms_list_ref = cx.get_global::<RoomsListRef>();
                 if rooms_list_ref.is_room_loaded(room_name_id.room_id()) {
                     let room_name_clone = room_name_id.clone();
Diff in /app/src/home/room_screen.rs:869:
             if is_interactive_hit {
                 loading_pane.handle_event(cx, event, scope);
             }
[31m-        }
[m[31m-        else if user_profile_sliding_pane.is_currently_shown(cx) {
[m[32m+        } else if user_profile_sliding_pane.is_currently_shown(cx) {
[m             is_pane_shown = true;
             if is_interactive_hit {
                 user_profile_sliding_pane.handle_event(cx, event, scope);
Diff in /app/src/home/room_screen.rs:877:
             }
[31m-        }
[m[31m-        else {
[m[32m+        } else {
[m             is_pane_shown = false;
         }

Diff in /app/src/home/room_screen.rs:895:
                 // Fetch room data once to avoid duplicate expensive lookups
                 let (room_display_name, room_avatar_url) = get_client()
                     .and_then(|client| client.get_room(&room_id))
[31m-                    .map(|room| (
[m[31m-                        room.cached_display_name().unwrap_or(RoomDisplayName::Empty),
[m[31m-                        room.avatar_url()
[m[31m-                    ))
[m[32m+                    .map(|room| {
[m[32m+                        (
[m[32m+                            room.cached_display_name().unwrap_or(RoomDisplayName::Empty),
[m[32m+                            room.avatar_url(),
[m[32m+                        )
[m[32m+                    })
[m                     .unwrap_or((RoomDisplayName::Empty, None));

                 RoomScreenProps {
Diff in /app/src/home/room_screen.rs:917:
                 }
             } else {
                 // No room selected yet, skip event handling that requires room context
[31m-                log!("RoomScreen handling event with no room_name_id and no tl_state, skipping room-dependent event handling");
[m[32m+                log!(
[m[32m+                    "RoomScreen handling event with no room_name_id and no tl_state, skipping room-dependent event handling"
[m[32m+                );
[m                 if !is_pane_shown || !is_interactive_hit {
                     return;
                 }
Diff in /app/src/home/room_screen.rs:934:
             };
             let mut room_scope = Scope::with_props(&room_props);

[31m-
[m             // Forward the event to the inner timeline view, but capture any actions it produces
             // such that we can handle the ones relevant to only THIS RoomScreen widget right here and now,
             // ensuring they are not mistakenly handled by other RoomScreen widget instances.
Diff in /app/src/home/room_screen.rs:941:
[31m-            let mut actions_generated_within_this_room_screen = cx.capture_actions(|cx|
[m[31m-                self.view.handle_event(cx, event, &mut room_scope)
[m[31m-            );
[m[32m+            let mut actions_generated_within_this_room_screen =
[m[32m+                cx.capture_actions(|cx| self.view.handle_event(cx, event, &mut room_scope));
[m             // Here, we handle and remove any general actions that are relevant to only this RoomScreen.
             // Removing the handled actions ensures they are not mistakenly handled by other RoomScreen widget instances.
             actions_generated_within_this_room_screen.retain(|action| {
Diff in /app/src/home/room_screen.rs:996:
         }
     }

[31m-
[m     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         // If the room isn't loaded yet, we show the restore status label only.
         if !self.is_loaded {
Diff in /app/src/home/room_screen.rs:1014:
             return DrawStep::done();
         }

[31m-
[m         let room_screen_widget_uid = self.widget_uid();
         while let Some(subview) = self.view.draw_walk(cx, scope, walk).step() {
             // Here, we only need to handle drawing the portal list.
Diff in /app/src/home/room_screen.rs:1021:
             let portal_list_ref = subview.as_portal_list();
             let Some(mut list_ref) = portal_list_ref.borrow_mut() else {
[31m-                error!("!!! RoomScreen::draw_walk(): BUG: expected a PortalList widget, but got something else");
[m[32m+                error!(
[m[32m+                    "!!! RoomScreen::draw_walk(): BUG: expected a PortalList widget, but got something else"
[m[32m+                );
[m                 continue;
             };
             let Some(tl_state) = self.tl_state.as_mut() else {
Diff in /app/src/home/room_screen.rs:1054:
                     };
                     let (item, item_new_draw_status) = match timeline_item.kind() {
                         TimelineItemKind::Event(event_tl_item) => match event_tl_item.content() {
[31m-                            TimelineItemContent::MsgLike(msg_like_content) => match &msg_like_content.kind {
[m[31m-                                MsgLikeKind::Message(_)
[m[31m-                                | MsgLikeKind::Sticker(_)
[m[31m-                                | MsgLikeKind::Redacted => {
[m[31m-                                    let prev_event = tl_idx.checked_sub(1).and_then(|i| tl_items.get(i));
[m[31m-                                    populate_message_view(
[m[32m+                            TimelineItemContent::MsgLike(msg_like_content) => {
[m[32m+                                match &msg_like_content.kind {
[m[32m+                                    MsgLikeKind::Message(_)
[m[32m+                                    | MsgLikeKind::Sticker(_)
[m[32m+                                    | MsgLikeKind::Redacted => {
[m[32m+                                        let prev_event =
[m[32m+                                            tl_idx.checked_sub(1).and_then(|i| tl_items.get(i));
[m[32m+                                        populate_message_view(
[m[32m+                                            cx,
[m[32m+                                            list,
[m[32m+                                            item_id,
[m[32m+                                            room_id,
[m[32m+                                            event_tl_item,
[m[32m+                                            msg_like_content,
[m[32m+                                            prev_event,
[m[32m+                                            &mut tl_state.media_cache,
[m[32m+                                            &mut tl_state.link_preview_cache,
[m[32m+                                            &tl_state.user_power,
[m[32m+                                            &self.pinned_events,
[m[32m+                                            item_drawn_status,
[m[32m+                                            room_screen_widget_uid,
[m[32m+                                        )
[m[32m+                                    }
[m[32m+                                    // TODO: properly implement `Poll` as a regular Message-like timeline item.
[m[32m+                                    MsgLikeKind::Poll(poll_state) => populate_small_state_event(
[m                                         cx,
                                         list,
                                         item_id,
Diff in /app/src/home/room_screen.rs:1066:
                                         room_id,
                                         event_tl_item,
[31m-                                        msg_like_content,
[m[31m-                                        prev_event,
[m[31m-                                        &mut tl_state.media_cache,
[m[31m-                                        &mut tl_state.link_preview_cache,
[m[31m-                                        &tl_state.user_power,
[m[31m-                                        &self.pinned_events,
[m[32m+                                        poll_state,
[m                                         item_drawn_status,
[31m-                                        room_screen_widget_uid,
[m[31m-                                    )
[m[31m-                                },
[m[31m-                                // TODO: properly implement `Poll` as a regular Message-like timeline item.
[m[31m-                                MsgLikeKind::Poll(poll_state) => populate_small_state_event(
[m[32m+                                    ),
[m[32m+                                    MsgLikeKind::UnableToDecrypt(utd) => {
[m[32m+                                        populate_small_state_event(
[m[32m+                                            cx,
[m[32m+                                            list,
[m[32m+                                            item_id,
[m[32m+                                            room_id,
[m[32m+                                            event_tl_item,
[m[32m+                                            utd,
[m[32m+                                            item_drawn_status,
[m[32m+                                        )
[m[32m+                                    }
[m[32m+                                    MsgLikeKind::Other(other) => populate_small_state_event(
[m[32m+                                        cx,
[m[32m+                                        list,
[m[32m+                                        item_id,
[m[32m+                                        room_id,
[m[32m+                                        event_tl_item,
[m[32m+                                        other,
[m[32m+                                        item_drawn_status,
[m[32m+                                    ),
[m[32m+                                }
[m[32m+                            }
[m[32m+                            TimelineItemContent::MembershipChange(membership_change) => {
[m[32m+                                populate_small_state_event(
[m                                     cx,
                                     list,
                                     item_id,
Diff in /app/src/home/room_screen.rs:1083:
                                     room_id,
                                     event_tl_item,
[31m-                                    poll_state,
[m[32m+                                    membership_change,
[m                                     item_drawn_status,
[31m-                                ),
[m[31m-                                MsgLikeKind::UnableToDecrypt(utd) => populate_small_state_event(
[m[32m+                                )
[m[32m+                            }
[m[32m+                            TimelineItemContent::ProfileChange(profile_change) => {
[m[32m+                                populate_small_state_event(
[m                                     cx,
                                     list,
                                     item_id,
Diff in /app/src/home/room_screen.rs:1092:
                                     room_id,
                                     event_tl_item,
[31m-                                    utd,
[m[32m+                                    profile_change,
[m                                     item_drawn_status,
[31m-                                ),
[m[31m-                                MsgLikeKind::Other(other) => populate_small_state_event(
[m[31m-                                    cx,
[m[31m-                                    list,
[m[31m-                                    item_id,
[m[31m-                                    room_id,
[m[31m-                                    event_tl_item,
[m[31m-                                    other,
[m[31m-                                    item_drawn_status,
[m[31m-                                ),
[m[31m-                            },
[m[31m-                            TimelineItemContent::MembershipChange(membership_change) => populate_small_state_event(
[m[31m-                                cx,
[m[31m-                                list,
[m[31m-                                item_id,
[m[31m-                                room_id,
[m[31m-                                event_tl_item,
[m[31m-                                membership_change,
[m[31m-                                item_drawn_status,
[m[31m-                            ),
[m[31m-                            TimelineItemContent::ProfileChange(profile_change) => populate_small_state_event(
[m[31m-                                cx,
[m[31m-                                list,
[m[31m-                                item_id,
[m[31m-                                room_id,
[m[31m-                                event_tl_item,
[m[31m-                                profile_change,
[m[31m-                                item_drawn_status,
[m[31m-                            ),
[m[32m+                                )
[m[32m+                            }
[m                             TimelineItemContent::OtherState(other) => populate_small_state_event(
                                 cx,
                                 list,
Diff in /app/src/home/room_screen.rs:1133:
                             ),
                             unhandled => {
                                 let item = list.item(cx, item_id, id!(SmallStateEvent));
[31m-                                item.label(ids!(content)).set_text(cx, &format!("[Unsupported] {:?}", unhandled));
[m[32m+                                item.label(ids!(content))
[m[32m+                                    .set_text(cx, &format!("[Unsupported] {:?}", unhandled));
[m                                 (item, ItemDrawnStatus::both_drawn())
                             }
[31m-                        }
[m[32m+                        },
[m                         TimelineItemKind::Virtual(VirtualTimelineItem::DateDivider(millis)) => {
                             let item = list.item(cx, item_id, id!(DateDivider));
                             let text = unix_time_millis_to_datetime(*millis)
Diff in /app/src/home/room_screen.rs:1158:

                     // Now that we've drawn the item, add its index to the set of drawn items.
                     if item_new_draw_status.content_drawn {
[31m-                        tl_state.content_drawn_since_last_update.insert(tl_idx .. tl_idx + 1);
[m[32m+                        tl_state
[m[32m+                            .content_drawn_since_last_update
[m[32m+                            .insert(tl_idx..tl_idx + 1);
[m                     }
                     if item_new_draw_status.profile_drawn {
[31m-                        tl_state.profile_drawn_since_last_update.insert(tl_idx .. tl_idx + 1);
[m[32m+                        tl_state
[m[32m+                            .profile_drawn_since_last_update
[m[32m+                            .insert(tl_idx..tl_idx + 1);
[m                     }
                     item
                 };
Diff in /app/src/home/room_screen.rs:1171:
             // If the list is not filling the viewport, we need to back paginate the timeline
             // until we have enough events items to fill the viewport.
             if !tl_state.fully_paginated && !list.is_filling_viewport() {
[31m-                log!("Automatically paginating timeline to fill viewport for room {:?}", self.room_name_id);
[m[32m+                log!(
[m[32m+                    "Automatically paginating timeline to fill viewport for room {:?}",
[m[32m+                    self.room_name_id
[m[32m+                );
[m                 submit_async_request(MatrixRequest::PaginateRoomTimeline {
                     room_id: room_id.clone(),
                     num_events: 50,
Diff in /app/src/home/room_screen.rs:1196:
         let jump_to_bottom = self.jump_to_bottom_button(ids!(jump_to_bottom));
         let curr_first_id = portal_list.first_id();
         let ui = self.widget_uid();
[31m-        let Some(tl) = self.tl_state.as_mut() else { return };
[m[32m+        let Some(tl) = self.tl_state.as_mut() else {
[m[32m+            return;
[m[32m+        };
[m
         let mut done_loading = false;
         let mut should_continue_backwards_pagination = false;
Diff in /app/src/home/room_screen.rs:1217:
                     tl.items = initial_items;
                     done_loading = true;
                 }
[31m-                TimelineUpdate::NewItems { new_items, changed_indices, is_append, clear_cache } => {
[m[32m+                TimelineUpdate::NewItems {
[m[32m+                    new_items,
[m[32m+                    changed_indices,
[m[32m+                    is_append,
[m[32m+                    clear_cache,
[m[32m+                } => {
[m                     if new_items.is_empty() {
                         if !tl.items.is_empty() {
[31m-                            log!("process_timeline_updates(): timeline (had {} items) was cleared for room {}", tl.items.len(), tl.room_id);
[m[32m+                            log!(
[m[32m+                                "process_timeline_updates(): timeline (had {} items) was cleared for room {}",
[m[32m+                                tl.items.len(),
[m[32m+                                tl.room_id
[m[32m+                            );
[m                             // For now, we paginate a cleared timeline in order to be able to show something at least.
                             // A proper solution would be what's described below, which would be to save a few event IDs
                             // and then either focus on them (if we're not close to the end of the timeline)
Diff in /app/src/home/room_screen.rs:1254:

                     if new_items.len() == tl.items.len() {
                         // log!("process_timeline_updates(): no jump necessary for updated timeline of same length: {}", items.len());
[31m-                    }
[m[31m-                    else if curr_first_id > new_items.len() {
[m[31m-                        log!("process_timeline_updates(): jumping to bottom: curr_first_id {} is out of bounds for {} new items", curr_first_id, new_items.len());
[m[32m+                    } else if curr_first_id > new_items.len() {
[m[32m+                        log!(
[m[32m+                            "process_timeline_updates(): jumping to bottom: curr_first_id {} is out of bounds for {} new items",
[m[32m+                            curr_first_id,
[m[32m+                            new_items.len()
[m[32m+                        );
[m                         portal_list.set_first_id_and_scroll(new_items.len().saturating_sub(1), 0.0);
                         portal_list.set_tail_range(true);
                         jump_to_bottom.update_visibility(cx, true);
Diff in /app/src/home/room_screen.rs:1265:
                     // in the timeline viewport so that we can maintain the scroll position of that item,
                     // which ensures that the timeline doesn't jump around unexpectedly and ruin the user's experience.
                     else if let Some((curr_item_idx, new_item_idx, new_item_scroll, _event_id)) =
[31m-                        prior_items_changed.then(||
[m[31m-                            find_new_item_matching_current_item(cx, portal_list, curr_first_id, &tl.items, &new_items)
[m[31m-                        )
[m[31m-                        .flatten()
[m[32m+                        prior_items_changed
[m[32m+                            .then(|| {
[m[32m+                                find_new_item_matching_current_item(
[m[32m+                                    cx,
[m[32m+                                    portal_list,
[m[32m+                                    curr_first_id,
[m[32m+                                    &tl.items,
[m[32m+                                    &new_items,
[m[32m+                                )
[m[32m+                            })
[m[32m+                            .flatten()
[m                     {
                         if curr_item_idx != new_item_idx {
[31m-                            log!("process_timeline_updates(): jumping view from event index {curr_item_idx} to new index {new_item_idx}, scroll {new_item_scroll}, event ID {_event_id}");
[m[32m+                            log!(
[m[32m+                                "process_timeline_updates(): jumping view from event index {curr_item_idx} to new index {new_item_idx}, scroll {new_item_scroll}, event ID {_event_id}"
[m[32m+                            );
[m                             portal_list.set_first_id_and_scroll(new_item_idx, new_item_scroll);
                             tl.prev_first_index = Some(new_item_idx);
                             // Set scrolled_past_read_marker false when we jump to a new event
Diff in /app/src/home/room_screen.rs:1278:
                             tl.scrolled_past_read_marker = false;
                             // Hide the tooltip when the timeline jumps, as a hover-out event won't occur.
[31m-                            cx.widget_action(ui, &HeapLiveIdPath::default(), RoomScreenTooltipActions::HoverOut);
[m[32m+                            cx.widget_action(
[m[32m+                                ui,
[m[32m+                                &HeapLiveIdPath::default(),
[m[32m+                                RoomScreenTooltipActions::HoverOut,
[m[32m+                            );
[m                         }
                     }
                     //
Diff in /app/src/home/room_screen.rs:1291:
                     if is_append && !portal_list.is_at_end() {
                         // Immediately show the unread badge with no count while we fetch the actual count in the background.
                         jump_to_bottom.show_unread_message_badge(cx, UnreadMessageCount::Unknown);
[31m-                        submit_async_request(MatrixRequest::GetNumberUnreadMessages{ room_id: tl.room_id.clone() });
[m[32m+                        submit_async_request(MatrixRequest::GetNumberUnreadMessages {
[m[32m+                            room_id: tl.room_id.clone(),
[m[32m+                        });
[m                     }

                     if prior_items_changed {
Diff in /app/src/home/room_screen.rs:1302:
                         let loading_pane = self.view.loading_pane(ids!(loading_pane));
                         let mut loading_pane_state = loading_pane.take_state();
                         if let LoadingPaneState::BackwardsPaginateUntilEvent {
[31m-                            events_paginated, target_event_id, ..
[m[31m-                        } = &mut loading_pane_state {
[m[32m+                            events_paginated,
[m[32m+                            target_event_id,
[m[32m+                            ..
[m[32m+                        } = &mut loading_pane_state
[m[32m+                        {
[m                             *events_paginated += new_items.len().saturating_sub(tl.items.len());
[31m-                            log!("While finding target event {target_event_id}, we have now loaded {events_paginated} messages...");
[m[32m+                            log!(
[m[32m+                                "While finding target event {target_event_id}, we have now loaded {events_paginated} messages..."
[m[32m+                            );
[m                             // Here, we assume that we have not yet found the target event,
                             // so we need to continue paginating backwards.
                             // If the target event has already been found, it will be handled
Diff in /app/src/home/room_screen.rs:1322:
                         tl.profile_drawn_since_last_update.clear();
                         tl.fully_paginated = false;
                     } else {
[31m-                        tl.content_drawn_since_last_update.remove(changed_indices.clone());
[m[31m-                        tl.profile_drawn_since_last_update.remove(changed_indices.clone());
[m[32m+                        tl.content_drawn_since_last_update
[m[32m+                            .remove(changed_indices.clone());
[m[32m+                        tl.profile_drawn_since_last_update
[m[32m+                            .remove(changed_indices.clone());
[m                         // log!("process_timeline_updates(): changed_indices: {changed_indices:?}, items len: {}\ncontent drawn: {:#?}\nprofile drawn: {:#?}", items.len(), tl.content_drawn_since_last_update, tl.profile_drawn_since_last_update);
                     }
                     tl.items = new_items;
Diff in /app/src/home/room_screen.rs:1332:
                 TimelineUpdate::NewUnreadMessagesCount(unread_messages_count) => {
                     jump_to_bottom.show_unread_message_badge(cx, unread_messages_count);
                 }
[31m-                TimelineUpdate::TargetEventFound { target_event_id, index } => {
[m[32m+                TimelineUpdate::TargetEventFound {
[m[32m+                    target_event_id,
[m[32m+                    index,
[m[32m+                } => {
[m                     // log!("Target event found in room {}: {target_event_id}, index: {index}", tl.room_id);
                     tl.request_sender.send_if_modified(|requests| {
                         requests.retain(|r| r.room_id != tl.room_id);
Diff in /app/src/home/room_screen.rs:1342:

                     // sanity check: ensure the target event is in the timeline at the given `index`.
                     let item = tl.items.get(index);
[31m-                    let is_valid = item.is_some_and(|item|
[m[32m+                    let is_valid = item.is_some_and(|item| {
[m                         item.as_event()
                             .is_some_and(|ev| ev.event_id() == Some(&target_event_id))
[31m-                    );
[m[32m+                    });
[m                     let loading_pane = self.view.loading_pane(ids!(loading_pane));

                     // log!("TargetEventFound: is_valid? {is_valid}. room {}, event {target_event_id}, index {index} of {}\n  --> item: {item:?}", tl.room_id, tl.items.len());
Diff in /app/src/home/room_screen.rs:1364:
                         //       appear beneath the top of the viewport.
                         portal_list.smooth_scroll_to(cx, index.saturating_sub(1), speed, None);
                         // start highlight animation.
[31m-                        tl.message_highlight_animation_state = MessageHighlightAnimationState::Pending {
[m[31m-                            item_id: index
[m[31m-                        };
[m[31m-                    }
[m[31m-                    else {
[m[32m+                        tl.message_highlight_animation_state =
[m[32m+                            MessageHighlightAnimationState::Pending { item_id: index };
[m[32m+                    } else {
[m                         // Here, the target event was not found in the current timeline,
                         // or we found it previously but it is no longer in the timeline (or has moved),
                         // which means we encountered an error and are unable to jump to the target event.
Diff in /app/src/home/room_screen.rs:1375:
[31m-                        error!("Target event index {index} of {} is out of bounds for room {}", tl.items.len(), tl.room_id);
[m[32m+                        error!(
[m[32m+                            "Target event index {index} of {} is out of bounds for room {}",
[m[32m+                            tl.items.len(),
[m[32m+                            tl.room_id
[m[32m+                        );
[m                         // Show this error in the loading pane, which should already be open.
[31m-                        loading_pane.set_state(cx, LoadingPaneState::Error(
[m[31m-                            String::from("Unable to find related message; it may have been deleted.")
[m[31m-                        ));
[m[32m+                        loading_pane.set_state(
[m[32m+                            cx,
[m[32m+                            LoadingPaneState::Error(String::from(
[m[32m+                                "Unable to find related message; it may have been deleted.",
[m[32m+                            )),
[m[32m+                        );
[m                     }

                     should_continue_backwards_pagination = false;
Diff in /app/src/home/room_screen.rs:1393:
                     }
                 }
                 TimelineUpdate::PaginationError { error, direction } => {
[31m-                    error!("Pagination error ({direction}) in {:?}: {error:?}", self.room_name_id);
[m[32m+                    error!(
[m[32m+                        "Pagination error ({direction}) in {:?}: {error:?}",
[m[32m+                        self.room_name_id
[m[32m+                    );
[m                     let room_name = self.room_name_id.as_ref().map(|r| r.to_string());
                     enqueue_popup_notification(
[31m-                        utils::stringify_pagination_error(&error, room_name.as_deref().unwrap_or(UNNAMED_ROOM)),
[m[32m+                        utils::stringify_pagination_error(
[m[32m+                            &error,
[m[32m+                            room_name.as_deref().unwrap_or(UNNAMED_ROOM),
[m[32m+                        ),
[m                         PopupKind::Error,
                         Some(10.0),
                     );
Diff in /app/src/home/room_screen.rs:1403:
                     done_loading = true;
                 }
[31m-                TimelineUpdate::PaginationIdle { fully_paginated, direction } => {
[m[32m+                TimelineUpdate::PaginationIdle {
[m[32m+                    fully_paginated,
[m[32m+                    direction,
[m[32m+                } => {
[m                     if direction == PaginationDirection::Backwards {
                         // Don't set `done_loading` to `true` here, because we want to keep the top space visible
                         // (with the "loading" message) until the corresponding `NewItems` update is received.
Diff in /app/src/home/room_screen.rs:1414:
                         error!("Unexpected PaginationIdle update in the Forwards direction");
                     }
                 }
[31m-                TimelineUpdate::EventDetailsFetched {event_id, result } => {
[m[32m+                TimelineUpdate::EventDetailsFetched { event_id, result } => {
[m                     if let Err(_e) = result {
[31m-                        error!("Failed to fetch details fetched for event {event_id} in room {}. Error: {_e:?}", tl.room_id);
[m[32m+                        error!(
[m[32m+                            "Failed to fetch details fetched for event {event_id} in room {}. Error: {_e:?}",
[m[32m+                            tl.room_id
[m[32m+                        );
[m                     }
                     // Here, to be most efficient, we could redraw only the updated event,
                     // but for now we just fall through and let the final `redraw()` call re-draw the whole timeline view.
Diff in /app/src/home/room_screen.rs:1429:
                 TimelineUpdate::RoomMembersListFetched { members } => {
                     // Store room members directly in TimelineUiState
                     tl.room_members = Some(Arc::new(members));
[31m-                },
[m[32m+                }
[m                 TimelineUpdate::MediaFetched(request) => {
[31m-                    log!("process_timeline_updates(): media fetched for room {}", tl.room_id);
[m[32m+                    log!(
[m[32m+                        "process_timeline_updates(): media fetched for room {}",
[m[32m+                        tl.room_id
[m[32m+                    );
[m                     // Set Image to image viewer modal if the media is not a thumbnail.
                     if let (MediaFormat::File, media_source) = (request.format, request.source) {
                         populate_matrix_image_modal(cx, media_source, &mut tl.media_cache);
Diff in /app/src/home/room_screen.rs:1439:
                     // Here, to be most efficient, we could redraw only the media items in the timeline,
                     // but for now we just fall through and let the final `redraw()` call re-draw the whole timeline view.
                 }
[31m-                TimelineUpdate::MessageEdited { timeline_event_id, result } => {
[m[31m-                    self.view.room_input_bar(ids!(room_input_bar))
[m[32m+                TimelineUpdate::MessageEdited {
[m[32m+                    timeline_event_id,
[m[32m+                    result,
[m[32m+                } => {
[m[32m+                    self.view
[m[32m+                        .room_input_bar(ids!(room_input_bar))
[m                         .handle_edit_result(cx, timeline_event_id, result);
                 }
                 TimelineUpdate::PinResult { result, pin, .. } => {
Diff in /app/src/home/room_screen.rs:1447:
                     let (message, auto_dismissal_duration, kind) = match &result {
                         Ok(true) => (
[31m-                            format!("Successfully {} event.", if pin { "pinned" } else { "unpinned" }),
[m[32m+                            format!(
[m[32m+                                "Successfully {} event.",
[m[32m+                                if pin { "pinned" } else { "unpinned" }
[m[32m+                            ),
[m                             Some(4.0),
[31m-                            PopupKind::Success
[m[32m+                            PopupKind::Success,
[m                         ),
                         Ok(false) => (
[31m-                            format!("Message was already {}.", if pin { "pinned" } else { "unpinned" }),
[m[32m+                            format!(
[m[32m+                                "Message was already {}.",
[m[32m+                                if pin { "pinned" } else { "unpinned" }
[m[32m+                            ),
[m                             Some(4.0),
[31m-                            PopupKind::Info
[m[32m+                            PopupKind::Info,
[m                         ),
                         Err(e) => (
[31m-                            format!("Failed to {} event. Error: {e}", if pin { "pin" } else { "unpin" }),
[m[32m+                            format!(
[m[32m+                                "Failed to {} event. Error: {e}",
[m[32m+                                if pin { "pin" } else { "unpin" }
[m[32m+                            ),
[m                             None,
[31m-                            PopupKind::Error
[m[32m+                            PopupKind::Error,
[m                         ),
                     };
                     enqueue_popup_notification(message, kind, auto_dismissal_duration);
Diff in /app/src/home/room_screen.rs:1482:
                 }
                 TimelineUpdate::UserPowerLevels(user_power_levels) => {
                     tl.user_power = user_power_levels;
[31m-                    self.view.room_input_bar(ids!(room_input_bar))
[m[32m+                    self.view
[m[32m+                        .room_input_bar(ids!(room_input_bar))
[m                         .update_user_power_levels(cx, user_power_levels);
                     // Update the @room mention capability based on the user's power level
                     cx.action(MentionableTextInputAction::PowerLevelsUpdated {
Diff in /app/src/home/room_screen.rs:1498:
                     tl.latest_own_user_receipt = Some(receipt);
                 }
                 TimelineUpdate::Tombstoned(successor_room_details) => {
[31m-                    self.view.room_input_bar(ids!(room_input_bar))
[m[32m+                    self.view
[m[32m+                        .room_input_bar(ids!(room_input_bar))
[m                         .update_tombstone_footer(cx, &tl.room_id, Some(&successor_room_details));
                     tl.tombstone_info = Some(successor_room_details);
                 }
Diff in /app/src/home/room_screen.rs:1530:
         }
     }

[31m-
[m     /// Handles a link being clicked in any child widgets of this RoomScreen.
     ///
     /// Returns `true` if the given `action` was handled as a link click.
Diff in /app/src/home/room_screen.rs:1574:
                     true
                 }
                 MatrixId::Room(room_id) => {
[31m-                    if self.room_name_id.as_ref().is_some_and(|r| r.room_id() == room_id) {
[m[32m+                    if self
[m[32m+                        .room_name_id
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|r| r.room_id() == room_id)
[m[32m+                    {
[m                         enqueue_popup_notification(
                             "You are already viewing that room.",
                             PopupKind::Info,
Diff in /app/src/home/room_screen.rs:1582:
                         );
                         return true;
                     }
[31m-                    if let Some(room_name_id) = cx.get_global::<RoomsListRef>().get_room_name(room_id) {
[m[32m+                    if let Some(room_name_id) =
[m[32m+                        cx.get_global::<RoomsListRef>().get_room_name(room_id)
[m[32m+                    {
[m                         cx.action(AppStateAction::NavigateToRoom {
                             room_to_close: None,
                             destination_room: BasicRoomDetails::Name(room_name_id),
Diff in /app/src/home/room_screen.rs:1616:
             let mut link_was_handled = false;
             if let Ok(matrix_to_uri) = MatrixToUri::parse(&url) {
                 link_was_handled |= handle_matrix_link(matrix_to_uri.id(), matrix_to_uri.via());
[31m-            }
[m[31m-            else if let Ok(matrix_uri) = MatrixUri::parse(&url) {
[m[32m+            } else if let Ok(matrix_uri) = MatrixUri::parse(&url) {
[m                 link_was_handled |= handle_matrix_link(matrix_uri.id(), matrix_uri.via());
             }

Diff in /app/src/home/room_screen.rs:1633:
                 }
             }
             true
[31m-        }
[m[31m-        else if let RobrixHtmlLinkAction::ClickedMatrixLink { url, matrix_id, via, .. } = action.as_widget_action().cast() {
[m[32m+        } else if let RobrixHtmlLinkAction::ClickedMatrixLink {
[m[32m+            url,
[m[32m+            matrix_id,
[m[32m+            via,
[m[32m+            ..
[m[32m+        } = action.as_widget_action().cast()
[m[32m+        {
[m             let link_was_handled = handle_matrix_link(&matrix_id, &via);
             if !link_was_handled {
                 log!("Opening URL \"{}\"", url);
Diff in /app/src/home/room_screen.rs:1648:
                 }
             }
             true
[31m-        }
[m[31m-        else {
[m[32m+        } else {
[m             false
         }
     }
Diff in /app/src/home/room_screen.rs:1665:
         let Some(media_source) = mxc_uri else {
             return;
         };
[31m-        let Some(tl_state) = self.tl_state.as_mut() else { return };
[m[31m-        let Some(event_tl_item) = tl_state.items.get(item_id).and_then(|item| item.as_event()) else { return };
[m[32m+        let Some(tl_state) = self.tl_state.as_mut() else {
[m[32m+            return;
[m[32m+        };
[m[32m+        let Some(event_tl_item) = tl_state.items.get(item_id).and_then(|item| item.as_event())
[m[32m+        else {
[m[32m+            return;
[m[32m+        };
[m
         let timestamp_millis = event_tl_item.timestamp();
         let (image_name, image_file_size) = get_image_name_and_filesize(event_tl_item);
Diff in /app/src/home/room_screen.rs:1676:
                 image_name,
                 image_file_size,
                 timestamp: unix_time_millis_to_datetime(timestamp_millis),
[31m-                avatar_parameter: Some((
[m[31m-                    tl_state.room_id.clone(),
[m[31m-                    event_tl_item.clone(),
[m[31m-                )),
[m[32m+                avatar_parameter: Some((tl_state.room_id.clone(), event_tl_item.clone())),
[m             }),
         )));

Diff in /app/src/home/room_screen.rs:1700:
         details: &MessageDetails,
     ) -> Option<&'a EventTimelineItem> {
         let target_event_id = details.event_id()?;
[31m-        if let Some(event) = items.get(details.item_id)
[m[32m+        if let Some(event) = items
[m[32m+            .get(details.item_id)
[m             .and_then(|item| item.as_event())
             .filter(|ev| ev.event_id().is_some_and(|id| id == target_event_id))
         {
Diff in /app/src/home/room_screen.rs:1707:
             return Some(event);
         }
[31m-        items.iter()
[m[32m+        items
[m[32m+            .iter()
[m             .rev()
             .take(MAX_ITEMS_TO_SEARCH_THROUGH)
             .filter_map(|item| item.as_event())
Diff in /app/src/home/room_screen.rs:1723:
     ) {
         let room_screen_widget_uid = self.widget_uid();
         for action in actions {
[31m-            match action.as_widget_action().widget_uid_eq(room_screen_widget_uid).cast_ref() {
[m[32m+            match action
[m[32m+                .as_widget_action()
[m[32m+                .widget_uid_eq(room_screen_widget_uid)
[m[32m+                .cast_ref()
[m[32m+            {
[m                 MessageAction::React { details, reaction } => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     submit_async_request(MatrixRequest::ToggleReaction {
                         room_id: tl.room_id.clone(),
                         timeline_event_id: details.timeline_event_id.clone(),
Diff in /app/src/home/room_screen.rs:1733:
                     });
                 }
                 MessageAction::Reply(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[31m-                    if let Some(event_tl_item) = Self::find_event_in_timeline(&tl.items, details).cloned() {
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m[32m+                    if let Some(event_tl_item) =
[m[32m+                        Self::find_event_in_timeline(&tl.items, details).cloned()
[m[32m+                    {
[m                         let replied_to_info = EmbeddedEvent::from_timeline_item(&event_tl_item);
[31m-                        self.view.room_input_bar(ids!(room_input_bar))
[m[32m+                        self.view
[m[32m+                            .room_input_bar(ids!(room_input_bar))
[m                             .show_replying_to(cx, (event_tl_item, replied_to_info), &tl.room_id);
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         enqueue_popup_notification(
                             "Could not find message in timeline to reply to. Please try again.",
                             PopupKind::Error,
Diff in /app/src/home/room_screen.rs:1746:
                             Some(5.0),
                         );
[31m-                        error!("MessageAction::Reply: couldn't find event [{}] {:?} to reply to in room {:?}",
[m[32m+                        error!(
[m[32m+                            "MessageAction::Reply: couldn't find event [{}] {:?} to reply to in room {:?}",
[m                             details.item_id,
                             details.timeline_event_id,
                             self.room_id(),
Diff in /app/src/home/room_screen.rs:1753:
                     }
                 }
                 MessageAction::Edit(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     if let Some(event_tl_item) = Self::find_event_in_timeline(&tl.items, details) {
[31m-                        self.view.room_input_bar(ids!(room_input_bar))
[m[32m+                        self.view
[m[32m+                            .room_input_bar(ids!(room_input_bar))
[m                             .show_editing_pane(cx, event_tl_item.clone(), tl.room_id.clone());
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         enqueue_popup_notification(
                             "Could not find message in timeline to edit. Please try again.",
                             PopupKind::Error,
Diff in /app/src/home/room_screen.rs:1765:
                             Some(5.0),
                         );
[31m-                        error!("MessageAction::Edit: couldn't find event [{}] {:?} to edit in room {:?}",
[m[32m+                        error!(
[m[32m+                            "MessageAction::Edit: couldn't find event [{}] {:?} to edit in room {:?}",
[m                             details.item_id,
                             details.timeline_event_id,
                             self.room_id(),
Diff in /app/src/home/room_screen.rs:1772:
                     }
                 }
                 MessageAction::EditLatest => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[31m-                    if let Some(latest_sent_msg) = tl.items
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m[32m+                    if let Some(latest_sent_msg) = tl
[m[32m+                        .items
[m                         .iter()
                         .rev()
                         .take(MAX_ITEMS_TO_SEARCH_THROUGH)
Diff in /app/src/home/room_screen.rs:1780:
                         .find_map(|item| item.as_event().filter(|ev| ev.is_editable()).cloned())
                     {
[31m-                        self.view.room_input_bar(ids!(room_input_bar))
[m[32m+                        self.view
[m[32m+                            .room_input_bar(ids!(room_input_bar))
[m                             .show_editing_pane(cx, latest_sent_msg, tl.room_id.clone());
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         enqueue_popup_notification(
                             "No recent message available to edit. Please manually select a message to edit.",
                             PopupKind::Warning,
Diff in /app/src/home/room_screen.rs:1791:
                     }
                 }
                 MessageAction::Pin(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     if let Some(event_id) = details.event_id() {
                         submit_async_request(MatrixRequest::PinEvent {
                             event_id: event_id.clone(),
Diff in /app/src/home/room_screen.rs:1807:
                     }
                 }
                 MessageAction::Unpin(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     if let Some(event_id) = details.event_id() {
                         submit_async_request(MatrixRequest::PinEvent {
                             event_id: event_id.clone(),
Diff in /app/src/home/room_screen.rs:1823:
                     }
                 }
                 MessageAction::CopyText(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     if let Some(event_tl_item) = Self::find_event_in_timeline(&tl.items, details) {
                         cx.copy_to_clipboard(&plaintext_body_of_timeline_item(event_tl_item));
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         enqueue_popup_notification(
                             "Could not find message in timeline to copy text from. Please try again.",
                             PopupKind::Error,
Diff in /app/src/home/room_screen.rs:1834:
                             Some(5.0),
                         );
[31m-                        error!("MessageAction::CopyText: couldn't find event [{}] {:?} to copy text from in room {}",
[m[31m-                            details.item_id,
[m[31m-                            details.timeline_event_id,
[m[31m-                            tl.room_id,
[m[32m+                        error!(
[m[32m+                            "MessageAction::CopyText: couldn't find event [{}] {:?} to copy text from in room {}",
[m[32m+                            details.item_id, details.timeline_event_id, tl.room_id,
[m                         );
                     }
                 }
Diff in /app/src/home/room_screen.rs:1843:
                 MessageAction::CopyHtml(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     // The logic for getting the formatted body of a message is the same
                     // as the logic used in `populate_message_view()`.
                     let mut success = false;
Diff in /app/src/home/room_screen.rs:1848:
                     if let Some(event_tl_item) = Self::find_event_in_timeline(&tl.items, details) {
                         if let Some(message) = event_tl_item.content().as_message() {
                             match message.msgtype() {
[31m-                                MessageType::Text(TextMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::Notice(NoticeMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::Emote(EmoteMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::Image(ImageMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::File(FileMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::Audio(AudioMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::Video(VideoMessageEventContent { formatted: Some(FormattedBody { body, .. }), .. })
[m[31m-                                | MessageType::VerificationRequest(KeyVerificationRequestEventContent { formatted: Some(FormattedBody { body, .. }), .. }) =>
[m[31m-                                {
[m[32m+                                MessageType::Text(TextMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::Notice(NoticeMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::Emote(EmoteMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::Image(ImageMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::File(FileMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::Audio(AudioMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::Video(VideoMessageEventContent {
[m[32m+                                    formatted: Some(FormattedBody { body, .. }),
[m[32m+                                    ..
[m[32m+                                })
[m[32m+                                | MessageType::VerificationRequest(
[m[32m+                                    KeyVerificationRequestEventContent {
[m[32m+                                        formatted: Some(FormattedBody { body, .. }),
[m[32m+                                        ..
[m[32m+                                    },
[m[32m+                                ) => {
[m                                     cx.copy_to_clipboard(body);
                                     success = true;
                                 }
Diff in /app/src/home/room_screen.rs:1870:
                             PopupKind::Error,
                             Some(5.0),
                         );
[31m-                        error!("MessageAction::CopyHtml: couldn't find event [{}] {:?} to copy HTML from in room {}",
[m[31m-                            details.item_id,
[m[31m-                            details.timeline_event_id,
[m[31m-                            tl.room_id,
[m[32m+                        error!(
[m[32m+                            "MessageAction::CopyHtml: couldn't find event [{}] {:?} to copy HTML from in room {}",
[m[32m+                            details.item_id, details.timeline_event_id, tl.room_id,
[m                         );
                     }
                 }
Diff in /app/src/home/room_screen.rs:1880:
                 MessageAction::CopyLink(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     if let Some(event_id) = details.event_id() {
                         let matrix_to_uri = tl.room_id.matrix_to_event_uri(event_id.clone());
                         cx.copy_to_clipboard(&matrix_to_uri.to_string());
Diff in /app/src/home/room_screen.rs:1888:
                             PopupKind::Error,
                             Some(5.0),
                         );
[31m-                        error!("MessageAction::CopyLink: no `event_id`: [{}] {:?} in room {}",
[m[31m-                            details.item_id,
[m[31m-                            details.timeline_event_id,
[m[31m-                            tl.room_id,
[m[32m+                        error!(
[m[32m+                            "MessageAction::CopyLink: no `event_id`: [{}] {:?} in room {}",
[m[32m+                            details.item_id, details.timeline_event_id, tl.room_id,
[m                         );
                     }
                 }
Diff in /app/src/home/room_screen.rs:1898:
                 MessageAction::ViewSource(details) => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { continue };
[m[31m-                    let Some(event_tl_item) = Self::find_event_in_timeline(&tl.items, details) else {
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        continue;
[m[32m+                    };
[m[32m+                    let Some(event_tl_item) = Self::find_event_in_timeline(&tl.items, details)
[m[32m+                    else {
[m                         enqueue_popup_notification(
                             "Could not find message in timeline to view source.",
                             PopupKind::Error,
Diff in /app/src/home/room_screen.rs:1921:
                 }
                 MessageAction::JumpToRelated(details) => {
                     let Some(related_event_id) = details.related_event_id.as_ref() else {
[31m-                        error!("BUG: MessageAction::JumpToRelated had no related event ID.\n{details:#?}");
[m[32m+                        error!(
[m[32m+                            "BUG: MessageAction::JumpToRelated had no related event ID.\n{details:#?}"
[m[32m+                        );
[m                         enqueue_popup_notification(
                             "Could not find related message or event in timeline.",
                             PopupKind::Error,
Diff in /app/src/home/room_screen.rs:1934:
                         related_event_id,
                         Some(details.item_id),
                         portal_list,
[31m-                        loading_pane
[m[32m+                        loading_pane,
[m                     );
                 }
                 MessageAction::JumpToEvent(event_id) => {
Diff in /app/src/home/room_screen.rs:1941:
[31m-                    self.jump_to_event(
[m[31m-                        cx,
[m[31m-                        event_id,
[m[31m-                        None,
[m[31m-                        portal_list,
[m[31m-                        loading_pane
[m[31m-                    );
[m[32m+                    self.jump_to_event(cx, event_id, None, portal_list, loading_pane);
[m                 }
                 MessageAction::Redact { details, reason } => {
[31m-                    let Some(tl) = self.tl_state.as_ref() else { return };
[m[32m+                    let Some(tl) = self.tl_state.as_ref() else {
[m[32m+                        return;
[m[32m+                    };
[m                     let timeline_event_id = details.timeline_event_id.clone();
                     let room_id = tl.room_id.clone();
                     let reason = reason.clone();
Diff in /app/src/home/room_screen.rs:1954:
                     let content = ConfirmationModalContent {
                         title_text: "Delete Message".into(),
[31m-                        body_text: "Are you sure you want to delete this message? This cannot be undone.".into(),
[m[32m+                        body_text:
[m[32m+                            "Are you sure you want to delete this message? This cannot be undone."
[m[32m+                                .into(),
[m                         accept_button_text: Some("Delete".into()),
                         on_accept_clicked: Some(Box::new(move |_cx| {
                             submit_async_request(MatrixRequest::RedactMessage {
Diff in /app/src/home/room_screen.rs:1971:
                 // }

                 // This is handled within the Message widget itself.
[31m-                MessageAction::HighlightMessage(..) => { }
[m[32m+                MessageAction::HighlightMessage(..) => {}
[m                 // This is handled by the top-level App itself.
[31m-                MessageAction::OpenMessageContextMenu { .. } => { }
[m[32m+                MessageAction::OpenMessageContextMenu { .. } => {}
[m                 // This isn't yet handled, as we need to completely redesign it.
[31m-                MessageAction::ActionBarOpen { .. } => { }
[m[32m+                MessageAction::ActionBarOpen { .. } => {}
[m                 // This isn't yet handled, as we need to completely redesign it.
[31m-                MessageAction::ActionBarClose => { }
[m[31m-                MessageAction::None => { }
[m[32m+                MessageAction::ActionBarClose => {}
[m[32m+                MessageAction::None => {}
[m             }
         }
     }
Diff in /app/src/home/room_screen.rs:1996:
         portal_list: &PortalListRef,
         loading_pane: &LoadingPaneRef,
     ) {
[31m-        let Some(tl) = self.tl_state.as_mut() else { return };
[m[32m+        let Some(tl) = self.tl_state.as_mut() else {
[m[32m+            return;
[m[32m+        };
[m         let max_tl_idx = max_tl_idx.unwrap_or_else(|| tl.items.len());

         // Attempt to find the index of replied-to message in the timeline.
Diff in /app/src/home/room_screen.rs:2003:
         // Start from the current item's index (`tl_idx`) and search backwards,
         // since we know the related message must come before the current item.
         let mut num_items_searched = 0;
[31m-        let related_msg_tl_index = tl.items
[m[32m+        let related_msg_tl_index = tl
[m[32m+            .items
[m             .focus()
             .narrow(..max_tl_idx)
             .into_iter()
Diff in /app/src/home/room_screen.rs:2026:
             //       appear beneath the top of the viewport.
             portal_list.smooth_scroll_to(cx, index.saturating_sub(1), speed, None);
             // start highlight animation.
[31m-            tl.message_highlight_animation_state = MessageHighlightAnimationState::Pending {
[m[31m-                item_id: index
[m[31m-            };
[m[32m+            tl.message_highlight_animation_state =
[m[32m+                MessageHighlightAnimationState::Pending { item_id: index };
[m         } else {
[31m-            log!("The related event {target_event_id} wasn't immediately available in room {}, searching for it in the background...", tl.room_id);
[m[32m+            log!(
[m[32m+                "The related event {target_event_id} wasn't immediately available in room {}, searching for it in the background...",
[m[32m+                tl.room_id
[m[32m+            );
[m             // Here, we set the state of the loading pane and display it to the user.
             // The main logic will be handled in `process_timeline_updates()`, which is the only
             // place where we can receive updates to the timeline from the background tasks.
Diff in /app/src/home/room_screen.rs:2094:
         } else {
             let Some(timeline_endpoints) = take_timeline_endpoints(&room_id) else {
                 if !self.is_loaded && self.all_rooms_loaded {
[31m-                    panic!("BUG: timeline is not loaded, but room_id {:?} \
[m[31m-                    was not waiting for its timeline to be loaded.", room_id);
[m[32m+                    panic!(
[m[32m+                        "BUG: timeline is not loaded, but room_id {:?} \
[m[32m+                    was not waiting for its timeline to be loaded.",
[m[32m+                        room_id
[m[32m+                    );
[m                 }
                 return;
             };
Diff in /app/src/home/room_screen.rs:2168:
             self.is_loaded = is_loaded_now;
         }

[31m-        self.view.restore_status_view(ids!(restore_status_view)).set_visible(cx, !self.is_loaded);
[m[32m+        self.view
[m[32m+            .restore_status_view(ids!(restore_status_view))
[m[32m+            .set_visible(cx, !self.is_loaded);
[m
         // Kick off a back pagination request if it's the first time loading this room,
         // because we want to show the user some messages as soon as possible
Diff in /app/src/home/room_screen.rs:2175:
         // when they first open the room, and there might not be any messages yet.
         if is_first_time_being_loaded {
             if !tl_state.fully_paginated {
[31m-                log!("Sending a first-time backwards pagination request for room {:?}", self.room_name_id);
[m[32m+                log!(
[m[32m+                    "Sending a first-time backwards pagination request for room {:?}",
[m[32m+                    self.room_name_id
[m[32m+                );
[m                 submit_async_request(MatrixRequest::PaginateRoomTimeline {
                     room_id: room_id.clone(),
                     num_events: 50,
Diff in /app/src/home/room_screen.rs:2186:
             // Even though we specify that room member profiles should be lazy-loaded,
             // the matrix server still doesn't consistently send them to our client properly.
             // So we kick off a request to fetch the room members here upon first viewing the room.
[31m-            submit_async_request(MatrixRequest::SyncRoomMemberList { room_id: room_id.clone() });
[m[32m+            submit_async_request(MatrixRequest::SyncRoomMemberList {
[m[32m+                room_id: room_id.clone(),
[m[32m+            });
[m         }

         // Hide the typing notice view initially.
Diff in /app/src/home/room_screen.rs:2239:

     /// Invoke this when this RoomScreen/timeline is being hidden or no longer being shown.
     fn hide_timeline(&mut self) {
[31m-        let Some(room_id) = self.room_id().cloned() else { return };
[m[32m+        let Some(room_id) = self.room_id().cloned() else {
[m[32m+            return;
[m[32m+        };
[m
         self.save_state();

Diff in /app/src/home/room_screen.rs:2268:
     /// Note: after calling this function, the widget's `tl_state` will be `None`.
     fn save_state(&mut self) {
         let Some(mut tl) = self.tl_state.take() else {
[31m-            error!("Timeline::save_state(): skipping due to missing state, room {:?}", self.room_name_id);
[m[32m+            error!(
[m[32m+                "Timeline::save_state(): skipping due to missing state, room {:?}",
[m[32m+                self.room_name_id
[m[32m+            );
[m             return;
         };

Diff in /app/src/home/room_screen.rs:2316:
     }

     /// Sets this `RoomScreen` widget to display the timeline for the given room.
[31m-    pub fn set_displayed_room(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        room_name_id: &RoomNameId,
[m[31m-    ) {
[m[32m+    pub fn set_displayed_room(&mut self, cx: &mut Cx, room_name_id: &RoomNameId) {
[m         // If the room is already being displayed, then do nothing.
[31m-        if self.room_name_id.as_ref().is_some_and(|rn| rn.room_id() == room_name_id.room_id()) { return; }
[m[32m+        if self
[m[32m+            .room_name_id
[m[32m+            .as_ref()
[m[32m+            .is_some_and(|rn| rn.room_id() == room_name_id.room_id())
[m[32m+        {
[m[32m+            return;
[m[32m+        }
[m
         self.hide_timeline();
         // Reset the the state of the inner loading pane.
Diff in /app/src/home/room_screen.rs:2354:
             return;
         }
         let first_index = portal_list.first_id();
[31m-        let Some(tl_state) = self.tl_state.as_mut() else { return };
[m[32m+        let Some(tl_state) = self.tl_state.as_mut() else {
[m[32m+            return;
[m[32m+        };
[m
         if let Some(ref mut index) = tl_state.prev_first_index {
             // to detect change of scroll when scroll ends
Diff in /app/src/home/room_screen.rs:2365:
                         .items
                         .get(std::cmp::min(
                             first_index + portal_list.visible_items(),
[31m-                            tl_state.items.len().saturating_sub(1)
[m[32m+                            tl_state.items.len().saturating_sub(1),
[m                         ))
                         .and_then(|f| f.as_event())
                         .and_then(|f| f.event_id().map(|e| (e, f.timestamp())))
Diff in /app/src/home/room_screen.rs:2383:
                             event_id: last_event_id.to_owned(),
                         });
                     } else {
[31m-                        if let Some(own_user_receipt_timestamp) = &tl_state.latest_own_user_receipt.clone()
[m[31m-                        .and_then(|receipt| receipt.ts) {
[m[32m+                        if let Some(own_user_receipt_timestamp) = &tl_state
[m[32m+                            .latest_own_user_receipt
[m[32m+                            .clone()
[m[32m+                            .and_then(|receipt| receipt.ts)
[m[32m+                        {
[m                             let Some((_first_event_id, first_timestamp)) = tl_state
                                 .items
                                 .get(first_index)
Diff in /app/src/home/room_screen.rs:2391:
                                 .and_then(|f| f.as_event())
                                 .and_then(|f| f.event_id().map(|e| (e, f.timestamp())))
[31m-                                else {
[m[31m-                                    *index = first_index;
[m[31m-                                    return;
[m[31m-                                };
[m[32m+                            else {
[m[32m+                                *index = first_index;
[m[32m+                                return;
[m[32m+                            };
[m                             if own_user_receipt_timestamp >= &first_timestamp
                                 && own_user_receipt_timestamp <= &last_timestamp
                             {
Diff in /app/src/home/room_screen.rs:2403:
                                     event_id: last_event_id.to_owned(),
                                 });
                             }
[31m-
[m                         }
                     }
                 }
Diff in /app/src/home/room_screen.rs:2422:
         actions: &ActionsBuf,
         portal_list: &PortalListRef,
     ) {
[31m-        let Some(tl) = self.tl_state.as_mut() else { return };
[m[31m-        if tl.fully_paginated { return };
[m[31m-        if !portal_list.scrolled(actions) { return };
[m[32m+        let Some(tl) = self.tl_state.as_mut() else {
[m[32m+            return;
[m[32m+        };
[m[32m+        if tl.fully_paginated {
[m[32m+            return;
[m[32m+        };
[m[32m+        if !portal_list.scrolled(actions) {
[m[32m+            return;
[m[32m+        };
[m
         let first_index = portal_list.first_id();
         if first_index == 0 && tl.last_scrolled_index > 0 {
Diff in /app/src/home/room_screen.rs:2431:
[31m-            log!("Scrolled up from item {} --> 0, sending back pagination request for room {}",
[m[31m-                tl.last_scrolled_index, tl.room_id,
[m[32m+            log!(
[m[32m+                "Scrolled up from item {} --> 0, sending back pagination request for room {}",
[m[32m+                tl.last_scrolled_index,
[m[32m+                tl.room_id,
[m             );
             submit_async_request(MatrixRequest::PaginateRoomTimeline {
                 room_id: tl.room_id.clone(),
Diff in /app/src/home/room_screen.rs:2443:

 impl RoomScreenRef {
     /// See [`RoomScreen::set_displayed_room()`].
[31m-    pub fn set_displayed_room(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        room_name_id: &RoomNameId,
[m[31m-    ) {
[m[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+    pub fn set_displayed_room(&self, cx: &mut Cx, room_name_id: &RoomNameId) {
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_displayed_room(cx, room_name_id);
     }
 }
Diff in /app/src/home/room_screen.rs:2462:
     pub room_avatar_url: Option<OwnedMxcUri>,
 }

[31m-
[m /// Actions for the room screen's tooltip.
 #[derive(Clone, Debug, DefaultNone)]
 pub enum RoomScreenTooltipActions {
Diff in /app/src/home/room_screen.rs:2553:
     /// includes a complete list of room members that can be shared across components.
     /// This is different from RoomMembersSynced which only indicates members were fetched
     /// but doesn't provide the actual data.
[31m-    RoomMembersListFetched {
[m[31m-        members: Vec<RoomMember>,
[m[31m-    },
[m[32m+    RoomMembersListFetched { members: Vec<RoomMember> },
[m     /// A notice with an option of Media Request Parameters that one or more requested media items (images, videos, etc.)
     /// that should be displayed in this timeline have now been fetched and are available.
     MediaFetched(MediaRequestParameters),
Diff in /app/src/home/room_screen.rs:2700:

 #[derive(Default, Debug)]
 enum MessageHighlightAnimationState {
[31m-    Pending { item_id: usize },
[m[32m+    Pending {
[m[32m+        item_id: usize,
[m[32m+    },
[m     #[default]
     Off,
 }
Diff in /app/src/home/room_screen.rs:2737:
 ) -> Option<(usize, usize, f64, OwnedEventId)> {
     let mut curr_item_focus = curr_items.focus();
     let mut idx_curr = starting_at_curr_idx;
[31m-    let mut curr_items_with_ids: Vec<(usize, OwnedEventId)> = Vec::with_capacity(
[m[31m-        portal_list.visible_items()
[m[31m-    );
[m[32m+    let mut curr_items_with_ids: Vec<(usize, OwnedEventId)> =
[m[32m+        Vec::with_capacity(portal_list.visible_items());
[m
     // Find all items with real event IDs that are currently visible in the portal list.
     // TODO: if this is slow, we could limit it to 3-5 events at the most.
Diff in /app/src/home/room_screen.rs:2768:
             // some may be zeroed-out, so we need to account for that possibility by only
             // using events that have a real non-zero area
             if let Some(pos_offset) = portal_list.position_of_item(cx, *idx_curr) {
[31m-                log!("Found matching event ID {event_id} at index {idx_new} in new items list, corresponding to current item index {idx_curr} at pos offset {pos_offset}");
[m[32m+                log!(
[m[32m+                    "Found matching event ID {event_id} at index {idx_new} in new items list, corresponding to current item index {idx_curr} at pos offset {pos_offset}"
[m[32m+                );
[m                 return Some((*idx_curr, idx_new, pos_offset, event_id.to_owned()));
             }
         }
Diff in /app/src/home/room_screen.rs:2834:
             TimelineItemContent::MsgLike(_msg_like_content) => {
                 let prev_msg_sender = prev_event_tl_item.sender();
                 prev_msg_sender == event_tl_item.sender()
[31m-                    && ts_millis.0
[m[32m+                    && ts_millis
[m[32m+                        .0
[m                         .checked_sub(prev_event_tl_item.timestamp().0)
                         .is_some_and(|d| d < uint!(600000)) // 10 mins in millis
             }
Diff in /app/src/home/room_screen.rs:2851:
     let (item, used_cached_item) = match &msg_like_content.kind {
         MsgLikeKind::Message(msg) => {
             match msg.msgtype() {
[31m-                MessageType::Text(TextMessageEventContent { body, formatted, .. }) => {
[m[31m-                    has_html_body = formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                MessageType::Text(TextMessageEventContent {
[m[32m+                    body, formatted, ..
[m[32m+                }) => {
[m[32m+                    has_html_body = formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = if use_compact_view {
                         id!(CondensedMessage)
                     } else {
Diff in /app/src/home/room_screen.rs:2876:
                 }
                 // A notice message is just a message sent by an automated bot,
                 // so we treat it just like a message but use a different font color.
[31m-                MessageType::Notice(NoticeMessageEventContent{body, formatted, ..}) => {
[m[32m+                MessageType::Notice(NoticeMessageEventContent {
[m[32m+                    body, formatted, ..
[m[32m+                }) => {
[m                     is_notice = true;
[31m-                    has_html_body = formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                    has_html_body = formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = if use_compact_view {
                         id!(CondensedMessage)
                     } else {
Diff in /app/src/home/room_screen.rs:2889:
                         (item, true)
                     } else {
                         let html_or_plaintext_ref = item.html_or_plaintext(ids!(content.message));
[31m-                        html_or_plaintext_ref.apply_over(cx, live!(
[m[31m-                            html_view = {
[m[31m-                                html = {
[m[31m-                                    font_color: (COLOR_MESSAGE_NOTICE_TEXT),
[m[31m-                                    draw_normal:      { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[31m-                                    draw_italic:      { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[31m-                                    draw_bold:        { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[31m-                                    draw_bold_italic: { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[32m+                        html_or_plaintext_ref.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                html_view = {
[m[32m+                                    html = {
[m[32m+                                        font_color: (COLOR_MESSAGE_NOTICE_TEXT),
[m[32m+                                        draw_normal:      { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[32m+                                        draw_italic:      { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[32m+                                        draw_bold:        { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[32m+                                        draw_bold_italic: { color: (COLOR_MESSAGE_NOTICE_TEXT), }
[m[32m+                                    }
[m                                 }
[31m-                            }
[m[31m-                        ));
[m[32m+                            ),
[m[32m+                        );
[m                         new_drawn_status.content_drawn = populate_text_message_content(
                             cx,
                             &html_or_plaintext_ref,
Diff in /app/src/home/room_screen.rs:2920:
                         (item, true)
                     } else {
                         let html_or_plaintext_ref = item.html_or_plaintext(ids!(content.message));
[31m-                        html_or_plaintext_ref.apply_over(cx, live!(
[m[31m-                            html_view = {
[m[31m-                                html = {
[m[31m-                                    font_color: (COLOR_FG_DANGER_RED),
[m[31m-                                    draw_normal:      { color: (COLOR_FG_DANGER_RED), }
[m[31m-                                    draw_italic:      { color: (COLOR_FG_DANGER_RED), }
[m[31m-                                    draw_bold:        { color: (COLOR_FG_DANGER_RED), }
[m[31m-                                    draw_bold_italic: { color: (COLOR_FG_DANGER_RED), }
[m[32m+                        html_or_plaintext_ref.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                html_view = {
[m[32m+                                    html = {
[m[32m+                                        font_color: (COLOR_FG_DANGER_RED),
[m[32m+                                        draw_normal:      { color: (COLOR_FG_DANGER_RED), }
[m[32m+                                        draw_italic:      { color: (COLOR_FG_DANGER_RED), }
[m[32m+                                        draw_bold:        { color: (COLOR_FG_DANGER_RED), }
[m[32m+                                        draw_bold_italic: { color: (COLOR_FG_DANGER_RED), }
[m[32m+                                    }
[m                                 }
[31m-                            }
[m[31m-                        ));
[m[32m+                            ),
[m[32m+                        );
[m                         let formatted = format!(
                             "<b>Server notice:</b> {}\n\n<i>Notice type:</i>: {}{}{}",
                             sn.body,
Diff in /app/src/home/room_screen.rs:2937:
                             sn.server_notice_type.as_str(),
[31m-                            sn.limit_type.as_ref()
[m[32m+                            sn.limit_type
[m[32m+                                .as_ref()
[m                                 .map(|l| format!("\n<i>Limit type:</i> {}", l.as_str()))
                                 .unwrap_or_default(),
[31m-                            sn.admin_contact.as_ref()
[m[32m+                            sn.admin_contact
[m[32m+                                .as_ref()
[m                                 .map(|c| format!("\n<i>Admin contact:</i> {}", c))
                                 .unwrap_or_default(),
                         );
Diff in /app/src/home/room_screen.rs:2959:
                 }
                 // An emote is just like a message but is prepended with the user's name
                 // to indicate that it's an "action" that the user is performing.
[31m-                MessageType::Emote(EmoteMessageEventContent { body, formatted, .. }) => {
[m[31m-                    has_html_body = formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                MessageType::Emote(EmoteMessageEventContent {
[m[32m+                    body, formatted, ..
[m[32m+                }) => {
[m[32m+                    has_html_body = formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = if use_compact_view {
                         id!(CondensedMessage)
                     } else {
Diff in /app/src/home/room_screen.rs:2971:
                         (item, true)
                     } else {
                         // Draw the profile up front here because we need the username for the emote body.
[31m-                        let (username, profile_drawn) = item.avatar(ids!(profile.avatar)).set_avatar_and_get_username(
[m[31m-                            cx,
[m[31m-                            room_id,
[m[31m-                            event_tl_item.sender(),
[m[31m-                            Some(event_tl_item.sender_profile()),
[m[31m-                            event_tl_item.event_id(),
[m[31m-                            true,
[m[31m-                        );
[m[32m+                        let (username, profile_drawn) = item
[m[32m+                            .avatar(ids!(profile.avatar))
[m[32m+                            .set_avatar_and_get_username(
[m[32m+                                cx,
[m[32m+                                room_id,
[m[32m+                                event_tl_item.sender(),
[m[32m+                                Some(event_tl_item.sender_profile()),
[m[32m+                                event_tl_item.event_id(),
[m[32m+                                true,
[m[32m+                            );
[m
                         // Prepend a "* <username> " to the emote body, as suggested by the Matrix spec.
                         let (body, formatted) = if let Some(fb) = formatted.as_ref() {
Diff in /app/src/home/room_screen.rs:2987:
                                 Some(FormattedBody {
                                     format: fb.format.clone(),
                                     body: format!("* {} {}", &username, &fb.body),
[31m-                                })
[m[32m+                                }),
[m                             )
                         } else {
                             (Cow::from(format!("* {} {}", &username, body)), None)
Diff in /app/src/home/room_screen.rs:3007:
                     }
                 }
                 MessageType::Image(image) => {
[31m-                    has_html_body = image.formatted.as_ref()
[m[32m+                    has_html_body = image
[m[32m+                        .formatted
[m[32m+                        .as_ref()
[m                         .is_some_and(|f| f.format == MessageFormat::Html);
                     let template = if use_compact_view {
                         id!(CondensedImageMessage)
Diff in /app/src/home/room_screen.rs:3052:
                     }
                 }
                 MessageType::File(file_content) => {
[31m-                    has_html_body = file_content.formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                    has_html_body = file_content
[m[32m+                        .formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = if use_compact_view {
                         id!(CondensedMessage)
                     } else {
Diff in /app/src/home/room_screen.rs:3071:
                     }
                 }
                 MessageType::Audio(audio) => {
[31m-                    has_html_body = audio.formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                    has_html_body = audio
[m[32m+                        .formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = if use_compact_view {
                         id!(CondensedMessage)
                     } else {
Diff in /app/src/home/room_screen.rs:3090:
                     }
                 }
                 MessageType::Video(video) => {
[31m-                    has_html_body = video.formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                    has_html_body = video
[m[32m+                        .formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = if use_compact_view {
                         id!(CondensedMessage)
                     } else {
Diff in /app/src/home/room_screen.rs:3109:
                     }
                 }
                 MessageType::VerificationRequest(verification) => {
[31m-                    has_html_body = verification.formatted.as_ref().is_some_and(|f| f.format == MessageFormat::Html);
[m[32m+                    has_html_body = verification
[m[32m+                        .formatted
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|f| f.format == MessageFormat::Html);
[m                     let template = id!(Message);
                     let (item, existed) = list.item_with_existed(cx, item_id, template);
                     if existed && item_drawn_status.content_drawn {
Diff in /app/src/home/room_screen.rs:3121:
                             body: format!(
                                 "<i>Sent a <b>verification request</b> to {}.<br>(Supported methods: {})</i>",
                                 verification.to,
[31m-                                verification.methods
[m[32m+                                verification
[m[32m+                                    .methods
[m                                     .iter()
                                     .map(|m| m.as_str())
                                     .collect::<Vec<_>>()
Diff in /app/src/home/room_screen.rs:3147:
                     if existed && item_drawn_status.content_drawn {
                         (item, true)
                     } else {
[31m-                        item.label(ids!(content.message)).set_text(
[m[31m-                            cx,
[m[31m-                            &format!("[Unsupported {:?}]", msg_like_content.kind),
[m[31m-                        );
[m[32m+                        item.label(ids!(content.message))
[m[32m+                            .set_text(cx, &format!("[Unsupported {:?}]", msg_like_content.kind));
[m                         new_drawn_status.content_drawn = true;
                         (item, false)
                     }
Diff in /app/src/home/room_screen.rs:3160:
         // Handle sticker messages that are static images.
         MsgLikeKind::Sticker(sticker) => {
             has_html_body = false;
[31m-            let StickerEventContent { body, info, source, .. } = sticker.content();
[m[32m+            let StickerEventContent {
[m[32m+                body, info, source, ..
[m[32m+            } = sticker.content();
[m
             let template = if use_compact_view {
                 id!(CondensedImageMessage)
Diff in /app/src/home/room_screen.rs:3188:
                     (item, true)
                 }
             }
[31m-        }
[m[32m+        }
[m         // Handle messages that have been redacted (deleted).
         MsgLikeKind::Redacted => {
             has_html_body = false;
Diff in /app/src/home/room_screen.rs:3202:
                 (item, true)
             } else {
                 let html_or_plaintext_ref = item.html_or_plaintext(ids!(content.message));
[31m-                html_or_plaintext_ref.apply_over(cx, live!{
[m[31m-                    html_view = { html = {
[m[31m-                        font_size: (REDACTED_MESSAGE_FONT_SIZE),
[m[31m-                        draw_normal: { text_style: { font_size: (REDACTED_MESSAGE_FONT_SIZE)} }
[m[31m-                        draw_italic: { text_style: { font_size: (REDACTED_MESSAGE_FONT_SIZE)} }
[m[31m-                    } }
[m[31m-                });
[m[32m+                html_or_plaintext_ref.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        html_view = { html = {
[m[32m+                            font_size: (REDACTED_MESSAGE_FONT_SIZE),
[m[32m+                            draw_normal: { text_style: { font_size: (REDACTED_MESSAGE_FONT_SIZE)} }
[m[32m+                            draw_italic: { text_style: { font_size: (REDACTED_MESSAGE_FONT_SIZE)} }
[m[32m+                        } }
[m[32m+                    },
[m[32m+                );
[m                 new_drawn_status.content_drawn = populate_redacted_message_content(
                     cx,
                     &html_or_plaintext_ref,
Diff in /app/src/home/room_screen.rs:3224:
             if existed && item_drawn_status.content_drawn {
                 (item, true)
             } else {
[31m-                item.label(ids!(content.message)).set_text(
[m[31m-                    cx,
[m[31m-                    &format!("[Unsupported {:?}] ", other),
[m[31m-                );
[m[32m+                item.label(ids!(content.message))
[m[32m+                    .set_text(cx, &format!("[Unsupported {:?}] ", other));
[m                 new_drawn_status.content_drawn = true;
                 (item, false)
             }
Diff in /app/src/home/room_screen.rs:3287:
         // log!("\t --> populate_message_view(): DRAWING  profile draw for item_id: {item_id}");
         let username_label = item.label(ids!(content.username));

[31m-        if !is_server_notice { // the normal case
[m[31m-            let (username, profile_drawn) = set_username_and_get_avatar_retval.unwrap_or_else(||
[m[31m-                item.avatar(ids!(profile.avatar)).set_avatar_and_get_username(
[m[31m-                    cx,
[m[31m-                    room_id,
[m[31m-                    event_tl_item.sender(),
[m[31m-                    Some(event_tl_item.sender_profile()),
[m[31m-                    event_tl_item.event_id(),
[m[31m-                    true,
[m[31m-                )
[m[31m-            );
[m[32m+        if !is_server_notice {
[m[32m+            // the normal case
[m[32m+            let (username, profile_drawn) =
[m[32m+                set_username_and_get_avatar_retval.unwrap_or_else(|| {
[m[32m+                    item.avatar(ids!(profile.avatar))
[m[32m+                        .set_avatar_and_get_username(
[m[32m+                            cx,
[m[32m+                            room_id,
[m[32m+                            event_tl_item.sender(),
[m[32m+                            Some(event_tl_item.sender_profile()),
[m[32m+                            event_tl_item.event_id(),
[m[32m+                            true,
[m[32m+                        )
[m[32m+                });
[m             if is_notice {
[31m-                username_label.apply_over(cx, live!(
[m[31m-                    draw_text: {
[m[31m-                        color: (COLOR_MESSAGE_NOTICE_TEXT),
[m[31m-                    }
[m[31m-                ));
[m[32m+                username_label.apply_over(
[m[32m+                    cx,
[m[32m+                    live!(
[m[32m+                        draw_text: {
[m[32m+                            color: (COLOR_MESSAGE_NOTICE_TEXT),
[m[32m+                        }
[m[32m+                    ),
[m[32m+                );
[m             }
             username_label.set_text(cx, &username);
             new_drawn_status.profile_drawn = profile_drawn;
Diff in /app/src/home/room_screen.rs:3310:
[31m-        }
[m[31m-        else {
[m[32m+        } else {
[m             // Server notices are drawn with a red color avatar background and username.
             let avatar = item.avatar(ids!(profile.avatar));
             avatar.show_text(cx, Some(COLOR_FG_DANGER_RED), None, "⚠");
Diff in /app/src/home/room_screen.rs:3315:
             username_label.set_text(cx, "Server notice");
[31m-            username_label.apply_over(cx, live!(
[m[31m-                draw_text: {
[m[31m-                    color: (COLOR_FG_DANGER_RED),
[m[31m-                }
[m[31m-            ));
[m[32m+            username_label.apply_over(
[m[32m+                cx,
[m[32m+                live!(
[m[32m+                    draw_text: {
[m[32m+                        color: (COLOR_FG_DANGER_RED),
[m[32m+                    }
[m[32m+                ),
[m[32m+            );
[m             new_drawn_status.profile_drawn = true;
         }
     }
Diff in /app/src/home/room_screen.rs:3329:

     // Set the timestamp.
     if let Some(dt) = unix_time_millis_to_datetime(ts_millis) {
[31m-        item.timestamp(ids!(profile.timestamp)).set_date_time(cx, dt);
[m[32m+        item.timestamp(ids!(profile.timestamp))
[m[32m+            .set_date_time(cx, dt);
[m     }

     // Set the "edited" indicator if this message was edited.
Diff in /app/src/home/room_screen.rs:3336:
     if msg_like_content.as_message().is_some_and(|m| m.is_edited()) {
[31m-        item.edited_indicator(ids!(profile.edited_indicator)).set_latest_edit(
[m[31m-            cx,
[m[31m-            event_tl_item,
[m[31m-        );
[m[32m+        item.edited_indicator(ids!(profile.edited_indicator))
[m[32m+            .set_latest_edit(cx, event_tl_item);
[m     }

[31m-    #[cfg(feature = "tsp")] {
[m[32m+    #[cfg(feature = "tsp")]
[m[32m+    {
[m         use matrix_sdk::ruma::serde::Base64;
[31m-        use crate::tsp::{self, tsp_sign_indicator::{TspSignState, TspSignIndicatorWidgetRefExt}};
[m[32m+        use crate::tsp::{
[m[32m+            self,
[m[32m+            tsp_sign_indicator::{TspSignState, TspSignIndicatorWidgetRefExt},
[m[32m+        };
[m
[31m-        if let Some(mut tsp_sig) = event_tl_item.latest_json()
[m[32m+        if let Some(mut tsp_sig) = event_tl_item
[m[32m+            .latest_json()
[m             .and_then(|raw| raw.get_field::<serde_json::Value>("content").ok())
             .flatten()
             .and_then(|content_obj| content_obj.get("org.robius.tsp_signature").cloned())
Diff in /app/src/home/room_screen.rs:3351:
             .and_then(|tsp_sig_value| serde_json::from_value::<Base64>(tsp_sig_value).ok())
             .map(|b64| b64.into_inner())
         {
[31m-            log!("Found event {:?} with TSP signature.", event_tl_item.event_id());
[m[31m-            let tsp_sign_state = if let Some(sender_vid) = tsp::tsp_state_ref().lock().unwrap()
[m[32m+            log!(
[m[32m+                "Found event {:?} with TSP signature.",
[m[32m+                event_tl_item.event_id()
[m[32m+            );
[m[32m+            let tsp_sign_state = if let Some(sender_vid) = tsp::tsp_state_ref()
[m[32m+                .lock()
[m[32m+                .unwrap()
[m                 .get_verified_vid_for(event_tl_item.sender())
             {
[31m-                log!("Found verified VID for sender {}: \"{}\"", event_tl_item.sender(), sender_vid.identifier());
[m[32m+                log!(
[m[32m+                    "Found verified VID for sender {}: \"{}\"",
[m[32m+                    event_tl_item.sender(),
[m[32m+                    sender_vid.identifier()
[m[32m+                );
[m                 tsp_sdk::crypto::verify(&*sender_vid, &mut tsp_sig).map_or(
                     TspSignState::WrongSignature,
                     |(msg, msg_type)| {
Diff in /app/src/home/room_screen.rs:3367:
                 TspSignState::Unknown
             };

[31m-            log!("TSP signature state for event {:?} is {:?}", event_tl_item.event_id(), tsp_sign_state);
[m[32m+            log!(
[m[32m+                "TSP signature state for event {:?} is {:?}",
[m[32m+                event_tl_item.event_id(),
[m[32m+                tsp_sign_state
[m[32m+            );
[m             item.tsp_sign_indicator(ids!(profile.tsp_sign_indicator))
                 .show_with_state(cx, tsp_sign_state);
         }
Diff in /app/src/home/room_screen.rs:3390:
 ) -> bool {
     // The message was HTML-formatted rich text.
     let mut links = Vec::new();
[31m-    if let Some(fb) = formatted_body.as_ref()
[m[32m+    if let Some(fb) = formatted_body
[m[32m+        .as_ref()
[m         .and_then(|fb| (fb.format == MessageFormat::Html).then_some(fb))
     {
         let linkified_html = utils::linkify_get_urls(
Diff in /app/src/home/room_screen.rs:3410:
     };

     // Populate link previews if all required parameters are provided
[31m-    if let (Some(link_preview_ref), Some(media_cache), Some(link_preview_cache)) =
[m[32m+    if let (Some(link_preview_ref), Some(media_cache), Some(link_preview_cache)) =
[m         (link_preview_ref, media_cache, link_preview_cache)
     {
         link_preview_ref.populate_below_message(
Diff in /app/src/home/room_screen.rs:3438:
 ) -> bool {
     // We don't use thumbnails, as their resolution is too low to be visually useful.
     // We also don't trust the provided mimetype, as it can be incorrect.
[31m-    let (mimetype, _width, _height) = image_info_source.as_ref()
[m[32m+    let (mimetype, _width, _height) = image_info_source
[m[32m+        .as_ref()
[m         .map(|info| (info.mimetype.as_deref(), info.width, info.height))
         .unwrap_or_default();

Diff in /app/src/home/room_screen.rs:3446:
     // then show a message about it being unsupported (e.g., for animated gifs).
     if let Some(mime) = mimetype.as_ref() {
         if ImageFormat::from_mimetype(mime).is_none() {
[31m-            text_or_image_ref.show_text(
[m[31m-                cx,
[m[31m-                format!("{body}\n\nUnsupported type {mime:?}"),
[m[31m-            );
[m[32m+            text_or_image_ref.show_text(cx, format!("{body}\n\nUnsupported type {mime:?}"));
[m             return true; // consider this as fully drawn
         }
     }
Diff in /app/src/home/room_screen.rs:3458:

     // A closure that fetches and shows the image from the given `mxc_uri`,
     // marking it as fully drawn if the image was available.
[31m-    let mut fetch_and_show_image_uri = |cx: &mut Cx, mxc_uri: OwnedMxcUri, image_info: Box<ImageInfo>| {
[m[31m-        match media_cache.try_get_media_or_fetch(&mxc_uri, MEDIA_THUMBNAIL_FORMAT.into()) {
[m[31m-            (MediaCacheEntry::Loaded(data), _media_format) => {
[m[31m-                let show_image_result = text_or_image_ref.show_image(cx, Some(MediaSource::Plain(mxc_uri)),|cx, img| {
[m[31m-                    utils::load_png_or_jpg(&img, cx, &data)
[m[31m-                        .map(|()| img.size_in_pixels(cx).unwrap_or_default())
[m[31m-                });
[m[31m-                if let Err(e) = show_image_result {
[m[31m-                    let err_str = format!("{body}\n\nFailed to display image: {e:?}");
[m[31m-                    error!("{err_str}");
[m[31m-                    text_or_image_ref.show_text(cx, &err_str);
[m[31m-                }
[m[31m-
[m[31m-                // We're done drawing the image, so mark it as fully drawn.
[m[31m-                fully_drawn = true;
[m[31m-            }
[m[31m-            (MediaCacheEntry::Requested, _media_format) => {
[m[31m-                // If the image is being fetched, we try to show its blurhash.
[m[31m-                if let (Some(ref blurhash), Some(width), Some(height)) = (image_info.blurhash.clone(), image_info.width, image_info.height) {
[m[31m-                    let show_image_result = text_or_image_ref.show_image(cx, Some(MediaSource::Plain(mxc_uri)), |cx, img| {
[m[31m-                        let (Ok(width), Ok(height)) = (width.try_into(), height.try_into()) else {
[m[31m-                            return Err(image_cache::ImageError::EmptyData)
[m[31m-                        };
[m[31m-                        let (width, height): (u32, u32) = (width, height);
[m[31m-                        if width == 0 || height == 0 {
[m[31m-                            warning!("Image had an invalid aspect ratio (width or height of 0).");
[m[31m-                            return Err(image_cache::ImageError::EmptyData);
[m[31m-                        }
[m[31m-                        let aspect_ratio: f32 = width as f32 / height as f32;
[m[31m-                        // Cap the blurhash to a max size of 500 pixels in each dimension
[m[31m-                        // because the `blurhash::decode()` function can be rather expensive.
[m[31m-                        let (mut capped_width, mut capped_height) = (width, height);
[m[31m-                        if capped_height > BLURHASH_IMAGE_MAX_SIZE {
[m[31m-                            capped_height = BLURHASH_IMAGE_MAX_SIZE;
[m[31m-                            capped_width = (capped_height as f32 * aspect_ratio).floor() as u32;
[m[31m-                        }
[m[31m-                        if capped_width > BLURHASH_IMAGE_MAX_SIZE {
[m[31m-                            capped_width = BLURHASH_IMAGE_MAX_SIZE;
[m[31m-                            capped_height = (capped_width as f32 / aspect_ratio).floor() as u32;
[m[31m-                        }
[m[31m-
[m[31m-                        match blurhash::decode(blurhash, capped_width, capped_height, 1.0) {
[m[31m-                            Ok(data) => {
[m[31m-                                ImageBuffer::new(&data, capped_width as usize, capped_height as usize).map(|img_buff| {
[m[31m-                                    let texture = Some(img_buff.into_new_texture(cx));
[m[31m-                                    img.set_texture(cx, texture);
[m[31m-                                    img.size_in_pixels(cx).unwrap_or_default()
[m[31m-                                })
[m[31m-                            }
[m[31m-                            Err(e) => {
[m[31m-                                error!("Failed to decode blurhash {e:?}");
[m[31m-                                Err(image_cache::ImageError::EmptyData)
[m[31m-                            }
[m[31m-                        }
[m[31m-                    });
[m[32m+    let mut fetch_and_show_image_uri =
[m[32m+        |cx: &mut Cx, mxc_uri: OwnedMxcUri, image_info: Box<ImageInfo>| {
[m[32m+            match media_cache.try_get_media_or_fetch(&mxc_uri, MEDIA_THUMBNAIL_FORMAT.into()) {
[m[32m+                (MediaCacheEntry::Loaded(data), _media_format) => {
[m[32m+                    let show_image_result = text_or_image_ref.show_image(
[m[32m+                        cx,
[m[32m+                        Some(MediaSource::Plain(mxc_uri)),
[m[32m+                        |cx, img| {
[m[32m+                            utils::load_png_or_jpg(&img, cx, &data)
[m[32m+                                .map(|()| img.size_in_pixels(cx).unwrap_or_default())
[m[32m+                        },
[m[32m+                    );
[m                     if let Err(e) = show_image_result {
                         let err_str = format!("{body}\n\nFailed to display image: {e:?}");
                         error!("{err_str}");
Diff in /app/src/home/room_screen.rs:3519:
                         text_or_image_ref.show_text(cx, &err_str);
                     }
[32m+
[m[32m+                    // We're done drawing the image, so mark it as fully drawn.
[m[32m+                    fully_drawn = true;
[m                 }
[31m-                fully_drawn = false;
[m[31m-            }
[m[31m-            (MediaCacheEntry::Failed(_status_code), _media_format) => {
[m[31m-                if text_or_image_ref.view(ids!(default_image_view)).visible() {
[m[32m+                (MediaCacheEntry::Requested, _media_format) => {
[m[32m+                    // If the image is being fetched, we try to show its blurhash.
[m[32m+                    if let (Some(ref blurhash), Some(width), Some(height)) = (
[m[32m+                        image_info.blurhash.clone(),
[m[32m+                        image_info.width,
[m[32m+                        image_info.height,
[m[32m+                    ) {
[m[32m+                        let show_image_result = text_or_image_ref.show_image(
[m[32m+                            cx,
[m[32m+                            Some(MediaSource::Plain(mxc_uri)),
[m[32m+                            |cx, img| {
[m[32m+                                let (Ok(width), Ok(height)) = (width.try_into(), height.try_into())
[m[32m+                                else {
[m[32m+                                    return Err(image_cache::ImageError::EmptyData);
[m[32m+                                };
[m[32m+                                let (width, height): (u32, u32) = (width, height);
[m[32m+                                if width == 0 || height == 0 {
[m[32m+                                    warning!(
[m[32m+                                        "Image had an invalid aspect ratio (width or height of 0)."
[m[32m+                                    );
[m[32m+                                    return Err(image_cache::ImageError::EmptyData);
[m[32m+                                }
[m[32m+                                let aspect_ratio: f32 = width as f32 / height as f32;
[m[32m+                                // Cap the blurhash to a max size of 500 pixels in each dimension
[m[32m+                                // because the `blurhash::decode()` function can be rather expensive.
[m[32m+                                let (mut capped_width, mut capped_height) = (width, height);
[m[32m+                                if capped_height > BLURHASH_IMAGE_MAX_SIZE {
[m[32m+                                    capped_height = BLURHASH_IMAGE_MAX_SIZE;
[m[32m+                                    capped_width =
[m[32m+                                        (capped_height as f32 * aspect_ratio).floor() as u32;
[m[32m+                                }
[m[32m+                                if capped_width > BLURHASH_IMAGE_MAX_SIZE {
[m[32m+                                    capped_width = BLURHASH_IMAGE_MAX_SIZE;
[m[32m+                                    capped_height =
[m[32m+                                        (capped_width as f32 / aspect_ratio).floor() as u32;
[m[32m+                                }
[m[32m+
[m[32m+                                match blurhash::decode(blurhash, capped_width, capped_height, 1.0) {
[m[32m+                                    Ok(data) => ImageBuffer::new(
[m[32m+                                        &data,
[m[32m+                                        capped_width as usize,
[m[32m+                                        capped_height as usize,
[m[32m+                                    )
[m[32m+                                    .map(|img_buff| {
[m[32m+                                        let texture = Some(img_buff.into_new_texture(cx));
[m[32m+                                        img.set_texture(cx, texture);
[m[32m+                                        img.size_in_pixels(cx).unwrap_or_default()
[m[32m+                                    }),
[m[32m+                                    Err(e) => {
[m[32m+                                        error!("Failed to decode blurhash {e:?}");
[m[32m+                                        Err(image_cache::ImageError::EmptyData)
[m[32m+                                    }
[m[32m+                                }
[m[32m+                            },
[m[32m+                        );
[m[32m+                        if let Err(e) = show_image_result {
[m[32m+                            let err_str = format!("{body}\n\nFailed to display image: {e:?}");
[m[32m+                            error!("{err_str}");
[m[32m+                            text_or_image_ref.show_text(cx, &err_str);
[m[32m+                        }
[m[32m+                    }
[m[32m+                    fully_drawn = false;
[m[32m+                }
[m[32m+                (MediaCacheEntry::Failed(_status_code), _media_format) => {
[m[32m+                    if text_or_image_ref.view(ids!(default_image_view)).visible() {
[m[32m+                        fully_drawn = true;
[m[32m+                        return;
[m[32m+                    }
[m[32m+                    text_or_image_ref.show_text(
[m[32m+                        cx,
[m[32m+                        format!("{body}\n\nFailed to fetch image from {:?}", mxc_uri),
[m[32m+                    );
[m[32m+                    // For now, we consider this as being "complete". In the future, we could support
[m[32m+                    // retrying to fetch thumbnail of the image on a user click/tap.
[m                     fully_drawn = true;
[31m-                    return;
[m                 }
[31m-                text_or_image_ref
[m[31m-                    .show_text(cx, format!("{body}\n\nFailed to fetch image from {:?}", mxc_uri));
[m[31m-                // For now, we consider this as being "complete". In the future, we could support
[m[31m-                // retrying to fetch thumbnail of the image on a user click/tap.
[m[31m-                fully_drawn = true;
[m             }
[31m-        }
[m[31m-    };
[m[32m+        };
[m
[31m-    let mut fetch_and_show_media_source = |cx: &mut Cx, media_source: MediaSource, image_info: Box<ImageInfo>| {
[m[31m-        match media_source {
[m[31m-            MediaSource::Encrypted(encrypted) => {
[m[31m-                // We consider this as "fully drawn" since we don't yet support encryption.
[m[31m-                text_or_image_ref.show_text(
[m[31m-                    cx,
[m[31m-                    format!("{body}\n\n[TODO] fetch encrypted image at {:?}", encrypted.url)
[m[31m-                );
[m[31m-            },
[m[31m-            MediaSource::Plain(mxc_uri) => {
[m[31m-                fetch_and_show_image_uri(cx, mxc_uri, image_info)
[m[32m+    let mut fetch_and_show_media_source =
[m[32m+        |cx: &mut Cx, media_source: MediaSource, image_info: Box<ImageInfo>| {
[m[32m+            match media_source {
[m[32m+                MediaSource::Encrypted(encrypted) => {
[m[32m+                    // We consider this as "fully drawn" since we don't yet support encryption.
[m[32m+                    text_or_image_ref.show_text(
[m[32m+                        cx,
[m[32m+                        format!(
[m[32m+                            "{body}\n\n[TODO] fetch encrypted image at {:?}",
[m[32m+                            encrypted.url
[m[32m+                        ),
[m[32m+                    );
[m[32m+                }
[m[32m+                MediaSource::Plain(mxc_uri) => fetch_and_show_image_uri(cx, mxc_uri, image_info),
[m             }
[31m-        }
[m[31m-    };
[m[32m+        };
[m
     match image_info_source {
         Some(image_info) => {
Diff in /app/src/home/room_screen.rs:3555:
             // Use the provided thumbnail URI if it exists; otherwise use the original URI.
[31m-            let media_source = image_info.thumbnail_source.clone()
[m[32m+            let media_source = image_info
[m[32m+                .thumbnail_source
[m[32m+                .clone()
[m                 .unwrap_or(original_source);
             fetch_and_show_media_source(cx, media_source, image_info);
         }
Diff in /app/src/home/room_screen.rs:3566:
     fully_drawn
 }

[31m-
[m /// Draws a file message's content into the given `message_content_widget`.
 ///
 /// Returns whether the file message content was fully drawn.
Diff in /app/src/home/room_screen.rs:3583:
         .and_then(|info| info.size)
         .map(|bytes| format!("  ({})", ByteSize::b(bytes.into())))
         .unwrap_or_default();
[31m-    let caption = file_content.formatted_caption()
[m[32m+    let caption = file_content
[m[32m+        .formatted_caption()
[m         .map(|fb| format!("<br><i>{}</i>", fb.body))
         .or_else(|| file_content.caption().map(|c| format!("<br><i>{c}</i>")))
         .unwrap_or_default();
Diff in /app/src/home/room_screen.rs:3610:
     let (duration, mime, size) = audio
         .info
         .as_ref()
[31m-        .map(|info| (
[m[31m-            info.duration
[m[31m-                .map(|d| format!("  {:.2} sec,", d.as_secs_f64()))
[m[31m-                .unwrap_or_default(),
[m[31m-            info.mimetype
[m[31m-                .as_ref()
[m[31m-                .map(|m| format!("  {m},"))
[m[31m-                .unwrap_or_default(),
[m[31m-            info.size
[m[31m-                .map(|bytes| format!("  ({}),", ByteSize::b(bytes.into())))
[m[31m-                .unwrap_or_default(),
[m[31m-        ))
[m[32m+        .map(|info| {
[m[32m+            (
[m[32m+                info.duration
[m[32m+                    .map(|d| format!("  {:.2} sec,", d.as_secs_f64()))
[m[32m+                    .unwrap_or_default(),
[m[32m+                info.mimetype
[m[32m+                    .as_ref()
[m[32m+                    .map(|m| format!("  {m},"))
[m[32m+                    .unwrap_or_default(),
[m[32m+                info.size
[m[32m+                    .map(|bytes| format!("  ({}),", ByteSize::b(bytes.into())))
[m[32m+                    .unwrap_or_default(),
[m[32m+            )
[m[32m+        })
[m         .unwrap_or_default();
[31m-    let caption = audio.formatted_caption()
[m[32m+    let caption = audio
[m[32m+        .formatted_caption()
[m         .map(|fb| format!("<br><i>{}</i>", fb.body))
         .or_else(|| audio.caption().map(|c| format!("<br><i>{c}</i>")))
         .unwrap_or_default();
Diff in /app/src/home/room_screen.rs:3637:
     true
 }

[31m-
[m /// Draws a video message's content into the given `message_content_widget`.
 ///
 /// Returns whether the video message content was fully drawn.
Diff in /app/src/home/room_screen.rs:3651:
     let (duration, mime, size, dimensions) = video
         .info
         .as_ref()
[31m-        .map(|info| (
[m[31m-            info.duration
[m[31m-                .map(|d| format!("  {:.2} sec,", d.as_secs_f64()))
[m[31m-                .unwrap_or_default(),
[m[31m-            info.mimetype
[m[31m-                .as_ref()
[m[31m-                .map(|m| format!("  {m},"))
[m[31m-                .unwrap_or_default(),
[m[31m-            info.size
[m[31m-                .map(|bytes| format!("  ({}),", ByteSize::b(bytes.into())))
[m[31m-                .unwrap_or_default(),
[m[31m-            info.width.and_then(|width|
[m[31m-                info.height.map(|height| format!("  {width}x{height},"))
[m[31m-            ).unwrap_or_default(),
[m[31m-        ))
[m[32m+        .map(|info| {
[m[32m+            (
[m[32m+                info.duration
[m[32m+                    .map(|d| format!("  {:.2} sec,", d.as_secs_f64()))
[m[32m+                    .unwrap_or_default(),
[m[32m+                info.mimetype
[m[32m+                    .as_ref()
[m[32m+                    .map(|m| format!("  {m},"))
[m[32m+                    .unwrap_or_default(),
[m[32m+                info.size
[m[32m+                    .map(|bytes| format!("  ({}),", ByteSize::b(bytes.into())))
[m[32m+                    .unwrap_or_default(),
[m[32m+                info.width
[m[32m+                    .and_then(|width| info.height.map(|height| format!("  {width}x{height},")))
[m[32m+                    .unwrap_or_default(),
[m[32m+            )
[m[32m+        })
[m         .unwrap_or_default();
[31m-    let caption = video.formatted_caption()
[m[32m+    let caption = video
[m[32m+        .formatted_caption()
[m         .map(|fb| format!("<br><i>{}</i>", fb.body))
         .or_else(|| video.caption().map(|c| format!("<br><i>{c}</i>")))
         .unwrap_or_default();
Diff in /app/src/home/room_screen.rs:3681:
     true
 }

[31m-
[m[31m-
[m /// Draws the given location message's content into the `message_content_widget`.
 ///
 /// Returns whether the location message content was fully drawn.
Diff in /app/src/home/room_screen.rs:3691:
     message_content_widget: &HtmlOrPlaintextRef,
     location: &LocationMessageEventContent,
 ) -> bool {
[31m-    let coords = location.geo_uri
[m[31m-        .get(utils::GEO_URI_SCHEME.len() ..)
[m[32m+    let coords = location
[m[32m+        .geo_uri
[m[32m+        .get(utils::GEO_URI_SCHEME.len()..)
[m         .and_then(|s| {
             let mut iter = s.split(',');
             if let (Some(lat), Some(long)) = (iter.next(), iter.next()) {
Diff in /app/src/home/room_screen.rs:3702:
             }
         });
     if let Some((lat, long)) = coords {
[31m-        let short_lat = lat.find('.').and_then(|dot| lat.get(..dot + 7)).unwrap_or(lat);
[m[31m-        let short_long = long.find('.').and_then(|dot| long.get(..dot + 7)).unwrap_or(long);
[m[32m+        let short_lat = lat
[m[32m+            .find('.')
[m[32m+            .and_then(|dot| lat.get(..dot + 7))
[m[32m+            .unwrap_or(lat);
[m[32m+        let short_long = long
[m[32m+            .find('.')
[m[32m+            .and_then(|dot| long.get(..dot + 7))
[m[32m+            .unwrap_or(long);
[m         let html_body = format!(
             "Location: <a href=\"{}\">{short_lat},{short_long}</a><br>\
             <ul>\
Diff in /app/src/home/room_screen.rs:3715:
         );
         message_content_widget.show_html(cx, html_body);
     } else {
[31m-        message_content_widget.show_html(
[m[31m-            cx,
[m[31m-            format!("<i>[Location invalid]</i> {}", location.body)
[m[31m-        );
[m[32m+        message_content_widget
[m[32m+            .show_html(cx, format!("<i>[Location invalid]</i> {}", location.body));
[m     }

     // Currently we do not fetch location thumbnail previews, so we consider this as fully drawn.
Diff in /app/src/home/room_screen.rs:3727:
     true
 }

[31m-
[m /// Draws the given redacted message's content into the `message_content_widget`.
 ///
 /// Returns whether the redacted message content was fully drawn.
Diff in /app/src/home/room_screen.rs:3740:
     let fully_drawn: bool;
     let mut redactor_id_and_reason = None;
     if let Some(redacted_msg) = event_tl_item.latest_json() {
[31m-        if let Ok(AnySyncTimelineEvent::MessageLike(
[m[31m-            AnySyncMessageLikeEvent::RoomMessage(
[m[31m-                SyncMessageLikeEvent::Redacted(redaction)
[m[31m-            )
[m[31m-        )) = redacted_msg.deserialize() {
[m[32m+        if let Ok(AnySyncTimelineEvent::MessageLike(AnySyncMessageLikeEvent::RoomMessage(
[m[32m+            SyncMessageLikeEvent::Redacted(redaction),
[m[32m+        ))) = redacted_msg.deserialize()
[m[32m+        {
[m             if let Ok(redacted_because) = redaction.unsigned.redacted_because.deserialize() {
[31m-                redactor_id_and_reason = Some((
[m[31m-                    redacted_because.sender,
[m[31m-                    redacted_because.content.reason,
[m[31m-                ));
[m[32m+                redactor_id_and_reason =
[m[32m+                    Some((redacted_because.sender, redacted_because.content.reason));
[m             }
         }
     }
Diff in /app/src/home/room_screen.rs:3758:
         if redactor == event_tl_item.sender() {
             fully_drawn = true;
             match reason {
[31m-                Some(r) => format!("⛔ <i>Deleted their own message. Reason: \"{}\".</i>", htmlize::escape_text(r)),
[m[32m+                Some(r) => format!(
[m[32m+                    "⛔ <i>Deleted their own message. Reason: \"{}\".</i>",
[m[32m+                    htmlize::escape_text(r)
[m[32m+                ),
[m                 None => String::from("⛔ <i>Deleted their own message.</i>"),
             }
         } else {
Diff in /app/src/home/room_screen.rs:3770:
                 true,
             );
             fully_drawn = redactor_name.was_found();
[31m-            let redactor_name_esc = htmlize::escape_text(redactor_name.as_deref().unwrap_or(redactor.as_str()));
[m[32m+            let redactor_name_esc =
[m[32m+                htmlize::escape_text(redactor_name.as_deref().unwrap_or(redactor.as_str()));
[m             match reason {
[31m-                Some(r) => format!("⛔ <i>{} deleted this message. Reason: \"{}\".</i>",
[m[32m+                Some(r) => format!(
[m[32m+                    "⛔ <i>{} deleted this message. Reason: \"{}\".</i>",
[m                     redactor_name_esc,
                     htmlize::escape_text(r),
                 ),
Diff in /app/src/home/room_screen.rs:3787:
     fully_drawn
 }

[31m-
[m /// Draws a ReplyPreview above a message if it was in-reply to another message.
 ///
 /// ## Arguments
Diff in /app/src/home/room_screen.rs:3816:

         match &in_reply_to_details.event {
             TimelineDetails::Ready(replied_to_event) => {
[31m-                let (in_reply_to_username, is_avatar_fully_drawn) =
[m[31m-                    replied_to_message_view
[m[31m-                        .avatar(ids!(replied_to_message_content.reply_preview_avatar))
[m[31m-                        .set_avatar_and_get_username(
[m[31m-                            cx,
[m[31m-                            room_id,
[m[31m-                            &replied_to_event.sender,
[m[31m-                            Some(&replied_to_event.sender_profile),
[m[31m-                            Some(in_reply_to_details.event_id.as_ref()),
[m[31m-                            true,
[m[31m-                        );
[m[32m+                let (in_reply_to_username, is_avatar_fully_drawn) = replied_to_message_view
[m[32m+                    .avatar(ids!(replied_to_message_content.reply_preview_avatar))
[m[32m+                    .set_avatar_and_get_username(
[m[32m+                        cx,
[m[32m+                        room_id,
[m[32m+                        &replied_to_event.sender,
[m[32m+                        Some(&replied_to_event.sender_profile),
[m[32m+                        Some(in_reply_to_details.event_id.as_ref()),
[m[32m+                        true,
[m[32m+                    );
[m
                 fully_drawn = is_avatar_fully_drawn;

Diff in /app/src/home/room_screen.rs:3900:
 ) {
     if let Some(m) = timeline_item_content.as_message() {
         match m.msgtype() {
[31m-            MessageType::Text(TextMessageEventContent { body, formatted, .. })
[m[31m-            | MessageType::Notice(NoticeMessageEventContent { body, formatted, .. }) => {
[m[31m-                let _ = populate_text_message_content(cx, widget_out, body, formatted.as_ref(), None, None, None);
[m[32m+            MessageType::Text(TextMessageEventContent {
[m[32m+                body, formatted, ..
[m[32m+            })
[m[32m+            | MessageType::Notice(NoticeMessageEventContent {
[m[32m+                body, formatted, ..
[m[32m+            }) => {
[m[32m+                let _ = populate_text_message_content(
[m[32m+                    cx,
[m[32m+                    widget_out,
[m[32m+                    body,
[m[32m+                    formatted.as_ref(),
[m[32m+                    None,
[m[32m+                    None,
[m[32m+                    None,
[m[32m+                );
[m                 return;
             }
[31m-            _ => { } // fall through to the general case for all timeline items below.
[m[32m+            _ => {} // fall through to the general case for all timeline items below.
[m         }
     }
[31m-    let html = text_preview_of_timeline_item(
[m[31m-        timeline_item_content,
[m[31m-        sender_user_id,
[m[31m-        sender_username,
[m[31m-    ).format_with(sender_username, true);
[m[32m+    let html =
[m[32m+        text_preview_of_timeline_item(timeline_item_content, sender_user_id, sender_username)
[m[32m+            .format_with(sender_username, true);
[m     widget_out.show_html(cx, html);
 }

Diff in /app/src/home/room_screen.rs:3919:
[31m-
[m /// A trait for abstracting over the different types of timeline events
 /// that can be displayed in a `SmallStateEvent` widget.
 trait SmallStateEventContent {
Diff in /app/src/home/room_screen.rs:4007:
     ) -> (WidgetRef, ItemDrawnStatus) {
         item.label(ids!(content)).set_text(
             cx,
[31m-            self.fallback_text().unwrap_or_else(|| self.results().question).as_str(),
[m[32m+            self.fallback_text()
[m[32m+                .unwrap_or_else(|| self.results().question)
[m[32m+                .as_str(),
[m         );
         new_drawn_status.content_drawn = true;
         (item, new_drawn_status)
Diff in /app/src/home/room_screen.rs:4076:
     ) -> (WidgetRef, ItemDrawnStatus) {
         let Some(preview) = text_preview_of_room_membership_change(self, false) else {
             // Don't actually display anything for nonexistent/unimportant membership changes.
[31m-            return (
[m[31m-                list.item(cx, item_id, id!(Empty)),
[m[31m-                ItemDrawnStatus::new(),
[m[31m-            );
[m[32m+            return (list.item(cx, item_id, id!(Empty)), ItemDrawnStatus::new());
[m         };

         item.label(ids!(content))
Diff in /app/src/home/room_screen.rs:4086:
             .set_text(cx, &preview.format_with(username, false));

         // The invite_user_button is only used for "Knocked" membership change events.
[31m-        item.button(ids!(invite_user_button)).set_visible(
[m[31m-            cx,
[m[31m-            matches!(self.change(), Some(MembershipChange::Knocked)),
[m[31m-        );
[m[32m+        item.button(ids!(invite_user_button))
[m[32m+            .set_visible(cx, matches!(self.change(), Some(MembershipChange::Knocked)));
[m
         new_drawn_status.content_drawn = true;
         (item, new_drawn_status)
Diff in /app/src/home/room_screen.rs:4141:
         );
         // Draw the timestamp as part of the profile.
         if let Some(dt) = unix_time_millis_to_datetime(event_tl_item.timestamp()) {
[31m-            item.timestamp(ids!(left_container.timestamp)).set_date_time(cx, dt);
[m[32m+            item.timestamp(ids!(left_container.timestamp))
[m[32m+                .set_date_time(cx, dt);
[m         }
         new_drawn_status.profile_drawn = profile_drawn;
         username
Diff in /app/src/home/room_screen.rs:4160:
     )
 }

[31m-
[m /// Returns the display name of the sender of the given `event_tl_item`, if available.
 fn get_profile_display_name(event_tl_item: &EventTimelineItem) -> Option<String> {
     if let TimelineDetails::Ready(profile) = event_tl_item.sender_profile() {
Diff in /app/src/home/room_screen.rs:4170:
     }
 }

[31m-
[m /// Actions related to invites within a room.
 ///
 /// These are NOT widget actions, just regular actions.
Diff in /app/src/home/room_screen.rs:4205:
     },
 }

[31m-
[m /// Actions related to a specific message within a room timeline.
 #[derive(Clone, DefaultNone, Debug)]
 pub enum MessageAction {
Diff in /app/src/home/room_screen.rs:4248:

     // /// The user clicked the "report" button on a message.
     // Report(MessageDetails),
[31m-
[m     /// The message at the given item index in the timeline should be highlighted.
     HighlightMessage(usize),
     /// The user requested that we show a context menu with actions
Diff in /app/src/home/room_screen.rs:4274:
 /// A widget representing a single message of any kind within a room timeline.
 #[derive(Live, LiveHook, Widget)]
 pub struct Message {
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m
[31m-    #[rust] details: Option<MessageDetails>,
[m[32m+    #[rust]
[m[32m+    details: Option<MessageDetails>,
[m }

 impl Widget for Message {
Diff in /app/src/home/room_screen.rs:4292:
             self.animator_play(cx, ids!(highlight.off));
         }

[31m-        let Some(details) = self.details.clone() else { return };
[m[32m+        let Some(details) = self.details.clone() else {
[m[32m+            return;
[m[32m+        };
[m
         // We first handle a click on the replied-to message preview, if present,
         // because we don't want any widgets within the replied-to message to be
Diff in /app/src/home/room_screen.rs:4306:
                         MessageAction::OpenMessageContextMenu {
                             details: details.clone(),
                             abs_pos: fe.abs,
[31m-                        }
[m[32m+                        },
[m                     );
                 }
             }
Diff in /app/src/home/room_screen.rs:4317:
                     MessageAction::OpenMessageContextMenu {
                         details: details.clone(),
                         abs_pos: lp.abs,
[31m-                    }
[m[32m+                    },
[m                 );
             }
             // If the hit occurred on the replied-to message preview, jump to it.
Diff in /app/src/home/room_screen.rs:4328:
                     MessageAction::JumpToRelated(details.clone()),
                 );
             }
[31m-            _ => { }
[m[32m+            _ => {}
[m         }

         // Next, we forward the event to the child view such that it has the chance
Diff in /app/src/home/room_screen.rs:4351:
                         MessageAction::OpenMessageContextMenu {
                             details: details.clone(),
                             abs_pos: fe.abs,
[31m-                        }
[m[32m+                        },
[m                     );
                 }
             }
Diff in /app/src/home/room_screen.rs:4362:
                     MessageAction::OpenMessageContextMenu {
                         details: details.clone(),
                         abs_pos: lp.abs,
[31m-                    }
[m[32m+                    },
[m                 );
             }
             Hit::FingerHoverIn(..) => {
Diff in /app/src/home/room_screen.rs:4373:
                 self.animator_play(cx, ids!(hover.off));
                 // TODO: here, hide the "action bar" buttons upon hover-out
             }
[31m-            _ => { }
[m[32m+            _ => {}
[m         }

         if let Event::Actions(actions) = event {
Diff in /app/src/home/room_screen.rs:4380:
             for action in actions {
[31m-                match action.as_widget_action().widget_uid_eq(details.room_screen_widget_uid).cast_ref() {
[m[32m+                match action
[m[32m+                    .as_widget_action()
[m[32m+                    .widget_uid_eq(details.room_screen_widget_uid)
[m[32m+                    .cast_ref()
[m[32m+                {
[m                     MessageAction::HighlightMessage(id) if id == &details.item_id => {
                         self.animator_play(cx, ids!(highlight.on));
                         self.redraw(cx);
Diff in /app/src/home/room_screen.rs:4390:
     }

     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
[31m-        if self.details.as_ref().is_some_and(|d| d.should_be_highlighted) {
[m[32m+        if self
[m[32m+            .details
[m[32m+            .as_ref()
[m[32m+            .is_some_and(|d| d.should_be_highlighted)
[m[32m+        {
[m             self.view.apply_over(
[31m-                cx, live!(
[m[32m+                cx,
[m[32m+                live!(
[m                     draw_bg: {
                         color: (vec4(1.0, 1.0, 0.82, 1.0))
                         mentions_bar_color: #ffd54f
Diff in /app/src/home/room_screen.rs:4399:
                     }
[31m-                )
[m[32m+                ),
[m             )
         }

Diff in /app/src/home/room_screen.rs:4413:

 impl MessageRef {
     fn set_data(&self, details: MessageDetails) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_data(details);
     }
 }
Diff in /app/src/home/room_screen.rs:4422:
 ///
 /// This function requires passing in a reference to `Cx`,
 /// which isn't used, but acts as a guarantee that this function
[31m-/// must only be called by the main UI thread.
[m[32m+/// must only be called by the main UI thread.
[m pub fn clear_timeline_states(_cx: &mut Cx) {
     // Clear timeline states cache
     TIMELINE_STATES.with_borrow_mut(|states| {
Diff in /app/src/home/rooms_list.rs:16:
 //! so you can use it from other widgets or functions on the main UI thread
 //! that need to query basic info about a particular room or space.

[31m-use std::{cell::RefCell, collections::{HashMap, HashSet, VecDeque, hash_map::Entry}, rc::Rc, sync::Arc};
[m[32m+use std::{
[m[32m+    cell::RefCell,
[m[32m+    collections::{HashMap, HashSet, VecDeque, hash_map::Entry},
[m[32m+    rc::Rc,
[m[32m+    sync::Arc,
[m[32m+};
[m use crossbeam_queue::SegQueue;
 use makepad_widgets::*;
 use matrix_sdk_ui::spaces::room_list::SpaceRoomListPaginationState;
Diff in /app/src/home/rooms_list.rs:23:
 use ruma::events::tag::TagName;
 use tokio::sync::mpsc::UnboundedSender;
[31m-use matrix_sdk::{RoomState, ruma::{events::tag::Tags, MilliSecondsSinceUnixEpoch, OwnedRoomAliasId, OwnedRoomId, OwnedUserId}};
[m[32m+use matrix_sdk::{
[m[32m+    RoomState,
[m[32m+    ruma::{
[m[32m+        events::tag::Tags, MilliSecondsSinceUnixEpoch, OwnedRoomAliasId, OwnedRoomId, OwnedUserId,
[m[32m+    },
[m[32m+};
[m use crate::{
     app::{AppState, SelectedRoom},
     home::{
Diff in /app/src/home/rooms_list.rs:29:
[31m-        navigation_tab_bar::{NavigationBarAction, SelectedTab}, room_context_menu::RoomContextMenuDetails, rooms_list_entry::RoomsListEntryAction, space_lobby::{SpaceLobbyAction, SpaceLobbyEntryWidgetExt}
[m[32m+        navigation_tab_bar::{NavigationBarAction, SelectedTab},
[m[32m+        room_context_menu::RoomContextMenuDetails,
[m[32m+        rooms_list_entry::RoomsListEntryAction,
[m[32m+        space_lobby::{SpaceLobbyAction, SpaceLobbyEntryWidgetExt},
[m     },
     room::{
         FetchedRoomAvatar,
Diff in /app/src/home/rooms_list.rs:33:
[31m-        room_display_filter::{RoomDisplayFilter, RoomDisplayFilterBuilder, RoomFilterCriteria, SortFn},
[m[32m+        room_display_filter::{
[m[32m+            RoomDisplayFilter, RoomDisplayFilterBuilder, RoomFilterCriteria, SortFn,
[m[32m+        },
[m     },
     shared::{
[31m-        collapsible_header::{CollapsibleHeaderAction, CollapsibleHeaderWidgetRefExt, HeaderCategory},
[m[32m+        collapsible_header::{
[m[32m+            CollapsibleHeaderAction, CollapsibleHeaderWidgetRefExt, HeaderCategory,
[m[32m+        },
[m         jump_to_bottom_button::UnreadMessageCount,
         popup_list::{PopupKind, enqueue_popup_notification},
         room_filter_input_bar::RoomFilterAction,
Diff in /app/src/home/rooms_list.rs:40:
     },
     sliding_sync::{MatrixLinkAction, MatrixRequest, PaginationDirection, submit_async_request},
[31m-    space_service_sync::{ParentChain, SpaceRequest, SpaceRoomListAction}, utils::{RoomNameId, VecDiff},
[m[32m+    space_service_sync::{ParentChain, SpaceRequest, SpaceRoomListAction},
[m[32m+    utils::{RoomNameId, VecDiff},
[m };

 /// Whether to pre-paginate visible rooms at least once in order to
Diff in /app/src/home/rooms_list.rs:71:
 /// must only be called by the main UI thread.
 pub fn clear_all_invited_rooms(_cx: &mut Cx) {
     ALL_INVITED_ROOMS.with(|rooms| {
[31m-       rooms.borrow_mut().clear();
[m[32m+        rooms.borrow_mut().clear();
[m     });
 }

Diff in /app/src/home/rooms_list.rs:78:
[31m-
[m live_design! {
     use link::theme::*;
     use link::shaders::*;
Diff in /app/src/home/rooms_list.rs:146:
     }
 }

[31m-
[m /// The possible updates that should be displayed by the single list of all rooms.
 ///
 /// These updates are enqueued by the `enqueue_rooms_list_update` function
Diff in /app/src/home/rooms_list.rs:157:
     NotLoaded,
     /// Some rooms were loaded, and the server optionally told us
     /// the max number of rooms that will ever be loaded.
[31m-    LoadedRooms{ max_rooms: Option<u32> },
[m[32m+    LoadedRooms { max_rooms: Option<u32> },
[m     /// Add a new room to the list of rooms the user has been invited to.
     /// This will be maintained and displayed separately from joined rooms.
     AddInvitedRoom(InvitedRoomInfo),
Diff in /app/src/home/rooms_list.rs:180:
         unread_mentions: u64,
     },
     /// Update the displayable name for the given room.
[31m-    UpdateRoomName {
[m[31m-        new_room_name: RoomNameId,
[m[31m-    },
[m[32m+    UpdateRoomName { new_room_name: RoomNameId },
[m     /// Update the avatar (image) for the given room.
     UpdateRoomAvatar {
         room_id: OwnedRoomId,
Diff in /app/src/home/rooms_list.rs:205:
         new_tags: Tags,
     },
     /// Update the status label at the bottom of the list of all rooms.
[31m-    Status {
[m[31m-        status: String,
[m[31m-    },
[m[32m+    Status { status: String },
[m     /// Mark the given room as tombstoned.
[31m-    TombstonedRoom {
[m[31m-        room_id: OwnedRoomId
[m[31m-    },
[m[32m+    TombstonedRoom { room_id: OwnedRoomId },
[m     /// Hide the given room from being displayed.
     ///
     /// This is useful for temporarily preventing a room from being shown,
Diff in /app/src/home/rooms_list.rs:218:
     /// e.g., after a room has been left but before the homeserver has registered
     /// that we left it and removed it via the RoomListService.
[31m-    HideRoom {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    HideRoom { room_id: OwnedRoomId },
[m     /// Scroll to the given room.
     ScrollToRoom(OwnedRoomId),
     /// The background space service is now listening for requests,
Diff in /app/src/home/rooms_list.rs:257:
     None,
 }

[31m-
[m /// UI-related info about a joined room.
 ///
 /// This includes info needed display a preview of that room in the RoomsList
Diff in /app/src/home/rooms_list.rs:296:
     pub is_direct: bool,
     /// Whether this room is tombstoned (shut down and replaced with a successor room).
     pub is_tombstoned: bool,
[31m-
[m     // TODO: we could store the parent chain(s) of this room, i.e., which spaces
     //       they are children of. One room can be in multiple spaces.
 }
Diff in /app/src/home/rooms_list.rs:388:

 #[derive(Live, Widget)]
 pub struct RoomsList {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// The list of all rooms that the user has been invited to.
     ///
Diff in /app/src/home/rooms_list.rs:395:
     /// This is a shared reference to the thread-local [`ALL_INVITED_ROOMS`] variable.
[31m-    #[rust] invited_rooms: Rc<RefCell<HashMap<OwnedRoomId, InvitedRoomInfo>>>,
[m[32m+    #[rust]
[m[32m+    invited_rooms: Rc<RefCell<HashMap<OwnedRoomId, InvitedRoomInfo>>>,
[m
     /// The set of all joined rooms and their cached info.
     /// This includes both direct rooms and regular rooms, but not invited rooms.
Diff in /app/src/home/rooms_list.rs:400:
[31m-    #[rust] all_joined_rooms: HashMap<OwnedRoomId, JoinedRoomInfo>,
[m[32m+    #[rust]
[m[32m+    all_joined_rooms: HashMap<OwnedRoomId, JoinedRoomInfo>,
[m
     /// The list of all room IDs in display order, matching the order from the room list service.
[31m-    #[rust] all_known_rooms_order: VecDeque<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    all_known_rooms_order: VecDeque<OwnedRoomId>,
[m
     /// The space that is currently selected as a display filter for the rooms list, if any.
     /// * If `None` (default), no space is selected, and all rooms can be shown.
Diff in /app/src/home/rooms_list.rs:407:
     /// * If `Some`, the rooms list is in "space" mode. A special "Space Lobby" entry
     ///   is shown at the top, and only child rooms within this space will be displayed.
[31m-    #[rust] selected_space: Option<RoomNameId>,
[m[32m+    #[rust]
[m[32m+    selected_space: Option<RoomNameId>,
[m
     /// The sender used to send Space-related requests to the background service.
[31m-    #[rust] space_request_sender: Option<UnboundedSender<SpaceRequest>>,
[m[32m+    #[rust]
[m[32m+    space_request_sender: Option<UnboundedSender<SpaceRequest>>,
[m
     /// A flattened map of all spaces known to the client.
     ///
Diff in /app/src/home/rooms_list.rs:417:
     /// and nested subspaces *directly* within that space.
     ///
     /// This can include both joined and non-joined spaces.
[31m-    #[rust] space_map: HashMap<OwnedRoomId, SpaceMapValue>,
[m[32m+    #[rust]
[m[32m+    space_map: HashMap<OwnedRoomId, SpaceMapValue>,
[m
     /// Rooms that are explicitly hidden and should never be shown in the rooms list.
[31m-    #[rust] hidden_rooms: HashSet<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    hidden_rooms: HashSet<OwnedRoomId>,
[m
     /// The currently-active filter function for the list of rooms.
     ///
Diff in /app/src/home/rooms_list.rs:427:
     /// ## Important Notes
     /// 1. Do not use this directly. Instead, use the `should_display_room!()` macro.
     /// 2. This does *not* get auto-applied when it changes, for performance reasons.
[31m-    #[rust] display_filter: RoomDisplayFilter,
[m[32m+    #[rust]
[m[32m+    display_filter: RoomDisplayFilter,
[m
     /// The currently-active sort function for the list of rooms.
[31m-    #[rust] sort_fn: Option<Box<SortFn>>,
[m[32m+    #[rust]
[m[32m+    sort_fn: Option<Box<SortFn>>,
[m
     /// The list of invited rooms currently displayed in the UI.
[31m-    #[rust] displayed_invited_rooms: Vec<OwnedRoomId>,
[m[31m-    #[rust(false)] is_invited_rooms_header_expanded: bool,
[m[31m-    #[rust] invited_rooms_indexes: RoomCategoryIndexes,
[m[32m+    #[rust]
[m[32m+    displayed_invited_rooms: Vec<OwnedRoomId>,
[m[32m+    #[rust(false)]
[m[32m+    is_invited_rooms_header_expanded: bool,
[m[32m+    #[rust]
[m[32m+    invited_rooms_indexes: RoomCategoryIndexes,
[m
     /// The list of direct rooms currently displayed in the UI.
[31m-    #[rust] displayed_direct_rooms: Vec<OwnedRoomId>,
[m[31m-    #[rust(false)] is_direct_rooms_header_expanded: bool,
[m[31m-    #[rust] direct_rooms_indexes: RoomCategoryIndexes,
[m[32m+    #[rust]
[m[32m+    displayed_direct_rooms: Vec<OwnedRoomId>,
[m[32m+    #[rust(false)]
[m[32m+    is_direct_rooms_header_expanded: bool,
[m[32m+    #[rust]
[m[32m+    direct_rooms_indexes: RoomCategoryIndexes,
[m
     /// The list of regular (non-direct) joined rooms currently displayed in the UI.
     ///
Diff in /app/src/home/rooms_list.rs:447:
     /// **Direct rooms are excluded** from this; they are in `displayed_direct_rooms`.
[31m-    #[rust] displayed_regular_rooms: Vec<OwnedRoomId>,
[m[31m-    #[rust(true)] is_regular_rooms_header_expanded: bool,
[m[31m-    #[rust] regular_rooms_indexes: RoomCategoryIndexes,
[m[32m+    #[rust]
[m[32m+    displayed_regular_rooms: Vec<OwnedRoomId>,
[m[32m+    #[rust(true)]
[m[32m+    is_regular_rooms_header_expanded: bool,
[m[32m+    #[rust]
[m[32m+    regular_rooms_indexes: RoomCategoryIndexes,
[m
     /// The latest status message that should be displayed in the bottom status label.
[31m-    #[rust] status: String,
[m[32m+    #[rust]
[m[32m+    status: String,
[m
     /// The ID of the currently-selected room.
[31m-    #[rust] current_active_room: Option<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    current_active_room: Option<OwnedRoomId>,
[m
     /// The maximum number of rooms that will ever be loaded.
     ///
Diff in /app/src/home/rooms_list.rs:460:
     /// This should not be used to determine whether all requested rooms have been loaded,
     /// because we will likely never receive this many rooms due to the room list service
     /// excluding rooms that we have filtered out (e.g., left or tombstoned rooms, spaces, etc).
[31m-    #[rust] max_known_rooms: Option<u32>,
[m[32m+    #[rust]
[m[32m+    max_known_rooms: Option<u32>,
[m     // /// Whether the room list service has loaded all requested rooms from the homeserver.
     // #[rust] all_rooms_loaded: bool,
 }
Diff in /app/src/home/rooms_list.rs:483:
     ($self:expr, $room_id:expr, $room:expr) => {
         !$self.hidden_rooms.contains($room_id)
             && ($self.display_filter)($room)
[31m-            && $self.selected_space.as_ref()
[m[32m+            && $self
[m[32m+                .selected_space
[m[32m+                .as_ref()
[m                 .is_none_or(|space| $self.is_room_indirectly_in_space(space.room_id(), $room_id))
     };
 }
Diff in /app/src/home/rooms_list.rs:490:

[31m-
[m impl RoomsList {
     /// Returns whether the homeserver has finished syncing all of the rooms
[31m-    /// that should be synced to our client based on the currently-specified room list filter.
[m[32m+    /// that should be synced to our client based on the currently-specified room list filter.
[m     pub fn all_rooms_loaded(&self) -> bool {
         // TODO: fix this: figure out a way to determine if
         //       all requested rooms have been received from the homeserver.
Diff in /app/src/home/rooms_list.rs:520:
                 RoomsListUpdate::AddInvitedRoom(invited_room) => {
                     let room_id = invited_room.room_name_id.room_id().clone();
                     let should_display = should_display_room!(self, &room_id, &invited_room);
[31m-                    let _replaced = self.invited_rooms.borrow_mut().insert(room_id.clone(), invited_room);
[m[32m+                    let _replaced = self
[m[32m+                        .invited_rooms
[m[32m+                        .borrow_mut()
[m[32m+                        .insert(room_id.clone(), invited_room);
[m                     if should_display {
                         self.displayed_invited_rooms.push(room_id);
                     }
Diff in /app/src/home/rooms_list.rs:546:
                     // 3. Emit an action to inform other widgets that the InviteScreen
                     //    displaying the invite to this room should be converted to a
                     //    RoomScreen displaying the now-joined room.
[31m-                    if let Some(_accepted_invite) = self.invited_rooms.borrow_mut().remove(&room_id) {
[m[32m+                    if let Some(_accepted_invite) = self.invited_rooms.borrow_mut().remove(&room_id)
[m[32m+                    {
[m                         log!("Removed room {room_id} from the list of invited rooms");
[31m-                        self.displayed_invited_rooms.iter()
[m[32m+                        self.displayed_invited_rooms
[m[32m+                            .iter()
[m                             .position(|r| r == &room_id)
                             .map(|index| self.displayed_invited_rooms.remove(index));
                         if let Some(room) = self.all_joined_rooms.get(&room_id) {
Diff in /app/src/home/rooms_list.rs:557:
                                 &scope.path,
                                 RoomsListAction::InviteAccepted {
                                     room_name_id: room.room_name_id.clone(),
[31m-                                }
[m[32m+                                },
[m                             );
                         }
                     }
Diff in /app/src/home/rooms_list.rs:564:
                     self.update_status();
                     SignalToUI::set_ui_signal(); // signal the RoomScreen to update itself
                 }
[31m-                RoomsListUpdate::UpdateRoomAvatar { room_id, room_avatar } => {
[m[32m+                RoomsListUpdate::UpdateRoomAvatar {
[m[32m+                    room_id,
[m[32m+                    room_avatar,
[m[32m+                } => {
[m                     if let Some(room) = self.all_joined_rooms.get_mut(&room_id) {
                         room.room_avatar = room_avatar;
                     } else {
Diff in /app/src/home/rooms_list.rs:571:
                         error!("Error: couldn't find room {room_id} to update avatar");
                     }
                 }
[31m-                RoomsListUpdate::UpdateLatestEvent { room_id, timestamp, latest_message_text } => {
[m[32m+                RoomsListUpdate::UpdateLatestEvent {
[m[32m+                    room_id,
[m[32m+                    timestamp,
[m[32m+                    latest_message_text,
[m[32m+                } => {
[m                     if let Some(room) = self.all_joined_rooms.get_mut(&room_id) {
                         room.latest = Some((timestamp, latest_message_text));
                     } else {
Diff in /app/src/home/rooms_list.rs:578:
                         error!("Error: couldn't find room {room_id} to update latest event");
                     }
                 }
[31m-                RoomsListUpdate::UpdateNumUnreadMessages { room_id, is_marked_unread, unread_messages, unread_mentions } => {
[m[32m+                RoomsListUpdate::UpdateNumUnreadMessages {
[m[32m+                    room_id,
[m[32m+                    is_marked_unread,
[m[32m+                    unread_messages,
[m[32m+                    unread_mentions,
[m[32m+                } => {
[m                     if let Some(room) = self.all_joined_rooms.get_mut(&room_id) {
                         room.num_unread_messages = match unread_messages {
                             UnreadMessageCount::Unknown => 0,
Diff in /app/src/home/rooms_list.rs:587:
                         room.num_unread_mentions = unread_mentions;
                         room.is_marked_unread = is_marked_unread;
                     } else {
[31m-                        warning!("Warning: couldn't find room {} to update unread messages count", room_id);
[m[32m+                        warning!(
[m[32m+                            "Warning: couldn't find room {} to update unread messages count",
[m[32m+                            room_id
[m[32m+                        );
[m                     }
                 }
                 RoomsListUpdate::UpdateRoomName { new_room_name } => {
Diff in /app/src/home/rooms_list.rs:594:
[31m-
[m                     // TODO: broadcast a new AppState action to ensure that this room's or space's new name
                     //       gets updated in all of the `SelectedRoom` instances throughout Robrix,
                     //       e.g., the name of the room in the Dock Tab or the StackNav header.
Diff in /app/src/home/rooms_list.rs:604:
                         let should_display = should_display_room!(self, &room_id, room);
                         let (pos_in_list, displayed_list) = if is_direct {
                             (
[31m-                                self.displayed_direct_rooms.iter().position(|r| r == &room_id),
[m[32m+                                self.displayed_direct_rooms
[m[32m+                                    .iter()
[m[32m+                                    .position(|r| r == &room_id),
[m                                 &mut self.displayed_direct_rooms,
                             )
                         } else {
Diff in /app/src/home/rooms_list.rs:611:
                             (
[31m-                                self.displayed_regular_rooms.iter().position(|r| r == &room_id),
[m[32m+                                self.displayed_regular_rooms
[m[32m+                                    .iter()
[m[32m+                                    .position(|r| r == &room_id),
[m                                 &mut self.displayed_regular_rooms,
                             )
                         };
Diff in /app/src/home/rooms_list.rs:627:
                         if let Some(invited_room) = invited_rooms.get_mut(&room_id) {
                             invited_room.room_name_id = new_room_name;
                             let should_display = should_display_room!(self, &room_id, invited_room);
[31m-                            let pos_in_list = self.displayed_invited_rooms.iter()
[m[32m+                            let pos_in_list = self
[m[32m+                                .displayed_invited_rooms
[m[32m+                                .iter()
[m                                 .position(|r| r == &room_id);
                             if should_display {
                                 if pos_in_list.is_none() {
Diff in /app/src/home/rooms_list.rs:637:
                                 pos_in_list.map(|i| self.displayed_invited_rooms.remove(i));
                             }
                         } else {
[31m-                            warning!("Warning: couldn't find room {new_room_name} to update its name.");
[m[32m+                            warning!(
[m[32m+                                "Warning: couldn't find room {new_room_name} to update its name."
[m[32m+                            );
[m                         }
                     }
                 }
Diff in /app/src/home/rooms_list.rs:648:
                             continue;
                         }
                         enqueue_popup_notification(
[31m-                            format!("{} was changed from {} to {}.",
[m[32m+                            format!(
[m[32m+                                "{} was changed from {} to {}.",
[m                                 room.room_name_id,
                                 if room.is_direct { "direct" } else { "regular" },
                                 if is_direct { "direct" } else { "regular" }
Diff in /app/src/home/rooms_list.rs:663:
                         } else {
                             &mut self.displayed_regular_rooms
                         };
[31m-                        list_to_remove_from.iter()
[m[32m+                        list_to_remove_from
[m[32m+                            .iter()
[m                             .position(|r| r == &room_id)
                             .map(|index| list_to_remove_from.remove(index));

Diff in /app/src/home/rooms_list.rs:687:
                     // and then options/buttons for the user to re-join it if desired.

                     if let Some(removed) = self.all_joined_rooms.remove(&room_id) {
[31m-                        log!("Removed room {room_id} from the list of all joined rooms, now has state {new_state:?}");
[m[32m+                        log!(
[m[32m+                            "Removed room {room_id} from the list of all joined rooms, now has state {new_state:?}"
[m[32m+                        );
[m                         let list_to_remove_from = if removed.is_direct {
                             &mut self.displayed_direct_rooms
                         } else {
Diff in /app/src/home/rooms_list.rs:694:
                             &mut self.displayed_regular_rooms
                         };
[31m-                        list_to_remove_from.iter()
[m[32m+                        list_to_remove_from
[m[32m+                            .iter()
[m                             .position(|r| r == &room_id)
                             .map(|index| list_to_remove_from.remove(index));
[31m-                    }
[m[31m-                    else if let Some(_removed) = self.invited_rooms.borrow_mut().remove(&room_id) {
[m[32m+                    } else if let Some(_removed) = self.invited_rooms.borrow_mut().remove(&room_id)
[m[32m+                    {
[m                         log!("Removed room {room_id} from the list of all invited rooms");
[31m-                        self.displayed_invited_rooms.iter()
[m[32m+                        self.displayed_invited_rooms
[m[32m+                            .iter()
[m                             .position(|r| r == &room_id)
                             .map(|index| self.displayed_invited_rooms.remove(index));
                     }
Diff in /app/src/home/rooms_list.rs:720:
                 }
                 RoomsListUpdate::LoadedRooms { max_rooms } => {
                     self.max_known_rooms = max_rooms;
[31m-                },
[m[32m+                }
[m                 RoomsListUpdate::Tags { room_id, new_tags } => {
                     if let Some(room) = self.all_joined_rooms.get_mut(&room_id) {
                         room.tags = new_tags;
Diff in /app/src/home/rooms_list.rs:740:
                         let should_display = should_display_room!(self, &room_id, room);
                         let (pos_in_list, displayed_list) = if is_direct {
                             (
[31m-                                self.displayed_direct_rooms.iter().position(|r| r == &room_id),
[m[32m+                                self.displayed_direct_rooms
[m[32m+                                    .iter()
[m[32m+                                    .position(|r| r == &room_id),
[m                                 &mut self.displayed_direct_rooms,
                             )
                         } else {
Diff in /app/src/home/rooms_list.rs:747:
                             (
[31m-                                self.displayed_regular_rooms.iter().position(|r| r == &room_id),
[m[32m+                                self.displayed_regular_rooms
[m[32m+                                    .iter()
[m[32m+                                    .position(|r| r == &room_id),
[m                                 &mut self.displayed_regular_rooms,
                             )
                         };
Diff in /app/src/home/rooms_list.rs:757:
                             pos_in_list.map(|i| displayed_list.remove(i));
                         }
                     } else {
[31m-                        warning!("Warning: couldn't find room {room_id} to update the tombstone status");
[m[32m+                        warning!(
[m[32m+                            "Warning: couldn't find room {room_id} to update the tombstone status"
[m[32m+                        );
[m                     }
                 }
                 RoomsListUpdate::HideRoom { room_id } => {
Diff in /app/src/home/rooms_list.rs:764:
                     self.hidden_rooms.insert(room_id.clone());
                     // Hiding a regular room is the most common case (e.g., after its successor is joined),
                     // so we check that list first.
[31m-                    if let Some(i) = self.displayed_regular_rooms.iter().position(|r| r == &room_id) {
[m[32m+                    if let Some(i) = self
[m[32m+                        .displayed_regular_rooms
[m[32m+                        .iter()
[m[32m+                        .position(|r| r == &room_id)
[m[32m+                    {
[m                         self.displayed_regular_rooms.remove(i);
[31m-                    }
[m[31m-                    else if let Some(i) = self.displayed_direct_rooms.iter().position(|r| r == &room_id) {
[m[32m+                    } else if let Some(i) = self
[m[32m+                        .displayed_direct_rooms
[m[32m+                        .iter()
[m[32m+                        .position(|r| r == &room_id)
[m[32m+                    {
[m                         self.displayed_direct_rooms.remove(i);
[31m-                    }
[m[31m-                    else if let Some(i) = self.displayed_invited_rooms.iter().position(|r| r == &room_id) {
[m[32m+                    } else if let Some(i) = self
[m[32m+                        .displayed_invited_rooms
[m[32m+                        .iter()
[m[32m+                        .position(|r| r == &room_id)
[m[32m+                    {
[m                         self.displayed_invited_rooms.remove(i);
                     }
                 }
Diff in /app/src/home/rooms_list.rs:779:
                     self.recalculate_indexes();
                     let portal_list = self.view.portal_list(ids!(list));
                     let speed = 50.0;
[31m-                    let portal_list_index = if let Some(regular_index) = self.displayed_regular_rooms.iter().position(|r| r == &room_id) {
[m[32m+                    let portal_list_index = if let Some(regular_index) = self
[m[32m+                        .displayed_regular_rooms
[m[32m+                        .iter()
[m[32m+                        .position(|r| r == &room_id)
[m[32m+                    {
[m                         self.regular_rooms_indexes.first_room_index + regular_index
[31m-                    }
[m[31m-                    else if let Some(direct_index) = self.displayed_direct_rooms.iter().position(|r| r == &room_id) {
[m[32m+                    } else if let Some(direct_index) = self
[m[32m+                        .displayed_direct_rooms
[m[32m+                        .iter()
[m[32m+                        .position(|r| r == &room_id)
[m[32m+                    {
[m                         self.direct_rooms_indexes.first_room_index + direct_index
[31m-                    }
[m[31m-                    else if let Some(invited_index) = self.displayed_invited_rooms.iter().position(|r| r == &room_id) {
[m[32m+                    } else if let Some(invited_index) = self
[m[32m+                        .displayed_invited_rooms
[m[32m+                        .iter()
[m[32m+                        .position(|r| r == &room_id)
[m[32m+                    {
[m                         self.invited_rooms_indexes.first_room_index + invited_index
[31m-                    }
[m[31m-                    else { continue };
[m[32m+                    } else {
[m[32m+                        continue;
[m[32m+                    };
[m                     // Scroll to just above the room to make it more obviously visible.
[31m-                    portal_list.smooth_scroll_to(cx, portal_list_index.saturating_sub(1), speed, Some(15));
[m[32m+                    portal_list.smooth_scroll_to(
[m[32m+                        cx,
[m[32m+                        portal_list_index.saturating_sub(1),
[m[32m+                        speed,
[m[32m+                        Some(15),
[m[32m+                    );
[m                 }
                 RoomsListUpdate::SpaceRequestSender(sender) => {
                     self.space_request_sender = Some(sender);
Diff in /app/src/home/rooms_list.rs:797:
[31m-                    num_updates -= 1;  // this does not require a redraw.
[m[32m+                    num_updates -= 1; // this does not require a redraw.
[m                 }
[31m-                RoomsListUpdate::RoomOrderUpdate(diff) => {
[m[31m-                    match diff {
[m[31m-                        VecDiff::Append { values } => {
[m[31m-                            self.all_known_rooms_order.extend(values);
[m[32m+                RoomsListUpdate::RoomOrderUpdate(diff) => match diff {
[m[32m+                    VecDiff::Append { values } => {
[m[32m+                        self.all_known_rooms_order.extend(values);
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                    VecDiff::Clear => {
[m[32m+                        self.all_known_rooms_order.clear();
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                    VecDiff::PushFront { value } => {
[m[32m+                        self.all_known_rooms_order.push_front(value);
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                    VecDiff::PushBack { value } => {
[m[32m+                        self.all_known_rooms_order.push_back(value);
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                    VecDiff::PopFront => {
[m[32m+                        self.all_known_rooms_order.pop_front();
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                    VecDiff::PopBack => {
[m[32m+                        self.all_known_rooms_order.pop_back();
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                    VecDiff::Insert { index, value } => {
[m[32m+                        if index <= self.all_known_rooms_order.len() {
[m[32m+                            self.all_known_rooms_order.insert(index, value);
[m                             needs_sort = true;
                         }
[31m-                        VecDiff::Clear => {
[m[31m-                            self.all_known_rooms_order.clear();
[m[31m-                            needs_sort = true;
[m[31m-                        }
[m[31m-                        VecDiff::PushFront { value } => {
[m[31m-                            self.all_known_rooms_order.push_front(value);
[m[31m-                            needs_sort = true;
[m[31m-                        }
[m[31m-                        VecDiff::PushBack { value } => {
[m[31m-                            self.all_known_rooms_order.push_back(value);
[m[31m-                            needs_sort = true;
[m[31m-                        }
[m[31m-                        VecDiff::PopFront => {
[m[31m-                            self.all_known_rooms_order.pop_front();
[m[31m-                            needs_sort = true;
[m[31m-                        }
[m[31m-                        VecDiff::PopBack => {
[m[31m-                            self.all_known_rooms_order.pop_back();
[m[31m-                            needs_sort = true;
[m[31m-                        }
[m[31m-                        VecDiff::Insert { index, value } => {
[m[31m-                            if index <= self.all_known_rooms_order.len() {
[m[31m-                                self.all_known_rooms_order.insert(index, value);
[m[32m+                    }
[m[32m+                    VecDiff::Set { index, value } => {
[m[32m+                        if let Some(existing) = self.all_known_rooms_order.get_mut(index) {
[m[32m+                            if *existing != value {
[m[32m+                                *existing = value;
[m                                 needs_sort = true;
                             }
                         }
Diff in /app/src/home/rooms_list.rs:831:
[31m-                        VecDiff::Set { index, value } => {
[m[31m-                            if let Some(existing) = self.all_known_rooms_order.get_mut(index) {
[m[31m-                                if *existing != value {
[m[31m-                                    *existing = value;
[m[31m-                                    needs_sort = true;
[m[31m-                                }
[m[31m-                            }
[m[31m-                        }
[m[31m-                        VecDiff::Remove { index } => {
[m[31m-                            if index < self.all_known_rooms_order.len() {
[m[31m-                                self.all_known_rooms_order.remove(index);
[m[31m-                                needs_sort = true;
[m[31m-                            }
[m[31m-                        }
[m[31m-                        VecDiff::Truncate { length } => {
[m[31m-                            self.all_known_rooms_order.truncate(length);
[m[32m+                    }
[m[32m+                    VecDiff::Remove { index } => {
[m[32m+                        if index < self.all_known_rooms_order.len() {
[m[32m+                            self.all_known_rooms_order.remove(index);
[m                             needs_sort = true;
                         }
                     }
Diff in /app/src/home/rooms_list.rs:850:
[31m-                }
[m[32m+                    VecDiff::Truncate { length } => {
[m[32m+                        self.all_known_rooms_order.truncate(length);
[m[32m+                        needs_sort = true;
[m[32m+                    }
[m[32m+                },
[m             }
         }
         if needs_sort {
Diff in /app/src/home/rooms_list.rs:872:
             + self.displayed_regular_rooms.len();

         let mut text = match (self.display_filter.is_none(), num_rooms) {
[31m-            (true, 0)  => "No joined or invited rooms found".to_string(),
[m[31m-            (true, 1)  => "Loaded 1 room".to_string(),
[m[31m-            (true, n)  => format!("Loaded {n} rooms"),
[m[32m+            (true, 0) => "No joined or invited rooms found".to_string(),
[m[32m+            (true, 1) => "Loaded 1 room".to_string(),
[m[32m+            (true, n) => format!("Loaded {n} rooms"),
[m             (false, 0) => "No matching rooms found".to_string(),
             (false, 1) => "Found 1 matching room".to_string(),
             (false, n) => format!("Found {n} matching rooms"),
Diff in /app/src/home/rooms_list.rs:923:
         self.redraw(cx);
     }

[31m-
[m     /// Generates a tuple of three kinds of displayed rooms (accounting for the current `display_filter`):
     /// 1. displayed_invited_rooms
     /// 2. displayed_regular_rooms
Diff in /app/src/home/rooms_list.rs:931:
     ///
     /// If `self.sort_fn` is `Some`, the rooms are ordered based on that function.
     /// Otherwise, the rooms are ordered based on `self.all_known_rooms_order` (the default).
[31m-    fn generate_displayed_rooms(&self) -> (Vec<OwnedRoomId>,Vec<OwnedRoomId>, Vec<OwnedRoomId>) {
[m[32m+    fn generate_displayed_rooms(&self) -> (Vec<OwnedRoomId>, Vec<OwnedRoomId>, Vec<OwnedRoomId>) {
[m         let mut new_displayed_invited_rooms = Vec::new();
         let mut new_displayed_regular_rooms = Vec::new();
         let mut new_displayed_direct_rooms = Vec::new();
Diff in /app/src/home/rooms_list.rs:949:

         // If a sort function was provided, use it.
         if let Some(sort_fn) = self.sort_fn.as_deref() {
[31m-            let mut filtered_joined_rooms = self.all_joined_rooms.iter()
[m[32m+            let mut filtered_joined_rooms = self
[m[32m+                .all_joined_rooms
[m[32m+                .iter()
[m                 .filter(|&(room_id, room)| should_display_room!(self, room_id, room))
                 .collect::<Vec<_>>();
             filtered_joined_rooms.sort_by(|(_, room_a), (_, room_b)| sort_fn(*room_a, *room_b));
Diff in /app/src/home/rooms_list.rs:957:
                 push_joined_room(room_id, jr)
             }

[31m-            let mut filtered_invited_rooms = invited_rooms_ref.iter()
[m[32m+            let mut filtered_invited_rooms = invited_rooms_ref
[m[32m+                .iter()
[m                 .filter(|&(room_id, room)| should_display_room!(self, room_id, room))
                 .collect::<Vec<_>>();
             filtered_invited_rooms.sort_by(|(_, room_a), (_, room_b)| sort_fn(*room_a, *room_b));
Diff in /app/src/home/rooms_list.rs:980:
             }
         }

[31m-        (new_displayed_invited_rooms, new_displayed_regular_rooms, new_displayed_direct_rooms)
[m[32m+        (
[m[32m+            new_displayed_invited_rooms,
[m[32m+            new_displayed_regular_rooms,
[m[32m+            new_displayed_direct_rooms,
[m[32m+        )
[m     }

     /// Calculates the indexes in the PortalList where the headers and rooms should be drawn.
Diff in /app/src/home/rooms_list.rs:993:
         // Based on the various displayed room lists and is_expanded state of each room header,
         // calculate the indexes in the PortalList where the headers and rooms should be drawn.
         let should_show_invited_rooms_header = !self.displayed_invited_rooms.is_empty();
[31m-        let should_show_direct_rooms_header  = !self.displayed_direct_rooms.is_empty();
[m[32m+        let should_show_direct_rooms_header = !self.displayed_direct_rooms.is_empty();
[m         let should_show_regular_rooms_header = !self.displayed_regular_rooms.is_empty();

         let index_of_invited_rooms_header = should_show_invited_rooms_header.then_some(0);
Diff in /app/src/home/rooms_list.rs:1000:
         let index_of_first_invited_room = should_show_invited_rooms_header as usize;
[31m-        let index_after_invited_rooms = index_of_first_invited_room +
[m[31m-            if self.is_invited_rooms_header_expanded {
[m[32m+        let index_after_invited_rooms = index_of_first_invited_room
[m[32m+            + if self.is_invited_rooms_header_expanded {
[m                 self.displayed_invited_rooms.len()
             } else {
                 0
Diff in /app/src/home/rooms_list.rs:1006:
             };

[31m-        let index_of_direct_rooms_header = should_show_direct_rooms_header
[m[31m-            .then_some(index_after_invited_rooms);
[m[31m-        let index_of_first_direct_room = index_after_invited_rooms +
[m[31m-            should_show_direct_rooms_header as usize;
[m[31m-        let index_after_direct_rooms = index_of_first_direct_room +
[m[31m-            if self.is_direct_rooms_header_expanded {
[m[32m+        let index_of_direct_rooms_header =
[m[32m+            should_show_direct_rooms_header.then_some(index_after_invited_rooms);
[m[32m+        let index_of_first_direct_room =
[m[32m+            index_after_invited_rooms + should_show_direct_rooms_header as usize;
[m[32m+        let index_after_direct_rooms = index_of_first_direct_room
[m[32m+            + if self.is_direct_rooms_header_expanded {
[m                 self.displayed_direct_rooms.len()
             } else {
                 0
Diff in /app/src/home/rooms_list.rs:1017:
             };

[31m-        let index_of_regular_rooms_header = should_show_regular_rooms_header
[m[31m-            .then_some(index_after_direct_rooms);
[m[31m-        let index_of_first_regular_room = index_after_direct_rooms +
[m[31m-            should_show_regular_rooms_header as usize;
[m[31m-        let index_after_regular_rooms = index_of_first_regular_room +
[m[31m-            if self.is_regular_rooms_header_expanded {
[m[32m+        let index_of_regular_rooms_header =
[m[32m+            should_show_regular_rooms_header.then_some(index_after_direct_rooms);
[m[32m+        let index_of_first_regular_room =
[m[32m+            index_after_direct_rooms + should_show_regular_rooms_header as usize;
[m[32m+        let index_after_regular_rooms = index_of_first_regular_room
[m[32m+            + if self.is_regular_rooms_header_expanded {
[m                 self.displayed_regular_rooms.len()
             } else {
                 0
Diff in /app/src/home/rooms_list.rs:1047:
     /// Handle any incoming updates to spaces' room lists and pagination state.
     fn handle_space_room_list_action(&mut self, cx: &mut Cx, action: &SpaceRoomListAction) {
         match action {
[31m-            SpaceRoomListAction::UpdatedChildren { space_id, parent_chain, direct_child_rooms, direct_subspaces } => {
[m[32m+            SpaceRoomListAction::UpdatedChildren {
[m[32m+                space_id,
[m[32m+                parent_chain,
[m[32m+                direct_child_rooms,
[m[32m+                direct_subspaces,
[m[32m+            } => {
[m                 match self.space_map.entry(space_id.clone()) {
                     Entry::Occupied(mut occ) => {
                         let occ_mut = occ.get_mut();
Diff in /app/src/home/rooms_list.rs:1054:
                         occ_mut.parent_chain = parent_chain.clone();
                         occ_mut.direct_child_rooms = Arc::clone(direct_child_rooms);
[31m-                        occ_mut.direct_subspaces   = Arc::clone(direct_subspaces);
[m[32m+                        occ_mut.direct_subspaces = Arc::clone(direct_subspaces);
[m                     }
                     Entry::Vacant(vac) => {
                         vac.insert_entry(SpaceMapValue {
Diff in /app/src/home/rooms_list.rs:1060:
                             is_fully_paginated: false,
                             parent_chain: parent_chain.clone(),
                             direct_child_rooms: Arc::clone(direct_child_rooms),
[31m-                            direct_subspaces:   Arc::clone(direct_subspaces),
[m[32m+                            direct_subspaces: Arc::clone(direct_subspaces),
[m                         });
                     }
                 }
Diff in /app/src/home/rooms_list.rs:1067:
[31m-                if self.selected_space.as_ref().is_some_and(|sel_space|
[m[31m-                    sel_space.room_id() == space_id
[m[31m-                    || parent_chain.contains(sel_space.room_id())
[m[31m-                ) {
[m[32m+                if self.selected_space.as_ref().is_some_and(|sel_space| {
[m[32m+                    sel_space.room_id() == space_id || parent_chain.contains(sel_space.room_id())
[m[32m+                }) {
[m                     self.update_displayed_rooms(cx, false);
                 }
             }
Diff in /app/src/home/rooms_list.rs:1074:
[31m-            SpaceRoomListAction::PaginationState { space_id, parent_chain, state } => {
[m[31m-                let is_fully_paginated = matches!(state, SpaceRoomListPaginationState::Idle { end_reached: true });
[m[32m+            SpaceRoomListAction::PaginationState {
[m[32m+                space_id,
[m[32m+                parent_chain,
[m[32m+                state,
[m[32m+            } => {
[m[32m+                let is_fully_paginated = matches!(
[m[32m+                    state,
[m[32m+                    SpaceRoomListPaginationState::Idle { end_reached: true }
[m[32m+                );
[m                 // Only re-fetch the list of rooms in this space if it was not already fully paginated.
                 let should_fetch_rooms: bool;
                 match self.space_map.entry(space_id.clone()) {
Diff in /app/src/home/rooms_list.rs:1091:
                     }
                 }
                 let Some(sender) = self.space_request_sender.as_ref() else {
[31m-                    error!("BUG: RoomsList: no space request sender was available after pagination state update.");
[m[32m+                    error!(
[m[32m+                        "BUG: RoomsList: no space request sender was available after pagination state update."
[m[32m+                    );
[m                     return;
                 };
                 if should_fetch_rooms {
Diff in /app/src/home/rooms_list.rs:1098:
[31m-                    if sender.send(SpaceRequest::GetChildren {
[m[31m-                        space_id: space_id.clone(),
[m[31m-                        parent_chain: parent_chain.clone(),
[m[31m-                    }).is_err() {
[m[31m-                        error!("BUG: RoomsList: failed to send GetRooms request for space {space_id}.");
[m[32m+                    if sender
[m[32m+                        .send(SpaceRequest::GetChildren {
[m[32m+                            space_id: space_id.clone(),
[m[32m+                            parent_chain: parent_chain.clone(),
[m[32m+                        })
[m[32m+                        .is_err()
[m[32m+                    {
[m[32m+                        error!(
[m[32m+                            "BUG: RoomsList: failed to send GetRooms request for space {space_id}."
[m[32m+                        );
[m                     }
                 }

Diff in /app/src/home/rooms_list.rs:1109:
                 // all of its children, such that we can see if any of them are subspaces,
                 // and then we'll paginate those as well.
                 if !is_fully_paginated {
[31m-                    if sender.send(SpaceRequest::PaginateSpaceRoomList {
[m[31m-                        space_id: space_id.clone(),
[m[31m-                        parent_chain: parent_chain.clone(),
[m[31m-                    }).is_err() {
[m[31m-                        error!("BUG: RoomsList: failed to send pagination request for space {space_id}.");
[m[32m+                    if sender
[m[32m+                        .send(SpaceRequest::PaginateSpaceRoomList {
[m[32m+                            space_id: space_id.clone(),
[m[32m+                            parent_chain: parent_chain.clone(),
[m[32m+                        })
[m[32m+                        .is_err()
[m[32m+                    {
[m[32m+                        error!(
[m[32m+                            "BUG: RoomsList: failed to send pagination request for space {space_id}."
[m[32m+                        );
[m                     }
                 }
             }
Diff in /app/src/home/rooms_list.rs:1125:
                     None,
                 );
             }
[31m-            SpaceRoomListAction::LeaveSpaceResult { space_name_id, result } => match result {
[m[32m+            SpaceRoomListAction::LeaveSpaceResult {
[m[32m+                space_name_id,
[m[32m+                result,
[m[32m+            } => match result {
[m                 Ok(()) => {
                     enqueue_popup_notification(
                         format!("Successfully left space \"{}\".", space_name_id),
Diff in /app/src/home/rooms_list.rs:1133:
                         Some(4.0),
                     );
                     // If the space we left was the currently-selected one, go back to the main Home view.
[31m-                    if self.selected_space.as_ref().is_some_and(|s| s.room_id() == space_name_id.room_id()) {
[m[32m+                    if self
[m[32m+                        .selected_space
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|s| s.room_id() == space_name_id.room_id())
[m[32m+                    {
[m                         cx.action(NavigationBarAction::GoToHome);
                     }
                 }
Diff in /app/src/home/rooms_list.rs:1148:
             },
             // Details-related space actions are handled by SpaceLobbyScreen, not RoomsList.
             SpaceRoomListAction::DetailedChildren { .. }
[31m-            | SpaceRoomListAction::TopLevelSpaceDetails(_) => { }
[m[32m+            | SpaceRoomListAction::TopLevelSpaceDetails(_) => {}
[m         }
     }

Diff in /app/src/home/rooms_list.rs:1155:
     /// Returns whether the given target room or space is indirectly within the given parent space.
     ///
     /// This will recursively search all nested spaces within the given `parent_space`.
[31m-    fn is_room_indirectly_in_space(&self, parent_space: &OwnedRoomId, target: &OwnedRoomId) -> bool {
[m[32m+    fn is_room_indirectly_in_space(
[m[32m+        &self,
[m[32m+        parent_space: &OwnedRoomId,
[m[32m+        target: &OwnedRoomId,
[m[32m+    ) -> bool {
[m         if let Some(smv) = self.space_map.get(parent_space) {
             if smv.direct_child_rooms.contains(target) {
                 return true;
Diff in /app/src/home/rooms_list.rs:1183:
         let props = RoomsListScopeProps {
             was_scrolling: self.view.portal_list(ids!(list)).was_scrolling(),
         };
[31m-        let rooms_list_actions = cx.capture_actions(
[m[31m-            |cx| self.view.handle_event(cx, event, &mut Scope::with_props(&props))
[m[31m-        );
[m[32m+        let rooms_list_actions = cx.capture_actions(|cx| {
[m[32m+            self.view
[m[32m+                .handle_event(cx, event, &mut Scope::with_props(&props))
[m[32m+        });
[m         for action in rooms_list_actions {
             // Handle a regular room (joined or invited) being clicked.
[31m-            if let RoomsListEntryAction::PrimaryClicked(room_id) = action.as_widget_action().cast() {
[m[32m+            if let RoomsListEntryAction::PrimaryClicked(room_id) = action.as_widget_action().cast()
[m[32m+            {
[m                 let new_selected_room = if let Some(jr) = self.all_joined_rooms.get(&room_id) {
                     SelectedRoom::JoinedRoom {
                         room_name_id: jr.room_name_id.clone(),
Diff in /app/src/home/rooms_list.rs:1211:
                 self.redraw(cx);
             }
             // Handle a room being right-clicked or long-pressed by opening the room context menu.
[31m-            else if let RoomsListEntryAction::SecondaryClicked(room_id, pos) = action.as_widget_action().cast() {
[m[32m+            else if let RoomsListEntryAction::SecondaryClicked(room_id, pos) =
[m[32m+                action.as_widget_action().cast()
[m[32m+            {
[m                 // Determine details for the context menu
                 let Some(jr) = self.all_joined_rooms.get(&room_id) else {
                     error!("BUG: couldn't find right-clicked room details for room {room_id}");
Diff in /app/src/home/rooms_list.rs:1231:
             }
             // Handle the space lobby being clicked.
             else if let Some(SpaceLobbyAction::SpaceLobbyEntryClicked) = action.downcast_ref() {
[31m-                let Some(space_name_id) = self.selected_space.clone() else { continue };
[m[32m+                let Some(space_name_id) = self.selected_space.clone() else {
[m[32m+                    continue;
[m[32m+                };
[m                 self.current_active_room = Some(space_name_id.room_id().clone());
                 let new_selected_space = SelectedRoom::Space { space_name_id };
                 cx.widget_action(
Diff in /app/src/home/rooms_list.rs:1242:
                 self.redraw(cx);
             }
             // Handle a collapsible header being clicked.
[31m-            else if let CollapsibleHeaderAction::Toggled { category } = action.as_widget_action().cast() {
[m[32m+            else if let CollapsibleHeaderAction::Toggled { category } =
[m[32m+                action.as_widget_action().cast()
[m[32m+            {
[m                 match category {
                     HeaderCategory::Invites => {
[31m-                        self.is_invited_rooms_header_expanded = !self.is_invited_rooms_header_expanded;
[m[32m+                        self.is_invited_rooms_header_expanded =
[m[32m+                            !self.is_invited_rooms_header_expanded;
[m                     }
                     HeaderCategory::RegularRooms => {
[31m-                        self.is_regular_rooms_header_expanded = !self.is_regular_rooms_header_expanded;
[m[32m+                        self.is_regular_rooms_header_expanded =
[m[32m+                            !self.is_regular_rooms_header_expanded;
[m                     }
                     HeaderCategory::DirectRooms => {
                         self.is_direct_rooms_header_expanded =
Diff in /app/src/home/rooms_list.rs:1273:
                 if let Some(NavigationBarAction::TabSelected(tab)) = action.downcast_ref() {
                     match tab {
                         SelectedTab::Space { space_name_id } => {
[31m-                            if self.selected_space.as_ref().is_some_and(|s| s.room_id() == space_name_id.room_id()) {
[m[32m+                            if self
[m[32m+                                .selected_space
[m[32m+                                .as_ref()
[m[32m+                                .is_some_and(|s| s.room_id() == space_name_id.room_id())
[m[32m+                            {
[m                                 continue;
                             }

Diff in /app/src/home/rooms_list.rs:1280:
                             self.selected_space = Some(space_name_id.clone());
[31m-                            self.view.space_lobby_entry(ids!(space_lobby_entry)).set_visible(cx, true);
[m[32m+                            self.view
[m[32m+                                .space_lobby_entry(ids!(space_lobby_entry))
[m[32m+                                .set_visible(cx, true);
[m
                             // If we don't have the full list of children in this newly-selected space, then fetch it.
[31m-                            let (is_fully_paginated, parent_chain) = self.space_map
[m[32m+                            let (is_fully_paginated, parent_chain) = self
[m[32m+                                .space_map
[m                                 .get(space_name_id.room_id())
                                 .map(|smv| (smv.is_fully_paginated, smv.parent_chain.clone()))
                                 .unwrap_or_default();
Diff in /app/src/home/rooms_list.rs:1288:
                             if !is_fully_paginated {
                                 let Some(sender) = self.space_request_sender.as_ref() else {
[31m-                                    error!("BUG: RoomsList: no space request sender was available.");
[m[32m+                                    error!(
[m[32m+                                        "BUG: RoomsList: no space request sender was available."
[m[32m+                                    );
[m                                     continue;
                                 };

Diff in /app/src/home/rooms_list.rs:1294:
[31m-                                if sender.send(SpaceRequest::SubscribeToSpaceRoomList {
[m[31m-                                    space_id: space_name_id.room_id().clone(),
[m[31m-                                    parent_chain: parent_chain.clone(),
[m[31m-                                }).is_err() {
[m[31m-                                    error!("BUG: RoomsList: failed to send SubscribeToSpaceRoomList request for space {space_name_id}.");
[m[32m+                                if sender
[m[32m+                                    .send(SpaceRequest::SubscribeToSpaceRoomList {
[m[32m+                                        space_id: space_name_id.room_id().clone(),
[m[32m+                                        parent_chain: parent_chain.clone(),
[m[32m+                                    })
[m[32m+                                    .is_err()
[m[32m+                                {
[m[32m+                                    error!(
[m[32m+                                        "BUG: RoomsList: failed to send SubscribeToSpaceRoomList request for space {space_name_id}."
[m[32m+                                    );
[m                                 }
[31m-                                if sender.send(SpaceRequest::PaginateSpaceRoomList {
[m[31m-                                    space_id: space_name_id.room_id().clone(),
[m[31m-                                    parent_chain: parent_chain.clone(),
[m[31m-                                }).is_err() {
[m[31m-                                    error!("BUG: RoomsList: failed to send PaginateSpaceRoomList request for space {space_name_id}.");
[m[32m+                                if sender
[m[32m+                                    .send(SpaceRequest::PaginateSpaceRoomList {
[m[32m+                                        space_id: space_name_id.room_id().clone(),
[m[32m+                                        parent_chain: parent_chain.clone(),
[m[32m+                                    })
[m[32m+                                    .is_err()
[m[32m+                                {
[m[32m+                                    error!(
[m[32m+                                        "BUG: RoomsList: failed to send PaginateSpaceRoomList request for space {space_name_id}."
[m[32m+                                    );
[m                                 }
[31m-                                if sender.send(SpaceRequest::GetChildren {
[m[31m-                                    space_id: space_name_id.room_id().clone(),
[m[31m-                                    parent_chain,
[m[31m-                                }).is_err() {
[m[31m-                                    error!("BUG: RoomsList: failed to send GetRooms request for space {space_name_id}.");
[m[32m+                                if sender
[m[32m+                                    .send(SpaceRequest::GetChildren {
[m[32m+                                        space_id: space_name_id.room_id().clone(),
[m[32m+                                        parent_chain,
[m[32m+                                    })
[m[32m+                                    .is_err()
[m[32m+                                {
[m[32m+                                    error!(
[m[32m+                                        "BUG: RoomsList: failed to send GetRooms request for space {space_name_id}."
[m[32m+                                    );
[m                                 }
                             }
                         }
Diff in /app/src/home/rooms_list.rs:1314:
                         _ => {
                             self.selected_space = None;
[31m-                            self.view.space_lobby_entry(ids!(space_lobby_entry)).set_visible(cx, false);
[m[32m+                            self.view
[m[32m+                                .space_lobby_entry(ids!(space_lobby_entry))
[m[32m+                                .set_visible(cx, false);
[m                         }
                     }

Diff in /app/src/home/rooms_list.rs:1361:
     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         let app_state = scope.data.get_mut::<AppState>().unwrap();
         // Update the currently-selected room from the AppState data.
[31m-        self.current_active_room = app_state.selected_room.as_ref()
[m[32m+        self.current_active_room = app_state
[m[32m+            .selected_room
[m[32m+            .as_ref()
[m             .map(|sel_room| sel_room.room_id().clone());

         // Based on the various displayed room lists and is_expanded state of each room header,
Diff in /app/src/home/rooms_list.rs:1373:
         let total_count = status_label_id + 1;

         let get_invited_room_id = |portal_list_index: usize| {
[31m-            portal_list_index.checked_sub(self.invited_rooms_indexes.first_room_index)
[m[31m-                .and_then(|index| self.is_invited_rooms_header_expanded
[m[31m-                    .then(|| self.displayed_invited_rooms.get(index))
[m[31m-                )
[m[32m+            portal_list_index
[m[32m+                .checked_sub(self.invited_rooms_indexes.first_room_index)
[m[32m+                .and_then(|index| {
[m[32m+                    self.is_invited_rooms_header_expanded
[m[32m+                        .then(|| self.displayed_invited_rooms.get(index))
[m[32m+                })
[m                 .flatten()
         };

Diff in /app/src/home/rooms_list.rs:1383:
         let get_direct_room_id = |portal_list_index: usize| {
[31m-            portal_list_index.checked_sub(self.direct_rooms_indexes.first_room_index)
[m[31m-                .and_then(|index| self.is_direct_rooms_header_expanded
[m[31m-                    .then(|| self.displayed_direct_rooms.get(index))
[m[31m-                )
[m[32m+            portal_list_index
[m[32m+                .checked_sub(self.direct_rooms_indexes.first_room_index)
[m[32m+                .and_then(|index| {
[m[32m+                    self.is_direct_rooms_header_expanded
[m[32m+                        .then(|| self.displayed_direct_rooms.get(index))
[m[32m+                })
[m                 .flatten()
         };
         let get_regular_room_id = |portal_list_index: usize| {
Diff in /app/src/home/rooms_list.rs:1391:
[31m-            portal_list_index.checked_sub(self.regular_rooms_indexes.first_room_index)
[m[31m-                .and_then(|index| self.is_regular_rooms_header_expanded
[m[31m-                    .then(|| self.displayed_regular_rooms.get(index))
[m[31m-                )
[m[32m+            portal_list_index
[m[32m+                .checked_sub(self.regular_rooms_indexes.first_room_index)
[m[32m+                .and_then(|index| {
[m[32m+                    self.is_regular_rooms_header_expanded
[m[32m+                        .then(|| self.displayed_regular_rooms.get(index))
[m[32m+                })
[m                 .flatten()
         };

Diff in /app/src/home/rooms_list.rs:1403:
                 portal_list_ref.set_first_id_and_scroll(status_label_id, 0.0);
             }
             // We only care about drawing the portal list.
[31m-            let Some(mut list) = portal_list_ref.borrow_mut() else { continue };
[m[32m+            let Some(mut list) = portal_list_ref.borrow_mut() else {
[m[32m+                continue;
[m[32m+            };
[m
             list.set_item_range(cx, 0, total_count);

Diff in /app/src/home/rooms_list.rs:1419:
                         self.displayed_invited_rooms.len() as u64,
                     );
                     item.draw_all(cx, &mut scope);
[31m-                }
[m[31m-                else if let Some(invited_room_id) = get_invited_room_id(portal_list_index) {
[m[32m+                } else if let Some(invited_room_id) = get_invited_room_id(portal_list_index) {
[m                     let mut invited_rooms_mut = self.invited_rooms.borrow_mut();
                     if let Some(invited_room) = invited_rooms_mut.get_mut(invited_room_id) {
                         let item = list.item(cx, portal_list_index, id!(rooms_list_entry));
Diff in /app/src/home/rooms_list.rs:1433:
                         list.item(cx, portal_list_index, id!(empty))
                             .draw_all(cx, &mut scope);
                     }
[31m-                }
[m[31m-                else if self.direct_rooms_indexes.header_index == Some(portal_list_index) {
[m[32m+                } else if self.direct_rooms_indexes.header_index == Some(portal_list_index) {
[m                     let item = list.item(cx, portal_list_index, id!(collapsible_header));
                     item.as_collapsible_header().set_details(
                         cx,
Diff in /app/src/home/rooms_list.rs:1445:
                         // NOTE: this might be really slow, so we should maintain a running total of mentions in this struct
                     );
                     item.draw_all(cx, &mut scope);
[31m-                }
[m[31m-                else if let Some(direct_room_id) = get_direct_room_id(portal_list_index) {
[m[32m+                } else if let Some(direct_room_id) = get_direct_room_id(portal_list_index) {
[m                     if let Some(direct_room) = self.all_joined_rooms.get_mut(direct_room_id) {
                         let item = list.item(cx, portal_list_index, id!(rooms_list_entry));
                         direct_room.is_selected =
Diff in /app/src/home/rooms_list.rs:1468:
                         list.item(cx, portal_list_index, id!(empty))
                             .draw_all(cx, &mut scope);
                     }
[31m-                }
[m[31m-                else if self.regular_rooms_indexes.header_index == Some(portal_list_index) {
[m[32m+                } else if self.regular_rooms_indexes.header_index == Some(portal_list_index) {
[m                     let item = list.item(cx, portal_list_index, id!(collapsible_header));
                     item.as_collapsible_header().set_details(
                         cx,
Diff in /app/src/home/rooms_list.rs:1480:
                         // NOTE: this might be really slow, so we should maintain a running total of mentions in this struct
                     );
                     item.draw_all(cx, &mut scope);
[31m-                }
[m[31m-                else if let Some(regular_room_id) = get_regular_room_id(portal_list_index) {
[m[32m+                } else if let Some(regular_room_id) = get_regular_room_id(portal_list_index) {
[m                     if let Some(regular_room) = self.all_joined_rooms.get_mut(regular_room_id) {
                         let item = list.item(cx, portal_list_index, id!(rooms_list_entry));
                         regular_room.is_selected =
Diff in /app/src/home/rooms_list.rs:1500:
                         scope = Scope::with_props(&*regular_room);
                         item.draw_all(cx, &mut scope);
                     } else {
[31m-                        list.item(cx, portal_list_index, id!(empty)).draw_all(cx, &mut scope);
[m[32m+                        list.item(cx, portal_list_index, id!(empty))
[m[32m+                            .draw_all(cx, &mut scope);
[m                     }
                 }
                 // Draw the status label as the bottom entry.
Diff in /app/src/home/rooms_list.rs:1507:
                 else if portal_list_index == status_label_id {
                     let item = list.item(cx, portal_list_index, id!(status_label));
[31m-                    item.as_view().apply_over(cx, live!{
[m[31m-                        height: Fit,
[m[31m-                        label = { text: (&self.status) }
[m[31m-                    });
[m[32m+                    item.as_view().apply_over(
[m[32m+                        cx,
[m[32m+                        live! {
[m[32m+                            height: Fit,
[m[32m+                            label = { text: (&self.status) }
[m[32m+                        },
[m[32m+                    );
[m                     item.draw_all(cx, &mut scope);
                 }
                 // Draw a filler entry to take up space at the bottom of the portal list.
Diff in /app/src/home/rooms_list.rs:1527:
 impl RoomsListRef {
     /// See [`RoomsList::all_rooms_loaded()`].
     pub fn all_rooms_loaded(&self) -> bool {
[31m-        let Some(inner) = self.borrow() else { return false; };
[m[32m+        let Some(inner) = self.borrow() else {
[m[32m+            return false;
[m[32m+        };
[m         inner.all_rooms_loaded()
     }

Diff in /app/src/home/rooms_list.rs:1544:
     /// Returns the name of the given room, if it is known and loaded.
     pub fn get_room_name(&self, room_id: &OwnedRoomId) -> Option<RoomNameId> {
         let inner = self.borrow()?;
[31m-        inner.all_joined_rooms
[m[32m+        inner
[m[32m+            .all_joined_rooms
[m             .get(room_id)
             .map(|jr| jr.room_name_id.clone())
[31m-            .or_else(||
[m[31m-                inner.invited_rooms.borrow()
[m[32m+            .or_else(|| {
[m[32m+                inner
[m[32m+                    .invited_rooms
[m[32m+                    .borrow()
[m                     .get(room_id)
                     .map(|ir| ir.room_name_id.clone())
[31m-            )
[m[32m+            })
[m     }

     /// Returns the currently-selected space (the one selected in the SpacesBar).
Diff in /app/src/home/rooms_list.rs:1561:

     /// Same as [`Self::get_selected_space()`], but only returns the space ID.
     pub fn get_selected_space_id(&self) -> Option<OwnedRoomId> {
[31m-        self.borrow()?.selected_space.as_ref().map(|ss| ss.room_id().clone())
[m[32m+        self.borrow()?
[m[32m+            .selected_space
[m[32m+            .as_ref()
[m[32m+            .map(|ss| ss.room_id().clone())
[m     }

     /// Returns a clone of the space request sender channel, if available.
Diff in /app/src/home/rooms_list_entry.rs:2:
 use matrix_sdk::ruma::OwnedRoomId;

 use crate::{
[31m-    room::FetchedRoomAvatar, shared::{
[m[31m-        avatar::AvatarWidgetExt,
[m[31m-        html_or_plaintext::HtmlOrPlaintextWidgetExt, unread_badge::UnreadBadgeWidgetExt as _,
[m[31m-    }, utils::{self, relative_format}
[m[32m+    room::FetchedRoomAvatar,
[m[32m+    shared::{
[m[32m+        avatar::AvatarWidgetExt, html_or_plaintext::HtmlOrPlaintextWidgetExt,
[m[32m+        unread_badge::UnreadBadgeWidgetExt as _,
[m[32m+    },
[m[32m+    utils::{self, relative_format},
[m };

 use super::rooms_list::{InvitedRoomInfo, InviterInfo, JoinedRoomInfo, RoomsListScopeProps};
Diff in /app/src/home/rooms_list_entry.rs:211:
 /// An entry in the rooms list.
 #[derive(Live, Widget)]
 pub struct RoomsListEntry {
[31m-    #[deref] view: View,
[m[31m-    #[rust] room_id: Option<OwnedRoomId>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    room_id: Option<OwnedRoomId>,
[m }

 /// Widget actions that are emitted by a RoomsListEntry.
Diff in /app/src/home/rooms_list_entry.rs:231:
         self.view
             .adaptive_view(ids!(adaptive_preview))
             .set_variant_selector(|_cx, parent_size| match parent_size.x {
[31m-                width if width <= 70.0  => id!(OnlyIcon),
[m[32m+                width if width <= 70.0 => id!(OnlyIcon),
[m                 width if width <= 200.0 => id!(IconAndName),
                 _ => id!(FullPreview),
             });
Diff in /app/src/home/rooms_list_entry.rs:266:
                         RoomsListEntryAction::SecondaryClicked(room_id.clone(), fe.abs),
                     );
                 }
[31m-                Hit::FingerUp(fe) if !rooms_list_props.was_scrolling && fe.is_over && fe.is_primary_hit() && fe.was_tap() => {
[m[31m-                    cx.widget_action(uid, &scope.path, RoomsListEntryAction::PrimaryClicked(room_id.clone()));
[m[32m+                Hit::FingerUp(fe)
[m[32m+                    if !rooms_list_props.was_scrolling
[m[32m+                        && fe.is_over
[m[32m+                        && fe.is_primary_hit()
[m[32m+                        && fe.was_tap() =>
[m[32m+                {
[m[32m+                    cx.widget_action(
[m[32m+                        uid,
[m[32m+                        &scope.path,
[m[32m+                        RoomsListEntryAction::PrimaryClicked(room_id.clone()),
[m[32m+                    );
[m                 }
[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }

Diff in /app/src/home/rooms_list_entry.rs:279:
     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         if let Some(room_info) = scope.props.get::<JoinedRoomInfo>() {
             self.room_id = Some(room_info.room_name_id.room_id().clone());
[31m-        }
[m[31m-        else if let Some(room_info) = scope.props.get::<InvitedRoomInfo>() {
[m[32m+        } else if let Some(room_info) = scope.props.get::<InvitedRoomInfo>() {
[m             self.room_id = Some(room_info.room_name_id.room_id().clone());
         }

Diff in /app/src/home/rooms_list_entry.rs:290:

 #[derive(Live, LiveHook, Widget)]
 pub struct RoomsListEntryContent {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 impl Widget for RoomsListEntryContent {
Diff in /app/src/home/rooms_list_entry.rs:311:

 impl RoomsListEntryContent {
     /// Populates this RoomsListEntry with info about a joined room.
[31m-    pub fn draw_joined_room(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        room_info: &JoinedRoomInfo,
[m[31m-    ) {
[m[31m-        self.view.label(ids!(room_name)).set_text(cx, &room_info.room_name_id.to_string());
[m[32m+    pub fn draw_joined_room(&mut self, cx: &mut Cx, room_info: &JoinedRoomInfo) {
[m[32m+        self.view
[m[32m+            .label(ids!(room_name))
[m[32m+            .set_text(cx, &room_info.room_name_id.to_string());
[m         if let Some((ts, msg)) = room_info.latest.as_ref() {
             if let Some(human_readable_date) = relative_format(*ts) {
                 self.view
Diff in /app/src/home/rooms_list_entry.rs:335:
         );
         self.draw_common(cx, &room_info.room_avatar, room_info.is_selected);
         // Show tombstone icon if the room is tombstoned
[31m-        self.view.view(ids!(tombstone_icon)).set_visible(cx, room_info.is_tombstoned);
[m[32m+        self.view
[m[32m+            .view(ids!(tombstone_icon))
[m[32m+            .set_visible(cx, room_info.is_tombstoned);
[m     }

     /// Populates this RoomsListEntry with info about an invited room.
Diff in /app/src/home/rooms_list_entry.rs:342:
[31m-    pub fn draw_invited_room(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        room_info: &InvitedRoomInfo,
[m[31m-    ) {
[m[31m-        self.view.label(ids!(room_name)).set_text(cx, &room_info.room_name_id.to_string());
[m[32m+    pub fn draw_invited_room(&mut self, cx: &mut Cx, room_info: &InvitedRoomInfo) {
[m[32m+        self.view
[m[32m+            .label(ids!(room_name))
[m[32m+            .set_text(cx, &room_info.room_name_id.to_string());
[m         // Hide the timestamp field, and use the latest message field to show the inviter.
         self.view.label(ids!(timestamp)).set_text(cx, "");
         let inviter_string = match &room_info.inviter_info {
Diff in /app/src/home/rooms_list_entry.rs:351:
[31m-            Some(InviterInfo { user_id, display_name: Some(dn), .. }) => format!("Invited by <b>{dn}</b> ({user_id})"),
[m[32m+            Some(InviterInfo {
[m[32m+                user_id,
[m[32m+                display_name: Some(dn),
[m[32m+                ..
[m[32m+            }) => format!("Invited by <b>{dn}</b> ({user_id})"),
[m             Some(InviterInfo { user_id, .. }) => format!("Invited by {user_id}"),
             None => String::from("You were invited"),
         };
Diff in /app/src/home/rooms_list_entry.rs:355:
[31m-        self.view.html_or_plaintext(ids!(latest_message)).show_html(cx, &inviter_string);
[m[32m+        self.view
[m[32m+            .html_or_plaintext(ids!(latest_message))
[m[32m+            .show_html(cx, &inviter_string);
[m
         match room_info.room_avatar {
             FetchedRoomAvatar::Text(ref text) => {
Diff in /app/src/home/rooms_list_entry.rs:359:
[31m-                self.view.avatar(ids!(avatar)).show_text(cx, None, None, text);
[m[32m+                self.view
[m[32m+                    .avatar(ids!(avatar))
[m[32m+                    .show_text(cx, None, None, text);
[m             }
             FetchedRoomAvatar::Image(ref img_bytes) => {
                 let _ = self.view.avatar(ids!(avatar)).show_image(
Diff in /app/src/home/rooms_list_entry.rs:375:
     }

     /// Populates the widgets common to both invited and joined rooms list entries.
[31m-    pub fn draw_common(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        room_avatar: &FetchedRoomAvatar,
[m[31m-        is_selected: bool,
[m[31m-    ) {
[m[32m+    pub fn draw_common(&mut self, cx: &mut Cx, room_avatar: &FetchedRoomAvatar, is_selected: bool) {
[m         match room_avatar {
             FetchedRoomAvatar::Text(text) => {
[31m-                self.view.avatar(ids!(avatar)).show_text(cx, None, None, text);
[m[32m+                self.view
[m[32m+                    .avatar(ids!(avatar))
[m[32m+                    .show_text(cx, None, None, text);
[m             }
             FetchedRoomAvatar::Image(img_bytes) => {
                 let _ = self.view.avatar(ids!(avatar)).show_image(
Diff in /app/src/home/rooms_list_entry.rs:460:
         }

         if !self.view.html_or_plaintext(ids!(latest_message)).is_empty() {
[31m-            self.view.html_or_plaintext(ids!(latest_message)).apply_over(
[m[31m-                cx,
[m[31m-                live!(
[m[31m-                html_view = {
[m[31m-                    html = {
[m[31m-                        font_color: (message_text_color),
[m[31m-                        draw_normal:      { color: (message_text_color) },
[m[31m-                        draw_italic:      { color: (message_text_color) },
[m[31m-                        draw_bold:        { color: (message_text_color) },
[m[31m-                        draw_bold_italic: { color: (message_text_color) },
[m[31m-                        draw_block: {
[m[31m-                            quote_bg_color: (code_bg_color),
[m[31m-                            code_color: (code_bg_color),
[m[32m+            self.view
[m[32m+                .html_or_plaintext(ids!(latest_message))
[m[32m+                .apply_over(
[m[32m+                    cx,
[m[32m+                    live!(
[m[32m+                    html_view = {
[m[32m+                        html = {
[m[32m+                            font_color: (message_text_color),
[m[32m+                            draw_normal:      { color: (message_text_color) },
[m[32m+                            draw_italic:      { color: (message_text_color) },
[m[32m+                            draw_bold:        { color: (message_text_color) },
[m[32m+                            draw_bold_italic: { color: (message_text_color) },
[m[32m+                            draw_block: {
[m[32m+                                quote_bg_color: (code_bg_color),
[m[32m+                                code_color: (code_bg_color),
[m[32m+                            }
[m                         }
                     }
[31m-                }
[m[31m-                plaintext_view = {
[m[31m-                    pt_label = {
[m[31m-                        draw_text: {
[m[31m-                            color: (message_text_color)
[m[32m+                    plaintext_view = {
[m[32m+                        pt_label = {
[m[32m+                            draw_text: {
[m[32m+                                color: (message_text_color)
[m[32m+                            }
[m                         }
                     }
[31m-                }
[m[31m-                ),
[m[31m-            );
[m[32m+                    ),
[m[32m+                );
[m         }
     }
 }
Diff in /app/src/home/rooms_list_header.rs:1:
 //! The RoomsListHeader contains the title label and loading spinner for rooms list.
 //!
[31m-//! This widget is designed to be reused across both Desktop and Mobile variants
[m[32m+//! This widget is designed to be reused across both Desktop and Mobile variants
[m //! of the RoomsSideBar to avoid code duplication.

 use std::mem::discriminant;
Diff in /app/src/home/rooms_list_header.rs:8:
 use makepad_widgets::*;
 use matrix_sdk_ui::sync_service::State;

[31m-use crate::{home::navigation_tab_bar::{NavigationBarAction, SelectedTab}, shared::{image_viewer::{ImageViewerAction, ImageViewerError, LoadState}, popup_list::{PopupKind, enqueue_popup_notification}}};
[m[32m+use crate::{
[m[32m+    home::navigation_tab_bar::{NavigationBarAction, SelectedTab},
[m[32m+    shared::{
[m[32m+        image_viewer::{ImageViewerAction, ImageViewerError, LoadState},
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    },
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/home/rooms_list_header.rs:84:

 #[derive(Live, LiveHook, Widget)]
 pub struct RoomsListHeader {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
[31m-    #[rust(State::Idle)] sync_state: State,
[m[32m+    #[rust(State::Idle)]
[m[32m+    sync_state: State,
[m }

 impl Widget for RoomsListHeader {
Diff in /app/src/home/rooms_list_header.rs:100:
                         if matches!(self.sync_state, State::Offline) {
                             continue;
                         }
[31m-                        self.view.view(ids!(loading_spinner)).set_visible(cx, *is_syncing);
[m[31m-                        self.view.view(ids!(synced_icon)).set_visible(cx, !*is_syncing);
[m[32m+                        self.view
[m[32m+                            .view(ids!(loading_spinner))
[m[32m+                            .set_visible(cx, *is_syncing);
[m[32m+                        self.view
[m[32m+                            .view(ids!(synced_icon))
[m[32m+                            .set_visible(cx, !*is_syncing);
[m                         self.view.view(ids!(offline_icon)).set_visible(cx, false);
                         self.redraw(cx);
                         continue;
Diff in /app/src/home/rooms_list_header.rs:120:
                                 None,
                             );
                             // Since there is no timeout for fetching media, send an action to ImageViewer when syncing is offline.
[31m-                            cx.action(ImageViewerAction::Show(LoadState::Error(ImageViewerError::Offline)));
[m[32m+                            cx.action(ImageViewerAction::Show(LoadState::Error(
[m[32m+                                ImageViewerError::Offline,
[m[32m+                            )));
[m                         }
                         self.sync_state = new_state.clone();
                         self.redraw(cx);
Diff in /app/src/home/rooms_sidebar.rs:56:
         Mobile = <View> {
             width: Fill, height: Fill
             flow: Down,
[31m-
[m[32m+
[m             <RoundedShadowView> {
                 width: Fill, height: Fit
                 padding: {top: 15, left: 15, right: 15, bottom: 10}
Diff in /app/src/home/rooms_sidebar.rs:83:
                     height: 39,
                     flow: Right
                     padding: {top: 2, bottom: 2}
[31m-                    spacing: 5
[m[32m+                    spacing: 5
[m                     align: {y: 0.5}

                     <CachedWidget> {
Diff in /app/src/home/rooms_sidebar.rs:114:
 ///   (because the search bar is at the top of the HomeScreen).
 #[derive(Live, Widget)]
 pub struct RoomsSideBar {
[31m-    #[deref] view: AdaptiveView,
[m[32m+    #[deref]
[m[32m+    view: AdaptiveView,
[m }

 impl LiveHook for RoomsSideBar {
Diff in /app/src/home/rooms_sidebar.rs:134:
         self.view.draw_walk(cx, scope, walk)
     }
 }
[31m-
[m
Diff in /app/src/home/search_messages.rs:1:
[31m-
[m //! UI widgets for searching messages in one or more rooms.

 use makepad_widgets::*;
Diff in /app/src/home/search_messages.rs:40:
         }
     }

[31m-
[m[32m+
[m }

 #[derive(Live, LiveHook, Widget)]
Diff in /app/src/home/search_messages.rs:47:
 pub struct SearchMessagesButton {
[31m-    #[deref] button: Button,
[m[32m+    #[deref]
[m[32m+    button: Button,
[m }

 impl Widget for SearchMessagesButton {
Diff in /app/src/home/space_lobby.rs:19:
 use crate::{
     app::AppStateAction,
     avatar_cache::{self, AvatarCacheEntry},
[31m-    home::{
[m[31m-        invite_modal::InviteModalAction,
[m[31m-        rooms_list::RoomsListRef,
[m[31m-    },
[m[32m+    home::{invite_modal::InviteModalAction, rooms_list::RoomsListRef},
[m     join_leave_room_modal::{JoinLeaveModalKind, JoinLeaveRoomModalAction},
     room::BasicRoomDetails,
     shared::avatar::{AvatarWidgetExt, AvatarWidgetRefExt},
Diff in /app/src/home/space_lobby.rs:30:
     utils::{self, RoomNameId},
 };

[31m-
[m live_design! {
     use link::theme::*;
     use link::shaders::*;
Diff in /app/src/home/space_lobby.rs:220:
                 // Dumb approach, but it works.
                 for i in 0..20 {
                     if float(i) > self.level { break; }
[31m-
[m[32m+
[m                     if float(i) < self.level {
                         // Check mask for parent levels
                         let mask_bit = mod(floor(self.parent_mask / pow(2.0, float(i))), 2.0);
Diff in /app/src/home/space_lobby.rs:232:
                         }
                     } else {
                         // Current level: connection to self
[31m-
[m[32m+
[m                         // Horizontal line to content
                         let hy = self.rect_size.y * 0.5;
                         if abs(pos.y - hy) < half_line && pos.x > (float(i) * indent + half_indent) {
Diff in /app/src/home/space_lobby.rs:239:
                              return vec4(0.8, 0.8, 0.8, 1.0);
                         }
[31m-
[m[32m+
[m                         // Vertical line (L shape)
                         if abs(pos.x - (float(i) * indent + half_indent)) < half_line && pos.y < (self.rect_size.y * (1.0 - 0.5 * self.is_last)) {
                               return vec4(0.8, 0.8, 0.8, 1.0);
Diff in /app/src/home/space_lobby.rs:481:
                 }
                 text: "Welcome to the space:"
             }
[31m-
[m[32m+
[m             parent_space_row = <View> {
                 width: Fill,
                 height: Fit,
Diff in /app/src/home/space_lobby.rs:488:
                 flow: Right,
                 align: { y: 0.5 }
                 padding: { top: 8 }
[31m-
[m[32m+
[m                 parent_avatar = <Avatar> {
                     width: 36,
                     height: 36,
Diff in /app/src/home/space_lobby.rs:495:
                     margin: { right: 12 }
                 }
[31m-
[m[32m+
[m                 parent_name = <Label> {
                     width: Fill,
                     height: Fit,
Diff in /app/src/home/space_lobby.rs:552:
     }
 }

[31m-
[m thread_local! {
     /// A cache of UI states for each SpaceLobbyScreen, keyed by the space's room ID.
     /// This allows preserving the expanded/collapsed state of subspaces across screen changes.
Diff in /app/src/home/space_lobby.rs:568:
     expanded_spaces: HashSet<OwnedRoomId>,
 }

[31m-
[m /// A clickable entry shown in the RoomsList that will show the space lobby when clicked.
 #[derive(Live, LiveHook, Widget)]
 pub struct SpaceLobbyEntry {
Diff in /app/src/home/space_lobby.rs:575:
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m }

 impl Widget for SpaceLobbyEntry {
Diff in /app/src/home/space_lobby.rs:603:
             Hit::FingerUp(fe) if !fe.is_over => {
                 self.animator_play(cx, ids!(hover.off));
             }
[31m-            Hit::FingerMove(_fe) => { }
[m[32m+            Hit::FingerMove(_fe) => {}
[m             _ => {}
         }
     }
Diff in /app/src/home/space_lobby.rs:613:
     }
 }

[31m-
[m #[derive(Debug)]
 pub enum SpaceLobbyAction {
     SpaceLobbyEntryClicked,
Diff in /app/src/home/space_lobby.rs:622:
 #[derive(Live, LiveHook, LiveRegister)]
 #[repr(C)]
 pub struct DrawTreeLine {
[31m-    #[deref] draw_super: DrawQuad,
[m[31m-    #[live] indent_width: f32,
[m[31m-    #[live] level: f32,
[m[31m-    #[live] is_last: f32,
[m[31m-    #[live] parent_mask: f32,
[m[32m+    #[deref]
[m[32m+    draw_super: DrawQuad,
[m[32m+    #[live]
[m[32m+    indent_width: f32,
[m[32m+    #[live]
[m[32m+    level: f32,
[m[32m+    #[live]
[m[32m+    is_last: f32,
[m[32m+    #[live]
[m[32m+    parent_mask: f32,
[m }

 #[derive(Live, LiveHook, Widget)]
Diff in /app/src/home/space_lobby.rs:633:
 pub struct TreeLines {
[31m-    #[redraw] #[live] draw_bg: DrawTreeLine,
[m[31m-    #[walk] walk: Walk,
[m[32m+    #[redraw]
[m[32m+    #[live]
[m[32m+    draw_bg: DrawTreeLine,
[m[32m+    #[walk]
[m[32m+    walk: Walk,
[m }

 impl Widget for TreeLines {
Diff in /app/src/home/space_lobby.rs:639:
[31m-    fn handle_event(&mut self, _cx: &mut Cx, _event: &Event, _scope: &mut Scope) { }
[m[32m+    fn handle_event(&mut self, _cx: &mut Cx, _event: &Event, _scope: &mut Scope) {}
[m
     fn draw_walk(&mut self, cx: &mut Cx2d, _scope: &mut Scope, walk: Walk) -> DrawStep {
         let indent_pixel = (self.draw_bg.level + 1.0) * self.draw_bg.indent_width;
Diff in /app/src/home/space_lobby.rs:643:
         let mut walk = walk;
         walk.width = Size::Fixed(indent_pixel as f64);
[31m-
[m[32m+
[m         self.draw_bg.draw_walk(cx, walk);
         DrawStep::done()
     }
Diff in /app/src/home/space_lobby.rs:651:
 /// A clickable entry for a child subspace.
 #[derive(Live, LiveHook, Widget)]
 pub struct SubspaceEntry {
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[31m-    #[rust] room_id: Option<OwnedRoomId>,
[m[31m-    #[rust] is_space: bool,
[m[31m-    #[rust] show_buttons_view: bool,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m[32m+    #[rust]
[m[32m+    room_id: Option<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    is_space: bool,
[m[32m+    #[rust]
[m[32m+    show_buttons_view: bool,
[m }

 /// Actions emitted when a `SubspaceEntry` or its buttons are clicked.
Diff in /app/src/home/space_lobby.rs:663:
 /// These *are* all widget actions.
 #[derive(Clone, Debug, DefaultNone)]
 pub enum SubspaceEntryAction {
[31m-    SpaceClicked { space_id: OwnedRoomId },
[m[31m-    RoomClicked  { room_id: OwnedRoomId },
[m[31m-    JoinClicked  { room_id: OwnedRoomId, is_space: bool },
[m[31m-    LeaveClicked { room_id: OwnedRoomId, is_space: bool },
[m[31m-    ViewClicked  { room_id: OwnedRoomId },
[m[32m+    SpaceClicked {
[m[32m+        space_id: OwnedRoomId,
[m[32m+    },
[m[32m+    RoomClicked {
[m[32m+        room_id: OwnedRoomId,
[m[32m+    },
[m[32m+    JoinClicked {
[m[32m+        room_id: OwnedRoomId,
[m[32m+        is_space: bool,
[m[32m+    },
[m[32m+    LeaveClicked {
[m[32m+        room_id: OwnedRoomId,
[m[32m+        is_space: bool,
[m[32m+    },
[m[32m+    ViewClicked {
[m[32m+        room_id: OwnedRoomId,
[m[32m+    },
[m     None,
 }

Diff in /app/src/home/space_lobby.rs:703:
                 // Makepad emits a HoverOut hit, but we don't want that to actually count as a hover-out
                 // because the mouse is still hovering over the buttons_view.
                 let entry_rect = self.view.area().rect(cx);
[31m-                let is_over_buttons_view = self.show_buttons_view && buttons_view_rect.contains(fe.abs);
[m[32m+                let is_over_buttons_view =
[m[32m+                    self.show_buttons_view && buttons_view_rect.contains(fe.abs);
[m                 if !entry_rect.contains(fe.abs) && !is_over_buttons_view {
                     self.animator_play(cx, ids!(hover.off));
                     self.show_buttons_view = false;
Diff in /app/src/home/space_lobby.rs:716:
             }
             Hit::FingerUp(fe) if fe.is_over && fe.is_primary_hit() && fe.was_tap() => {
                 let is_within_buttons_view = self.show_buttons_view
[31m-                    && self.view.view(ids!(buttons_view)).area().rect(cx).contains(fe.abs);
[m[32m+                    && self
[m[32m+                        .view
[m[32m+                        .view(ids!(buttons_view))
[m[32m+                        .area()
[m[32m+                        .rect(cx)
[m[32m+                        .contains(fe.abs);
[m                 if !is_within_buttons_view {
                     if let Some(room_id) = self.room_id.as_ref() {
                         cx.widget_action(
Diff in /app/src/home/space_lobby.rs:723:
                             self.widget_uid(),
[31m-                            &scope.path,
[m[32m+                            &scope.path,
[m                             if self.is_space {
[31m-                                SubspaceEntryAction::SpaceClicked { space_id: room_id.clone() }
[m[32m+                                SubspaceEntryAction::SpaceClicked {
[m[32m+                                    space_id: room_id.clone(),
[m[32m+                                }
[m                             } else {
[31m-                                SubspaceEntryAction::RoomClicked { room_id: room_id.clone() }
[m[31m-                            }
[m[32m+                                SubspaceEntryAction::RoomClicked {
[m[32m+                                    room_id: room_id.clone(),
[m[32m+                                }
[m[32m+                            },
[m                         );
                     }
                 }
Diff in /app/src/home/space_lobby.rs:747:
                     cx.widget_action(
                         self.widget_uid(),
                         &scope.path,
[31m-                        SubspaceEntryAction::JoinClicked { room_id, is_space: self.is_space },
[m[32m+                        SubspaceEntryAction::JoinClicked {
[m[32m+                            room_id,
[m[32m+                            is_space: self.is_space,
[m[32m+                        },
[m                     );
                 }
             }
Diff in /app/src/home/space_lobby.rs:757:
                     cx.widget_action(
                         self.widget_uid(),
                         &scope.path,
[31m-                        SubspaceEntryAction::LeaveClicked { room_id, is_space: self.is_space },
[m[32m+                        SubspaceEntryAction::LeaveClicked {
[m[32m+                            room_id,
[m[32m+                            is_space: self.is_space,
[m[32m+                        },
[m                     );
                 }
             }
Diff in /app/src/home/space_lobby.rs:802:
         SpaceRoomInfo {
             id: space_room.room_id.clone(),
             name: space_room.display_name.clone(),
[31m-            topic: space_room.topic.as_ref().map(|t| replace_linebreaks_separators(t.trim())),
[m[32m+            topic: space_room
[m[32m+                .topic
[m[32m+                .as_ref()
[m[32m+                .map(|t| replace_linebreaks_separators(t.trim())),
[m             avatar: AvatarState::Known(space_room.avatar_url.clone()),
             num_joined_members: space_room.num_joined_members,
             state: space_room.state,
Diff in /app/src/home/space_lobby.rs:817:
             children_count: space_room.is_space().then_some(space_room.children_count),
             id: space_room.room_id,
             name: space_room.display_name,
[31m-            topic: space_room.topic.map(|t| replace_linebreaks_separators(t.trim())),
[m[32m+            topic: space_room
[m[32m+                .topic
[m[32m+                .map(|t| replace_linebreaks_separators(t.trim())),
[m             avatar: AvatarState::Known(space_room.avatar_url),
             num_joined_members: space_room.num_joined_members,
             state: space_room.state,
Diff in /app/src/home/space_lobby.rs:852:
 /// The view showing the lobby/homepage for a given space.
 #[derive(Live, LiveHook, Widget)]
 pub struct SpaceLobbyScreen {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// The space that is currently being displayed.
[31m-    #[rust] space_name_id: Option<RoomNameId>,
[m[32m+    #[rust]
[m[32m+    space_name_id: Option<RoomNameId>,
[m
     /// The sender channel to submit space requests to the background service.
[31m-    #[rust] space_request_sender: Option<UnboundedSender<SpaceRequest>>,
[m[32m+    #[rust]
[m[32m+    space_request_sender: Option<UnboundedSender<SpaceRequest>>,
[m
     /// Cache of detailed children for each space we've fetched.
     /// Key is the space_id, value is the list of its direct children.
Diff in /app/src/home/space_lobby.rs:865:
[31m-    #[rust] children_cache: HashMap<OwnedRoomId, Vector<SpaceRoom>>,
[m[32m+    #[rust]
[m[32m+    children_cache: HashMap<OwnedRoomId, Vector<SpaceRoom>>,
[m
     /// The set of space IDs that are currently expanded (showing their children).
[31m-    #[rust] expanded_spaces: HashSet<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    expanded_spaces: HashSet<OwnedRoomId>,
[m
     /// The ordered list of children to display in the space tree.
[31m-    #[rust] tree_entries: Vec<TreeEntry>,
[m[32m+    #[rust]
[m[32m+    tree_entries: Vec<TreeEntry>,
[m
     /// The set of space IDs that are currently loading their children.
[31m-    #[rust] loading_subspaces: HashSet<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    loading_subspaces: HashSet<OwnedRoomId>,
[m
     /// Whether we are currently loading the initial data.
[31m-    #[rust] is_loading: bool,
[m[32m+    #[rust]
[m[32m+    is_loading: bool,
[m }

 impl Widget for SpaceLobbyScreen {
Diff in /app/src/home/space_lobby.rs:891:
         if let Event::Actions(actions) = event {
             for action in actions {
                 match action.downcast_ref() {
[31m-                    Some(SpaceRoomListAction::DetailedChildren { space_id, children, .. }) => {
[m[32m+                    Some(SpaceRoomListAction::DetailedChildren {
[m[32m+                        space_id, children, ..
[m[32m+                    }) => {
[m                         self.update_children_in_space(cx, space_id, children);
                     }

Diff in /app/src/home/space_lobby.rs:898:
                     // Handle receiving top-level space details (join rule, member count).
                     Some(SpaceRoomListAction::TopLevelSpaceDetails(sr)) => {
[31m-                        if self.space_name_id.as_ref().is_some_and(|sni| sni.room_id() == &sr.room_id) {
[m[31m-                            self.view.label(ids!(header.space_info_label)).set_text(cx, &format!(
[m[31m-                                "{}  ·  {} {}",
[m[31m-                                match sr.join_rule {
[m[31m-                                    Some(JoinRuleSummary::Public) => "🌐  Public space",
[m[31m-                                    _ => "🔒  Private space",
[m[31m-                                },
[m[31m-                                sr.num_joined_members,
[m[31m-                                if sr.num_joined_members == 1 { "member" } else { "members" }
[m[31m-                            ));
[m[32m+                        if self
[m[32m+                            .space_name_id
[m[32m+                            .as_ref()
[m[32m+                            .is_some_and(|sni| sni.room_id() == &sr.room_id)
[m[32m+                        {
[m[32m+                            self.view.label(ids!(header.space_info_label)).set_text(
[m[32m+                                cx,
[m[32m+                                &format!(
[m[32m+                                    "{}  ·  {} {}",
[m[32m+                                    match sr.join_rule {
[m[32m+                                        Some(JoinRuleSummary::Public) => "🌐  Public space",
[m[32m+                                        _ => "🔒  Private space",
[m[32m+                                    },
[m[32m+                                    sr.num_joined_members,
[m[32m+                                    if sr.num_joined_members == 1 {
[m[32m+                                        "member"
[m[32m+                                    } else {
[m[32m+                                        "members"
[m[32m+                                    }
[m[32m+                                ),
[m[32m+                            );
[m                             self.redraw(cx);
                         }
                     }
Diff in /app/src/home/space_lobby.rs:913:

                     // Handle a change to the set of children in this space or any of its child subspaces.
[31m-                    Some(SpaceRoomListAction::UpdatedChildren { space_id, parent_chain, .. }) => {
[m[31m-                        if self.space_name_id.as_ref().is_some_and(|sni|
[m[32m+                    Some(SpaceRoomListAction::UpdatedChildren {
[m[32m+                        space_id,
[m[32m+                        parent_chain,
[m[32m+                        ..
[m[32m+                    }) => {
[m[32m+                        if self.space_name_id.as_ref().is_some_and(|sni| {
[m                             sni.room_id() == space_id
[31m-                            || parent_chain.iter().any(|ancestor_id| sni.room_id() == ancestor_id)
[m[31m-                        ) {
[m[32m+                                || parent_chain
[m[32m+                                    .iter()
[m[32m+                                    .any(|ancestor_id| sni.room_id() == ancestor_id)
[m[32m+                        }) {
[m                             if let Some(sender) = &self.space_request_sender {
                                 let _ = sender.send(SpaceRequest::GetDetailedChildren {
                                     space_id: space_id.clone(),
Diff in /app/src/home/space_lobby.rs:925:
                             }
                         }
                     }
[31m-                    _ => { }
[m[32m+                    _ => {}
[m                 }

                 // Handle SubspaceEntry clicks
Diff in /app/src/home/space_lobby.rs:960:
                         } else {
                             cx.action(JoinLeaveRoomModalAction::Open {
                                 kind: JoinLeaveModalKind::LeaveRoom(
[31m-                                    self.basic_room_details_for(room_id)
[m[32m+                                    self.basic_room_details_for(room_id),
[m                                 ),
                                 show_tip: false,
                             });
Diff in /app/src/home/space_lobby.rs:972:
                             destination_room: self.basic_room_details_for(room_id),
                         });
                     }
[31m-                    SubspaceEntryAction::None => { }
[m[32m+                    SubspaceEntryAction::None => {}
[m                 }
             }

Diff in /app/src/home/space_lobby.rs:979:
             // Handle the invite button being clicked in the header.
[31m-            if self.view.button(ids!(header.parent_space_row.invite_button)).clicked(actions) {
[m[32m+            if self
[m[32m+                .view
[m[32m+                .button(ids!(header.parent_space_row.invite_button))
[m[32m+                .clicked(actions)
[m[32m+            {
[m                 if let Some(space_name_id) = self.space_name_id.as_ref() {
                     cx.action(InviteModalAction::Open(space_name_id.clone()));
                 }
Diff in /app/src/home/space_lobby.rs:988:
     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         while let Some(widget_to_draw) = self.view.draw_walk(cx, scope, walk).step() {
             let portal_list_ref = widget_to_draw.as_portal_list();
[31m-            let Some(mut list) = portal_list_ref.borrow_mut() else { continue };
[m[32m+            let Some(mut list) = portal_list_ref.borrow_mut() else {
[m[32m+                continue;
[m[32m+            };
[m
             let entry_count = self.tree_entries.len();
             let total_count = if self.is_loading || entry_count == 0 {
Diff in /app/src/home/space_lobby.rs:1003:
                 // Draw loading indicator
                 let item = if self.is_loading && item_id == 0 {
                     let item = list.item(cx, item_id, id!(status_label));
[31m-                    item.label(ids!(label)).set_text(cx, "Loading rooms and spaces...");
[m[32m+                    item.label(ids!(label))
[m[32m+                        .set_text(cx, "Loading rooms and spaces...");
[m                     item
                 }
                 // No entries found
Diff in /app/src/home/space_lobby.rs:1010:
                 else if entry_count == 0 && item_id == 0 {
                     let item = list.item(cx, item_id, id!(status_label));
[31m-                    item.label(ids!(label)).set_text(cx, "No rooms or spaces found.");
[m[31m-                    item.view(ids!(loading_spinner)).apply_over(cx, live! { visible: false });
[m[32m+                    item.label(ids!(label))
[m[32m+                        .set_text(cx, "No rooms or spaces found.");
[m[32m+                    item.view(ids!(loading_spinner))
[m[32m+                        .apply_over(cx, live! { visible: false });
[m                     item
                 }
                 // Draw a regular entry
Diff in /app/src/home/space_lobby.rs:1017:
                 else if let Some(entry) = self.tree_entries.get_mut(item_id) {
                     match entry {
[31m-                        TreeEntry::Item { info, level, is_last, parent_mask } => {
[m[32m+                        TreeEntry::Item {
[m[32m+                            info,
[m[32m+                            level,
[m[32m+                            is_last,
[m[32m+                            parent_mask,
[m[32m+                        } => {
[m                             let show_join_button = !matches!(info.state, Some(RoomState::Joined));
                             let show_leave_button = !show_join_button;
                             let show_view_button = show_leave_button && !info.is_space();
Diff in /app/src/home/space_lobby.rs:1032:
                                     }
                                     show_buttons_view = inner.show_buttons_view;
                                 }
[31m-                                item.view(ids!(buttons_view)).set_visible(cx, show_buttons_view);
[m[32m+                                item.view(ids!(buttons_view))
[m[32m+                                    .set_visible(cx, show_buttons_view);
[m                                 // Expand icon
                                 let is_expanded = self.expanded_spaces.contains(&info.id);
                                 let angle = if is_expanded { 180.0 } else { 90.0 };
Diff in /app/src/home/space_lobby.rs:1039:
[31m-                                item.icon(ids!(expand_icon)).apply_over(cx, live! {
[m[31m-                                    draw_icon: { rotation_angle: (angle) }
[m[31m-                                });
[m[32m+                                item.icon(ids!(expand_icon)).apply_over(
[m[32m+                                    cx,
[m[32m+                                    live! {
[m[32m+                                        draw_icon: { rotation_angle: (angle) }
[m[32m+                                    },
[m[32m+                                );
[m                                 item
                             } else {
                                 let item = list.item(cx, item_id, id!(room_entry));
Diff in /app/src/home/space_lobby.rs:1052:
                                     }
                                     show_buttons_view = inner.show_buttons_view;
                                 }
[31m-                                item.view(ids!(buttons_view)).set_visible(cx, show_buttons_view);
[m[32m+                                item.view(ids!(buttons_view))
[m[32m+                                    .set_visible(cx, show_buttons_view);
[m                                 item
                             };

Diff in /app/src/home/space_lobby.rs:1059:
[31m-                            item.button(ids!(buttons_view.join_button)).set_visible(cx, show_join_button);
[m[31m-                            item.button(ids!(buttons_view.leave_button)).set_visible(cx, show_leave_button);
[m[31m-                            item.button(ids!(buttons_view.view_button)).set_visible(cx, show_view_button);
[m[32m+                            item.button(ids!(buttons_view.join_button))
[m[32m+                                .set_visible(cx, show_join_button);
[m[32m+                            item.button(ids!(buttons_view.leave_button))
[m[32m+                                .set_visible(cx, show_leave_button);
[m[32m+                            item.button(ids!(buttons_view.view_button))
[m[32m+                                .set_visible(cx, show_view_button);
[m
                             // Below, draw things that are common to child rooms and subspaces.
[31m-                            item.label(ids!(content.name_label)).set_text(cx, &info.name);
[m[32m+                            item.label(ids!(content.name_label))
[m[32m+                                .set_text(cx, &info.name);
[m
                             // Display avatar from stored data, or fetch from cache, or show initials
                             let avatar_ref = item.avatar(ids!(avatar));
Diff in /app/src/home/space_lobby.rs:1070:

                             match &info.avatar {
                                 AvatarState::Loaded(data) => {
[31m-                                    drew_avatar = avatar_ref.show_image(
[m[31m-                                        cx,
[m[31m-                                        None,
[m[31m-                                        |cx, img| utils::load_png_or_jpg(&img, cx, data),
[m[31m-                                    ).is_ok();
[m[32m+                                    drew_avatar = avatar_ref
[m[32m+                                        .show_image(cx, None, |cx, img| {
[m[32m+                                            utils::load_png_or_jpg(&img, cx, data)
[m[32m+                                        })
[m[32m+                                        .is_ok();
[m                                 }
                                 AvatarState::Known(Some(uri)) => {
                                     match avatar_cache::get_or_fetch_avatar(cx, uri) {
Diff in /app/src/home/space_lobby.rs:1081:
                                         AvatarCacheEntry::Loaded(data) => {
[31m-                                            drew_avatar = avatar_ref.show_image(
[m[31m-                                                cx,
[m[31m-                                                None,
[m[31m-                                                |cx, img| utils::load_png_or_jpg(&img, cx, &data),
[m[31m-                                            ).is_ok();
[m[32m+                                            drew_avatar = avatar_ref
[m[32m+                                                .show_image(cx, None, |cx, img| {
[m[32m+                                                    utils::load_png_or_jpg(&img, cx, &data)
[m[32m+                                                })
[m[32m+                                                .is_ok();
[m                                             info.avatar = AvatarState::Loaded(data);
                                         }
                                         AvatarCacheEntry::Failed => {
Diff in /app/src/home/space_lobby.rs:1090:
                                             info.avatar = AvatarState::Failed;
                                         }
[31m-                                        AvatarCacheEntry::Requested => { }
[m[32m+                                        AvatarCacheEntry::Requested => {}
[m                                     }
                                 }
[31m-                                _ => { }
[m[32m+                                _ => {}
[m                             };
                             // Fallback to text initials.
                             if !drew_avatar {
Diff in /app/src/home/space_lobby.rs:1099:
                                 avatar_ref.show_text(cx, None, None, first_char.unwrap_or("#"));
                             }

[31m-                            if let Some(mut lines) = item.widget(ids!(tree_lines)).borrow_mut::<TreeLines>() {
[m[32m+                            if let Some(mut lines) =
[m[32m+                                item.widget(ids!(tree_lines)).borrow_mut::<TreeLines>()
[m[32m+                            {
[m                                 lines.draw_bg.level = *level as f32;
                                 lines.draw_bg.is_last = if *is_last { 1.0 } else { 0.0 };
                                 lines.draw_bg.parent_mask = *parent_mask as f32;
Diff in /app/src/home/space_lobby.rs:1126:
                             info_parts.push(format!(
                                 "{} {}",
                                 info.num_joined_members,
[31m-                                if info.num_joined_members == 1 { "member" } else { "members" }
[m[32m+                                if info.num_joined_members == 1 {
[m[32m+                                    "member"
[m[32m+                                } else {
[m[32m+                                    "members"
[m[32m+                                }
[m                             ));

                             // Add children count for spaces
Diff in /app/src/home/space_lobby.rs:1153:
                             // Draw loading indicator for subspace
                             let item = list.item(cx, item_id, id!(subspace_loading));
                             // Configure tree lines
[31m-                            if let Some(mut lines) = item.widget(ids!(tree_lines)).borrow_mut::<TreeLines>() {
[m[32m+                            if let Some(mut lines) =
[m[32m+                                item.widget(ids!(tree_lines)).borrow_mut::<TreeLines>()
[m[32m+                            {
[m                                 lines.draw_bg.level = *level as f32;
[31m-                                lines.draw_bg.is_last = 1.0;
[m[32m+                                lines.draw_bg.is_last = 1.0;
[m                                 lines.draw_bg.parent_mask = *parent_mask as f32;
                                 lines.draw_bg.indent_width = 44.0;
                             }
Diff in /app/src/home/space_lobby.rs:1187:
     }

     /// Handle receiving detailed children for a space.
[31m-    fn update_children_in_space(&mut self, cx: &mut Cx, space_id: &OwnedRoomId, children: &Vector<SpaceRoom>) {
[m[31m-        self.children_cache.insert(space_id.clone(), children.clone());
[m[32m+    fn update_children_in_space(
[m[32m+        &mut self,
[m[32m+        cx: &mut Cx,
[m[32m+        space_id: &OwnedRoomId,
[m[32m+        children: &Vector<SpaceRoom>,
[m[32m+    ) {
[m[32m+        self.children_cache
[m[32m+            .insert(space_id.clone(), children.clone());
[m         self.loading_subspaces.remove(space_id);

         // If this is for our displayed space, mark as loaded and rebuild tree
Diff in /app/src/home/space_lobby.rs:1195:
[31m-        if self.space_name_id.as_ref().is_some_and(|sni| sni.room_id() == space_id) {
[m[32m+        if self
[m[32m+            .space_name_id
[m[32m+            .as_ref()
[m[32m+            .is_some_and(|sni| sni.room_id() == space_id)
[m[32m+        {
[m             self.is_loading = false;
             // Auto-expand the top-level space (we don't show it, just its children)
             self.expanded_spaces.insert(space_id.clone());
Diff in /app/src/home/space_lobby.rs:1214:
             if !self.children_cache.contains_key(space_id) {
                 self.loading_subspaces.insert(space_id.clone());
                 if let Some(sender) = &self.space_request_sender {
[31m-                    let parent_chain = cx.get_global::<RoomsListRef>()
[m[32m+                    let parent_chain = cx
[m[32m+                        .get_global::<RoomsListRef>()
[m                         .get_space_parent_chain(space_id)
                         .unwrap_or_default();
                     let _ = sender.send(SpaceRequest::GetDetailedChildren {
Diff in /app/src/home/space_lobby.rs:1231:

     /// Rebuild the flattened tree entries based on the current expansion state.
     fn rebuild_tree_entries(&mut self) {
[31m-        let Some(space_name_id) = &self.space_name_id else { return };
[m[32m+        let Some(space_name_id) = &self.space_name_id else {
[m[32m+            return;
[m[32m+        };
[m         let root_space_id = space_name_id.room_id().clone();
         // Build tree starting from root
         let mut new_tree_entries = Vec::new();
Diff in /app/src/home/space_lobby.rs:1262:
         level: usize,
         parent_mask: u32,
     ) {
[31m-        let Some(children) = children_cache.get(space_id) else { return };
[m[32m+        let Some(children) = children_cache.get(space_id) else {
[m[32m+            return;
[m[32m+        };
[m
         // Sort: spaces first, then rooms, both alphabetically
         let mut sorted_children: Vec<_> = children.iter().collect();
Diff in /app/src/home/space_lobby.rs:1269:
[31m-        sorted_children.sort_by(|a, b| {
[m[31m-            match (a.is_space(), b.is_space()) {
[m[31m-                (true, false) => std::cmp::Ordering::Less,
[m[31m-                (false, true) => std::cmp::Ordering::Greater,
[m[31m-                _ => a.display_name.to_lowercase().cmp(&b.display_name.to_lowercase()),
[m[31m-            }
[m[32m+        sorted_children.sort_by(|a, b| match (a.is_space(), b.is_space()) {
[m[32m+            (true, false) => std::cmp::Ordering::Less,
[m[32m+            (false, true) => std::cmp::Ordering::Greater,
[m[32m+            _ => a
[m[32m+                .display_name
[m[32m+                .to_lowercase()
[m[32m+                .cmp(&b.display_name.to_lowercase()),
[m         });

[31m-
[m         let count = sorted_children.len();
         for (i, child) in sorted_children.into_iter().enumerate() {
             let is_last = i == count - 1;
Diff in /app/src/home/space_lobby.rs:1281:
[31m-
[m[32m+
[m             tree_entries.push(TreeEntry::Item {
                 info: SpaceRoomInfo::from(child),
                 level,
Diff in /app/src/home/space_lobby.rs:1310:
                     );
                 } else if loading_subspaces.contains(&child.room_id) {
                     // Show loading indicator
[31m-                    tree_entries.push(TreeEntry::Loading {
[m[32m+                    tree_entries.push(TreeEntry::Loading {
[m                         level: level + 1,
                         parent_mask: child_mask,
                     });
Diff in /app/src/home/space_lobby.rs:1340:

         // If this space is already being displayed, then the only thing we may need to do
         // is update its name in the top-level header (already done above).
[31m-        if self.space_name_id.as_ref().is_some_and(|sni| sni.room_id() == space_name_id.room_id()) {
[m[32m+        if self
[m[32m+            .space_name_id
[m[32m+            .as_ref()
[m[32m+            .is_some_and(|sni| sni.room_id() == space_name_id.room_id())
[m[32m+        {
[m             return;
         }

Diff in /app/src/home/space_lobby.rs:1364:

         // Clear the main content until we receive the async space info responses.
         self.tree_entries.clear();
[31m-        self.view.label(ids!(header.space_info_label)).set_text(cx, "");
[m[32m+        self.view
[m[32m+            .label(ids!(header.space_info_label))
[m[32m+            .set_text(cx, "");
[m         self.is_loading = true;

         // Restore UI state if we've viewed this space before, otherwise start fresh
Diff in /app/src/home/space_lobby.rs:1377:

         // TODO: move avatar setting to `draw_walk()`
         // Set parent avatar
[31m-        let avatar_ref = self.view.avatar(ids!(header.parent_space_row.parent_avatar));
[m[32m+        let avatar_ref = self
[m[32m+            .view
[m[32m+            .avatar(ids!(header.parent_space_row.parent_avatar));
[m         let first_char = utils::user_name_first_letter(&space_name);
         avatar_ref.show_text(cx, None, None, first_char.unwrap_or("#"));

Diff in /app/src/home/space_lobby.rs:1387:

 impl SpaceLobbyScreenRef {
     pub fn set_displayed_space(&self, cx: &mut Cx, space_name_id: &RoomNameId) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_displayed_space(cx, space_name_id);
     }

Diff in /app/src/home/space_lobby.rs:1394:
     /// Saves the current UI state. Call this when the screen is being hidden or destroyed.
     pub fn save_current_state(&self) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.save_current_state();
     }
 }
Diff in /app/src/home/spaces_bar.rs:13:
 use ruma::{OwnedRoomAliasId, OwnedRoomId, room::JoinRuleSummary};

 use crate::{
[31m-    home::navigation_tab_bar::{NavigationBarAction, SelectedTab}, room::{FetchedRoomAvatar, room_display_filter::{RoomDisplayFilter, RoomDisplayFilterBuilder, RoomFilterCriteria}}, shared::{avatar::AvatarWidgetRefExt, callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition}, room_filter_input_bar::RoomFilterAction}, utils::{self, RoomNameId}
[m[32m+    home::navigation_tab_bar::{NavigationBarAction, SelectedTab},
[m[32m+    room::{
[m[32m+        FetchedRoomAvatar,
[m[32m+        room_display_filter::{RoomDisplayFilter, RoomDisplayFilterBuilder, RoomFilterCriteria},
[m[32m+    },
[m[32m+    shared::{
[m[32m+        avatar::AvatarWidgetRefExt,
[m[32m+        callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition},
[m[32m+        room_filter_input_bar::RoomFilterAction,
[m[32m+    },
[m[32m+    utils::{self, RoomNameId},
[m };

 live_design! {
Diff in /app/src/home/spaces_bar.rs:188:
         flow: Down,
         spacing: 0.0

[31m-        auto_tail: false,
[m[32m+        auto_tail: false,
[m         max_pull_down: 0.0,
         scroll_bar: {  // hide the scroll bar
             bar_size: 0.0,
Diff in /app/src/home/spaces_bar.rs:207:
         Desktop = {
             align: {x: 0.5, y: 0.5}
             padding: 0,
[31m-            width: (NAVIGATION_TAB_BAR_SIZE),
[m[32m+            width: (NAVIGATION_TAB_BAR_SIZE),
[m             height: Fill

             show_bg: false
Diff in /app/src/home/spaces_bar.rs:239:
     }
 }

[31m-
[m /// Actions emitted by and handled by the SpacesBar widget (and its children).
 #[derive(Clone, Debug, DefaultNone)]
 pub enum SpacesBarAction {
Diff in /app/src/home/spaces_bar.rs:246:
     /// The user primary-clicked/tapped a space entry in the SpacesBar.
[31m-    ButtonClicked { space_name_id: RoomNameId },
[m[32m+    ButtonClicked {
[m[32m+        space_name_id: RoomNameId,
[m[32m+    },
[m     /// The user secondary-clicked/long-pressed a space entry in the SpacesBar.
[31m-    ButtonSecondaryClicked { space_name_id: RoomNameId },
[m[32m+    ButtonSecondaryClicked {
[m[32m+        space_name_id: RoomNameId,
[m[32m+    },
[m     None,
 }

Diff in /app/src/home/spaces_bar.rs:253:
[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct SpacesBarEntry {
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m
[31m-    #[rust] space_name_id: Option<RoomNameId>,
[m[32m+    #[rust]
[m[32m+    space_name_id: Option<RoomNameId>,
[m }

 impl Widget for SpacesBarEntry {
Diff in /app/src/home/spaces_bar.rs:273:
                 &scope.path,
                 TooltipAction::HoverIn {
                     widget_rect: area.rect(cx),
[31m-                    text: this.space_name_id.as_ref().map_or(
[m[31m-                        String::from("Unknown Space Name"),
[m[31m-                        |sni| sni.to_string(),
[m[31m-                    ),
[m[32m+                    text: this
[m[32m+                        .space_name_id
[m[32m+                        .as_ref()
[m[32m+                        .map_or(String::from("Unknown Space Name"), |sni| sni.to_string()),
[m                     options: CalloutTooltipOptions {
                         position: if is_desktop {
                             TooltipPosition::Right
Diff in /app/src/home/spaces_bar.rs:296:
             }
             Hit::FingerHoverOut(_) => {
                 self.animator_play(cx, ids!(hover.off));
[31m-                cx.widget_action(
[m[31m-                    self.widget_uid(),
[m[31m-                    &scope.path,
[m[31m-                    TooltipAction::HoverOut,
[m[31m-                );
[m[32m+                cx.widget_action(self.widget_uid(), &scope.path, TooltipAction::HoverOut);
[m             }
             Hit::FingerDown(fe) => {
                 self.animator_play(cx, ids!(hover.down));
Diff in /app/src/home/spaces_bar.rs:341:
             _ => {}
         }
     }
[31m-
[m[32m+
[m     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         self.view.draw_walk(cx, scope, walk)
     }
Diff in /app/src/home/spaces_bar.rs:351:
     fn set_metadata(&mut self, cx: &mut Cx, space_name_id: RoomNameId, is_selected: bool) {
         self.space_name_id = Some(space_name_id);
         let active_val = is_selected as u8 as f64;
[31m-        self.apply_over(cx, live!{
[m[31m-            draw_bg: { active: (active_val) },
[m[31m-            space_name = { draw_text: { active: (active_val) } }
[m[31m-        });
[m[32m+        self.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                draw_bg: { active: (active_val) },
[m[32m+                space_name = { draw_text: { active: (active_val) } }
[m[32m+            },
[m[32m+        );
[m     }
 }
 impl SpacesBarEntryRef {
Diff in /app/src/home/spaces_bar.rs:361:
     pub fn set_metadata(&self, cx: &mut Cx, space_name_id: RoomNameId, is_selected: bool) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_metadata(cx, space_name_id, is_selected);
     }
 }
Diff in /app/src/home/spaces_bar.rs:385:
     pub children_count: u64,
 }

[31m-
[m[31m-
[m /// The possible updates that should be displayed by the single list of all spaces.
 ///
 /// These updates are enqueued by the `enqueue_spaces_list_update` function
Diff in /app/src/home/spaces_bar.rs:452:
     ScrollToSpace(OwnedRoomId),
 }

[31m-
[m static PENDING_SPACE_UPDATES: SegQueue<SpacesListUpdate> = SegQueue::new();

 /// Enqueue a new room update for the list of all spaces
Diff in /app/src/home/spaces_bar.rs:462:
     SignalToUI::set_ui_signal();
 }

[31m-
[m /// The tab bar with buttons that navigate through top-level app pages.
 ///
 /// * In the "desktop" (wide) layout, this is a vertical bar on the left.
Diff in /app/src/home/spaces_bar.rs:469:
 /// * In the "mobile" (narrow) layout, this is a horizontal bar on the bottom.
 #[derive(Live, LiveHook, Widget)]
 pub struct SpacesBar {
[31m-    #[deref] view: AdaptiveView,
[m[32m+    #[deref]
[m[32m+    view: AdaptiveView,
[m
     /// The set of all joined spaces, keyed by the space ID.
[31m-    #[rust] all_joined_spaces: HashMap<OwnedRoomId, JoinedSpaceInfo>,
[m[32m+    #[rust]
[m[32m+    all_joined_spaces: HashMap<OwnedRoomId, JoinedSpaceInfo>,
[m
     /// The currently-active filter function for the list of spaces.
     ///
Diff in /app/src/home/spaces_bar.rs:479:
     /// Note: for performance reasons, this does not get automatically applied
     /// when its value changes. Instead, you must manually invoke it on the set of `all_joined_spaces`
     /// in order to update the set of `displayed_spaces` accordingly.
[31m-    #[rust] display_filter: RoomDisplayFilter,
[m[32m+    #[rust]
[m[32m+    display_filter: RoomDisplayFilter,
[m
     /// The list of spaces currently displayed in the UI, in order from top to bottom.
     /// This is a strict subset of the rooms in `all_joined_spaces`, and should be determined
Diff in /app/src/home/spaces_bar.rs:486:
     /// by applying the `display_filter` to the set of `all_joined_spaces`.
[31m-    #[rust] displayed_spaces: Vec<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    displayed_spaces: Vec<OwnedRoomId>,
[m
     /// Whether the list of `displayed_spaces` is currently filtered:
     /// `true` if filtered, `false` if showing everything.
Diff in /app/src/home/spaces_bar.rs:491:
[31m-    #[rust] is_filtered: bool,
[m[32m+    #[rust]
[m[32m+    is_filtered: bool,
[m
     /// The ID of the currently-selected space in this SpacesBar.
     /// Only one space can be selected at once.
Diff in /app/src/home/spaces_bar.rs:495:
[31m-    #[rust] selected_space: Option<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    selected_space: Option<OwnedRoomId>,
[m }

 impl Widget for SpacesBar {
Diff in /app/src/home/spaces_bar.rs:513:
                 }

                 // Update which space is currently selected.
[31m-                if let SpacesBarAction::ButtonClicked { space_name_id } = action.as_widget_action().cast() {
[m[32m+                if let SpacesBarAction::ButtonClicked { space_name_id } =
[m[32m+                    action.as_widget_action().cast()
[m[32m+                {
[m                     self.selected_space = Some(space_name_id.room_id().clone());
                     self.redraw(cx);
                     cx.action(NavigationBarAction::GoToSpace { space_name_id });
Diff in /app/src/home/spaces_bar.rs:543:
         while let Some(widget_to_draw) = self.view.draw_walk(cx, scope, walk).step() {
             // We only care about drawing the portal list.
             let portal_list_ref = widget_to_draw.as_portal_list();
[31m-            let Some(mut list) = portal_list_ref.borrow_mut() else { continue };
[m[32m+            let Some(mut list) = portal_list_ref.borrow_mut() else {
[m[32m+                continue;
[m[32m+            };
[m
             // AdaptiveView + CachedWidget does not properly handle DSL-level style overrides,
             // so we must manually apply the different style choices here when drawing it.
Diff in /app/src/home/spaces_bar.rs:550:
             if cx.display_context.is_desktop() {
[31m-                list.apply_over(cx, live! {
[m[31m-                    flow: Down,
[m[31m-                });
[m[32m+                list.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        flow: Down,
[m[32m+                    },
[m[32m+                );
[m             } else {
[31m-                list.apply_over(cx, live! {
[m[31m-                    flow: Right,
[m[31m-                });
[m[32m+                list.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        flow: Right,
[m[32m+                    },
[m[32m+                );
[m             }

             let len = self.displayed_spaces.len();
Diff in /app/src/home/spaces_bar.rs:569:
                                 "Found no\nmatching spaces."
                             } else {
                                 "Found no\njoined spaces."
[31m-                            }
[m[32m+                            },
[m                         );
                         item
                     } else {
Diff in /app/src/home/spaces_bar.rs:577:
                     };
                     item.draw_all(cx, scope);
                 }
[31m-            }
[m[31m-            else {
[m[32m+            } else {
[m                 list.set_item_range(cx, 0, len + 1);
                 while let Some(portal_list_index) = list.next_visible_item(cx) {
[31m-                    let item = if let Some(space) = self.displayed_spaces
[m[32m+                    let item = if let Some(space) = self
[m[32m+                        .displayed_spaces
[m                         .get(portal_list_index)
                         .and_then(|space_id| self.all_joined_spaces.get(space_id))
                     {
Diff in /app/src/home/spaces_bar.rs:595:
                                 avatar_ref.show_text(cx, None, None, text);
                             }
                             FetchedRoomAvatar::Image(image_data) => {
[31m-                                let res = avatar_ref.show_image(
[m[31m-                                    cx,
[m[31m-                                    None,
[m[31m-                                    |cx, img_ref| utils::load_png_or_jpg(&img_ref, cx, image_data),
[m[31m-                                );
[m[32m+                                let res = avatar_ref.show_image(cx, None, |cx, img_ref| {
[m[32m+                                    utils::load_png_or_jpg(&img_ref, cx, image_data)
[m[32m+                                });
[m                                 if res.is_err() {
[31m-                                    avatar_ref.show_text(
[m[31m-                                        cx,
[m[31m-                                        None,
[m[31m-                                        None,
[m[31m-                                        &space_name,
[m[31m-                                    );
[m[32m+                                    avatar_ref.show_text(cx, None, None, &space_name);
[m                                 }
                             }
                         }
Diff in /app/src/home/spaces_bar.rs:613:
                         item.as_spaces_bar_entry().set_metadata(
                             cx,
                             space.space_name_id.clone(),
[31m-                            self.selected_space.as_ref().is_some_and(|id| id == space.space_name_id.room_id()),
[m[32m+                            self.selected_space
[m[32m+                                .as_ref()
[m[32m+                                .is_some_and(|id| id == space.space_name_id.room_id()),
[m                         );
                         item
[31m-                    }
[m[31m-                    else if portal_list_index == len {
[m[32m+                    } else if portal_list_index == len {
[m                         let item = list.item(cx, portal_list_index, id!(StatusLabel));
[31m-                        let descriptor = if self.is_filtered { "matching" } else { "joined" };
[m[32m+                        let descriptor = if self.is_filtered {
[m[32m+                            "matching"
[m[32m+                        } else {
[m[32m+                            "joined"
[m[32m+                        };
[m                         let text = match len {
[31m-                            0      => format!("Found no\n{descriptor} spaces."),
[m[31m-                            1      => format!("Found 1\n{descriptor} space."),
[m[32m+                            0 => format!("Found no\n{descriptor} spaces."),
[m[32m+                            1 => format!("Found 1\n{descriptor} space."),
[m                             2..100 => format!("Found {len}\n{descriptor} spaces."),
[31m-                            100..  => format!("Found 99+\n{descriptor} spaces."),
[m[32m+                            100.. => format!("Found 99+\n{descriptor} spaces."),
[m                         };
                         item.label(ids!(label)).set_text(cx, &text);
                         item
Diff in /app/src/home/spaces_bar.rs:631:
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         list.item(cx, portal_list_index, id!(BottomFiller))
                     };
                     item.draw_all(cx, scope);
Diff in /app/src/home/spaces_bar.rs:642:
 }

 impl SpacesBar {
[31m-     /// Handle all pending updates to the spaces list.
[m[32m+    /// Handle all pending updates to the spaces list.
[m     fn handle_spaces_list_updates(&mut self, cx: &mut Cx, _event: &Event, _scope: &mut Scope) {
[31m-
[m         fn adjust_displayed_spaces(
             was_displayed: bool,
             should_display: bool,
Diff in /app/src/home/spaces_bar.rs:653:
         ) {
             match (was_displayed, should_display) {
                 // No need to update anything
[31m-                (true, true) | (false, false) => { }
[m[32m+                (true, true) | (false, false) => {}
[m                 // Space was displayed but should no longer be displayed.
                 (true, false) => {
[31m-                    displayed_spaces.iter()
[m[32m+                    displayed_spaces
[m[32m+                        .iter()
[m                         .position(|s| s == &space_id)
                         .map(|index| displayed_spaces.remove(index));
                 }
Diff in /app/src/home/spaces_bar.rs:667:
             }
         }

[31m-
[m         let mut num_updates: usize = 0;
         while let Some(update) = PENDING_SPACE_UPDATES.pop() {
             num_updates += 1;
Diff in /app/src/home/spaces_bar.rs:675:
                 SpacesListUpdate::AddJoinedSpace(joined_space) => {
                     let space_id = joined_space.space_name_id.room_id().clone();
                     let should_display = (self.display_filter)(&joined_space);
[31m-                    let replaced = self.all_joined_spaces.insert(space_id.clone(), joined_space);
[m[32m+                    let replaced = self
[m[32m+                        .all_joined_spaces
[m[32m+                        .insert(space_id.clone(), joined_space);
[m                     if replaced.is_none() {
[31m-                        adjust_displayed_spaces(false, should_display, space_id, &mut self.displayed_spaces);
[m[32m+                        adjust_displayed_spaces(
[m[32m+                            false,
[m[32m+                            should_display,
[m[32m+                            space_id,
[m[32m+                            &mut self.displayed_spaces,
[m[32m+                        );
[m                     } else {
                         error!("BUG: Added joined space {space_id} that already existed");
                     }
Diff in /app/src/home/spaces_bar.rs:684:
                 }

[31m-                SpacesListUpdate::UpdateCanonicalAlias { space_id, new_canonical_alias } => {
[m[32m+                SpacesListUpdate::UpdateCanonicalAlias {
[m[32m+                    space_id,
[m[32m+                    new_canonical_alias,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         let was_displayed = (self.display_filter)(space);
                         space.canonical_alias = new_canonical_alias;
Diff in /app/src/home/spaces_bar.rs:690:
                         let should_display = (self.display_filter)(space);
[31m-                        adjust_displayed_spaces(was_displayed, should_display, space_id, &mut self.displayed_spaces);
[m[32m+                        adjust_displayed_spaces(
[m[32m+                            was_displayed,
[m[32m+                            should_display,
[m[32m+                            space_id,
[m[32m+                            &mut self.displayed_spaces,
[m[32m+                        );
[m                     } else {
[31m-                        error!("Error: couldn't find space {space_id} to update space canonical alias");
[m[32m+                        error!(
[m[32m+                            "Error: couldn't find space {space_id} to update space canonical alias"
[m[32m+                        );
[m                     }
                 }

Diff in /app/src/home/spaces_bar.rs:697:
[31m-                SpacesListUpdate::UpdateSpaceName { space_id, new_space_name } => {
[m[32m+                SpacesListUpdate::UpdateSpaceName {
[m[32m+                    space_id,
[m[32m+                    new_space_name,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         let was_displayed = (self.display_filter)(space);
                         space.space_name_id = RoomNameId::new(
Diff in /app/src/home/spaces_bar.rs:702:
                             space_id.clone(),
                         );
                         let should_display = (self.display_filter)(space);
[31m-                        adjust_displayed_spaces(was_displayed, should_display, space_id, &mut self.displayed_spaces);
[m[32m+                        adjust_displayed_spaces(
[m[32m+                            was_displayed,
[m[32m+                            should_display,
[m[32m+                            space_id,
[m[32m+                            &mut self.displayed_spaces,
[m[32m+                        );
[m                     } else {
                         error!("Error: couldn't find space {space_id} to update space name");
                     }
Diff in /app/src/home/spaces_bar.rs:728:
                     }
                 }

[31m-                SpacesListUpdate::UpdateNumJoinedMembers { space_id, num_joined_members } => {
[m[32m+                SpacesListUpdate::UpdateNumJoinedMembers {
[m[32m+                    space_id,
[m[32m+                    num_joined_members,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         space.num_joined_members = num_joined_members;
                     } else {
Diff in /app/src/home/spaces_bar.rs:735:
[31m-                        error!("Error: couldn't find space {space_id} to update space num_joined_members");
[m[32m+                        error!(
[m[32m+                            "Error: couldn't find space {space_id} to update space num_joined_members"
[m[32m+                        );
[m                     }
                 }

Diff in /app/src/home/spaces_bar.rs:739:
[31m-                SpacesListUpdate::UpdateJoinRule { space_id, join_rule } => {
[m[32m+                SpacesListUpdate::UpdateJoinRule {
[m[32m+                    space_id,
[m[32m+                    join_rule,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         space.join_rule = join_rule;
                     } else {
Diff in /app/src/home/spaces_bar.rs:744:
                     }
                 }

[31m-                SpacesListUpdate::UpdateWorldReadable { space_id, world_readable } => {
[m[32m+                SpacesListUpdate::UpdateWorldReadable {
[m[32m+                    space_id,
[m[32m+                    world_readable,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         space.world_readable = world_readable;
                     } else {
Diff in /app/src/home/spaces_bar.rs:751:
[31m-                        error!("Error: couldn't find space {space_id} to update space world_readable");
[m[32m+                        error!(
[m[32m+                            "Error: couldn't find space {space_id} to update space world_readable"
[m[32m+                        );
[m                     }
                 }

Diff in /app/src/home/spaces_bar.rs:755:
[31m-                SpacesListUpdate::UpdateGuestCanJoin { space_id, guest_can_join } => {
[m[32m+                SpacesListUpdate::UpdateGuestCanJoin {
[m[32m+                    space_id,
[m[32m+                    guest_can_join,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         space.guest_can_join = guest_can_join;
                     } else {
Diff in /app/src/home/spaces_bar.rs:759:
[31m-                        error!("Error: couldn't find space {space_id} to update space guest_can_join");
[m[32m+                        error!(
[m[32m+                            "Error: couldn't find space {space_id} to update space guest_can_join"
[m[32m+                        );
[m                     }
                 }

Diff in /app/src/home/spaces_bar.rs:763:
[31m-                SpacesListUpdate::UpdateChildrenCount { space_id, children_count } => {
[m[32m+                SpacesListUpdate::UpdateChildrenCount {
[m[32m+                    space_id,
[m[32m+                    children_count,
[m[32m+                } => {
[m                     if let Some(space) = self.all_joined_spaces.get_mut(&space_id) {
                         space.children_count = children_count;
                     } else {
Diff in /app/src/home/spaces_bar.rs:767:
[31m-                        error!("Error: couldn't find space {space_id} to update space children_count");
[m[32m+                        error!(
[m[32m+                            "Error: couldn't find space {space_id} to update space children_count"
[m[32m+                        );
[m                     }
                 }

Diff in /app/src/home/spaces_bar.rs:793:
         }
     }

[31m-
[m     /// Updates the lists of displayed spaces based on the current search filter.
     fn update_displayed_spaces(&mut self, cx: &mut Cx, keywords: &str) {
         let portal_list = self.view.portal_list(ids!(spaces_list));
Diff in /app/src/home/spaces_bar.rs:816:
         self.display_filter = filter;
         self.is_filtered = true;

[31m-        let filtered_spaces_iter = self.all_joined_spaces.iter()
[m[32m+        let filtered_spaces_iter = self
[m[32m+            .all_joined_spaces
[m[32m+            .iter()
[m             .filter(|(_, space)| (self.display_filter)(*space));

         self.displayed_spaces = if let Some(sort_fn) = sort_fn {
Diff in /app/src/home/spaces_bar.rs:823:
[31m-            let mut filtered_spaces = filtered_spaces_iter
[m[31m-                .collect::<Vec<_>>();
[m[32m+            let mut filtered_spaces = filtered_spaces_iter.collect::<Vec<_>>();
[m             filtered_spaces.sort_by(|(_, space_a), (_, space_b)| sort_fn(*space_a, *space_b));
             filtered_spaces
                 .into_iter()
Diff in /app/src/home/spaces_bar.rs:828:
[31m-                .map(|(space_id, _)| space_id.clone()).collect()
[m[32m+                .map(|(space_id, _)| space_id.clone())
[m[32m+                .collect()
[m         } else {
[31m-            filtered_spaces_iter.map(|(space_id, _)| space_id.clone()).collect()
[m[32m+            filtered_spaces_iter
[m[32m+                .map(|(space_id, _)| space_id.clone())
[m[32m+                .collect()
[m         };

         portal_list.set_first_id_and_scroll(0, 0.0);
Diff in /app/src/home/tombstone_footer.rs:5:
 //! the option to join the successor room or stay in the current tombstoned room.

 use makepad_widgets::*;
[31m-use matrix_sdk::{
[m[31m-    ruma::OwnedRoomId, RoomState, SuccessorRoom
[m[32m+use matrix_sdk::{ruma::OwnedRoomId, RoomState, SuccessorRoom};
[m[32m+
[m[32m+use crate::{
[m[32m+    app::AppStateAction,
[m[32m+    room::{BasicRoomDetails, FetchedRoomAvatar, FetchedRoomPreview},
[m[32m+    shared::avatar::AvatarWidgetExt,
[m[32m+    utils,
[m };

[31m-use crate::{app::AppStateAction, room::{BasicRoomDetails, FetchedRoomAvatar, FetchedRoomPreview}, shared::avatar::AvatarWidgetExt, utils};
[m[31m-
[m const DEFAULT_TOMBSTONE_REASON: &str = "This room has been replaced and is no longer active.";
 const DEFAULT_JOIN_BUTTON_TEXT: &str = "Go to the replacement room";

Diff in /app/src/home/tombstone_footer.rs:102:
     Full {
         room_preview: FetchedRoomPreview,
         reason: Option<String>,
[31m-    }
[m[32m+    },
[m }

[31m-
[m /// A view that shows information about a tombstoned room and its successor.
 #[derive(Live, LiveHook, Widget)]
 pub struct TombstoneFooter {
Diff in /app/src/home/tombstone_footer.rs:112:
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m     /// The ID of the current tombstoned room.
[31m-    #[rust] room_id: Option<OwnedRoomId>,
[m[32m+    #[rust]
[m[32m+    room_id: Option<OwnedRoomId>,
[m     /// The details of the successor room.
[31m-    #[rust] successor_info: Option<BasicRoomDetails>,
[m[32m+    #[rust]
[m[32m+    successor_info: Option<BasicRoomDetails>,
[m }

 impl Widget for TombstoneFooter {
Diff in /app/src/home/tombstone_footer.rs:120:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         if let Event::Actions(actions) = event {
[31m-            if self.view.button(ids!(join_successor_button)).clicked(actions) {
[m[32m+            if self
[m[32m+                .view
[m[32m+                .button(ids!(join_successor_button))
[m[32m+                .clicked(actions)
[m[32m+            {
[m                 let Some(destination_room) = self.successor_info.clone() else {
[31m-                    error!("BUG: cannot navigate to replacement room: no successor room information.");
[m[32m+                    error!(
[m[32m+                        "BUG: cannot navigate to replacement room: no successor room information."
[m[32m+                    );
[m                     return;
                 };
                 cx.action(AppStateAction::NavigateToRoom {
Diff in /app/src/home/tombstone_footer.rs:151:
         let successor_room_avatar = self.view.avatar(ids!(successor_room_avatar));
         let successor_room_name = self.view.label(ids!(successor_room_name));

[31m-        log!("Showing TombstoneFooter for room {tombstoned_room_id}, Successor: {successor_room_details:?}");
[m[32m+        log!(
[m[32m+            "Showing TombstoneFooter for room {tombstoned_room_id}, Successor: {successor_room_details:?}"
[m[32m+        );
[m         match successor_room_details {
             SuccessorRoomDetails::None => {
                 replacement_reason.set_text(cx, DEFAULT_TOMBSTONE_REASON);
Diff in /app/src/home/tombstone_footer.rs:161:
                 self.successor_info = None;
             }
             SuccessorRoomDetails::Basic(sr) => {
[31m-                replacement_reason.set_text(
[m[31m-                    cx,
[m[31m-                    sr.reason.as_deref().unwrap_or(DEFAULT_TOMBSTONE_REASON)
[m[31m-                );
[m[32m+                replacement_reason
[m[32m+                    .set_text(cx, sr.reason.as_deref().unwrap_or(DEFAULT_TOMBSTONE_REASON));
[m                 join_successor_button.set_text(cx, DEFAULT_JOIN_BUTTON_TEXT);
                 successor_room_avatar.show_text(cx, None, None, "#");
                 successor_room_name.set_text(cx, &format!("Room ID {}", sr.room_id));
Diff in /app/src/home/tombstone_footer.rs:171:
                 self.successor_info = Some(sr.into());
[31m-            },
[m[31m-            SuccessorRoomDetails::Full { room_preview, reason } => {
[m[31m-                replacement_reason.set_text(
[m[31m-                    cx,
[m[31m-                    reason.as_deref().unwrap_or(DEFAULT_TOMBSTONE_REASON)
[m[31m-                );
[m[32m+            }
[m[32m+            SuccessorRoomDetails::Full {
[m[32m+                room_preview,
[m[32m+                reason,
[m[32m+            } => {
[m[32m+                replacement_reason
[m[32m+                    .set_text(cx, reason.as_deref().unwrap_or(DEFAULT_TOMBSTONE_REASON));
[m                 join_successor_button.set_text(
                     cx,
                     matches!(room_preview.state, Some(RoomState::Joined))
Diff in /app/src/home/tombstone_footer.rs:181:
                         .then_some(DEFAULT_JOIN_BUTTON_TEXT)
[31m-                        .unwrap_or("Join the replacement room")
[m[32m+                        .unwrap_or("Join the replacement room"),
[m                 );
                 match &room_preview.room_avatar {
                     FetchedRoomAvatar::Text(text) => {
Diff in /app/src/home/tombstone_footer.rs:186:
                         successor_room_avatar.show_text(cx, None, None, text);
                     }
                     FetchedRoomAvatar::Image(image_data) => {
[31m-                        let res = successor_room_avatar.show_image(
[m[31m-                            cx,
[m[31m-                            None,
[m[31m-                            |cx, img_ref| utils::load_png_or_jpg(&img_ref, cx, image_data),
[m[31m-                        );
[m[32m+                        let res = successor_room_avatar.show_image(cx, None, |cx, img_ref| {
[m[32m+                            utils::load_png_or_jpg(&img_ref, cx, image_data)
[m[32m+                        });
[m                         if res.is_err() {
                             successor_room_avatar.show_text(
                                 cx,
Diff in /app/src/home/tombstone_footer.rs:197:
                                 None,
                                 None,
[31m-                                room_preview.room_name_id.name_for_avatar().as_deref().unwrap_or("?"),
[m[32m+                                room_preview
[m[32m+                                    .room_name_id
[m[32m+                                    .name_for_avatar()
[m[32m+                                    .as_deref()
[m[32m+                                    .unwrap_or("?"),
[m                             );
                         }
                     }
Diff in /app/src/home/tombstone_footer.rs:203:
                 }
                 match room_preview.room_name_id.name_for_avatar().as_deref() {
                     Some(n) => successor_room_name.set_text(cx, n),
[31m-                    _ => successor_room_name.set_text(cx, &format!("Unnamed Room, ID: {}", room_preview.room_name_id.room_id())),
[m[32m+                    _ => successor_room_name.set_text(
[m[32m+                        cx,
[m[32m+                        &format!("Unnamed Room, ID: {}", room_preview.room_name_id.room_id()),
[m[32m+                    ),
[m                 }
                 self.successor_info = Some(room_preview.clone().into());
             }
Diff in /app/src/home/tombstone_footer.rs:229:
         tombstoned_room_id: &OwnedRoomId,
         successor_room_details: &SuccessorRoomDetails,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx, tombstoned_room_id, successor_room_details);
     }

Diff in /app/src/home/tombstone_footer.rs:236:
     /// See [`TombstoneFooter::hide()`].
     pub fn hide(&self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.hide(cx);
     }
 }
Diff in /app/src/join_leave_room_modal.rs:8:
 use matrix_sdk::ruma::OwnedRoomId;
 use tokio::sync::mpsc::UnboundedSender;

[31m-use crate::{home::invite_screen::{InviteDetails, JoinRoomResultAction, LeaveRoomResultAction}, room::BasicRoomDetails, shared::popup_list::{PopupKind, enqueue_popup_notification}, sliding_sync::{MatrixRequest, submit_async_request}, space_service_sync::{SpaceRequest, SpaceRoomListAction}, utils::{self, RoomNameId}};
[m[31m-use crate::shared::styles::{COLOR_ACTIVE_PRIMARY, COLOR_PRIMARY, COLOR_FG_ACCEPT_GREEN, COLOR_BG_ACCEPT_GREEN};
[m[32m+use crate::{
[m[32m+    home::invite_screen::{InviteDetails, JoinRoomResultAction, LeaveRoomResultAction},
[m[32m+    room::BasicRoomDetails,
[m[32m+    shared::popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    sliding_sync::{MatrixRequest, submit_async_request},
[m[32m+    space_service_sync::{SpaceRequest, SpaceRoomListAction},
[m[32m+    utils::{self, RoomNameId},
[m[32m+};
[m[32m+use crate::shared::styles::{
[m[32m+    COLOR_ACTIVE_PRIMARY, COLOR_PRIMARY, COLOR_FG_ACCEPT_GREEN, COLOR_BG_ACCEPT_GREEN,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/join_leave_room_modal.rs:82:
                             color: (COLOR_FG_DANGER_RED),
                         }
                         icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                         draw_bg: {
                             border_color: (COLOR_FG_DANGER_RED),
                             color: (COLOR_BG_DANGER_RED)
Diff in /app/src/join_leave_room_modal.rs:143:

 #[derive(Live, LiveHook, Widget)]
 pub struct JoinLeaveRoomModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] kind: Option<JoinLeaveModalKind>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    kind: Option<JoinLeaveModalKind>,
[m     /// Whether the modal is in a final state, meaning the user can only click "Okay" to close it.
     ///
     /// * Set to `Some(true)` after a successful action (e.g., joining or leaving a room).
Diff in /app/src/join_leave_room_modal.rs:151:
     /// * Set to `Some(false)` after a join/leave error occurs.
     /// * Set to `None` when the user is still able to interact with the modal.
[31m-    #[rust] final_success: Option<bool>,
[m[32m+    #[rust]
[m[32m+    final_success: Option<bool>,
[m }

 /// Kinds of content that can be shown and handled by the [`JoinLeaveRoomModal`].
Diff in /app/src/join_leave_room_modal.rs:180:
 impl JoinLeaveModalKind {
     pub fn room_id(&self) -> &OwnedRoomId {
         match self {
[31m-            JoinLeaveModalKind::AcceptInvite(invite)
[m[31m-            | JoinLeaveModalKind::RejectInvite(invite) => invite.room_id(),
[m[32m+            JoinLeaveModalKind::AcceptInvite(invite) | JoinLeaveModalKind::RejectInvite(invite) => {
[m[32m+                invite.room_id()
[m[32m+            }
[m             JoinLeaveModalKind::JoinRoom { details, .. }
             | JoinLeaveModalKind::LeaveRoom(details)
             | JoinLeaveModalKind::LeaveSpace { details, .. } => details.room_id(),
Diff in /app/src/join_leave_room_modal.rs:190:

     pub fn room_name(&self) -> &RoomNameId {
         match self {
[31m-            JoinLeaveModalKind::AcceptInvite(invite)
[m[31m-            | JoinLeaveModalKind::RejectInvite(invite) => invite.room_name_id(),
[m[32m+            JoinLeaveModalKind::AcceptInvite(invite) | JoinLeaveModalKind::RejectInvite(invite) => {
[m[32m+                invite.room_name_id()
[m[32m+            }
[m             JoinLeaveModalKind::JoinRoom { details, .. }
             | JoinLeaveModalKind::LeaveRoom(details)
             | JoinLeaveModalKind::LeaveSpace { details, .. } => details.room_name_id(),
Diff in /app/src/join_leave_room_modal.rs:201:
     #[allow(unused)] // remove when we use it in navigate_to_room
     pub fn basic_room_details(&self) -> &BasicRoomDetails {
         match self {
[31m-            JoinLeaveModalKind::AcceptInvite(invite)
[m[31m-            | JoinLeaveModalKind::RejectInvite(invite) => &invite.room_info,
[m[32m+            JoinLeaveModalKind::AcceptInvite(invite) | JoinLeaveModalKind::RejectInvite(invite) => {
[m[32m+                &invite.room_info
[m[32m+            }
[m             JoinLeaveModalKind::JoinRoom { details, .. }
             | JoinLeaveModalKind::LeaveRoom(details)
             | JoinLeaveModalKind::LeaveSpace { details, .. } => details,
Diff in /app/src/join_leave_room_modal.rs:231:
     },
 }

[31m-
[m impl Widget for JoinLeaveRoomModal {
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);
Diff in /app/src/join_leave_room_modal.rs:249:
         let cancel_button = self.view.button(ids!(cancel_button));

         let cancel_clicked = cancel_button.clicked(actions);
[31m-        if cancel_clicked ||
[m[31m-            actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m[32m+        if cancel_clicked
[m[32m+            || actions
[m[32m+                .iter()
[m[32m+                .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m         {
             // Inform other widgets that this modal has been closed.
[31m-            cx.action(JoinLeaveRoomModalAction::Close { successful: false, was_internal: cancel_clicked });
[m[32m+            cx.action(JoinLeaveRoomModalAction::Close {
[m[32m+                successful: false,
[m[32m+                was_internal: cancel_clicked,
[m[32m+            });
[m             self.reset_state();
             return;
         }
Diff in /app/src/join_leave_room_modal.rs:260:

[31m-        let Some(kind) = self.kind.as_ref() else { return };
[m[32m+        let Some(kind) = self.kind.as_ref() else {
[m[32m+            return;
[m[32m+        };
[m         let mut needs_redraw = false;

         if accept_button.clicked(actions) {
Diff in /app/src/join_leave_room_modal.rs:265:
             if let Some(successful) = self.final_success {
[31m-                cx.action(JoinLeaveRoomModalAction::Close { successful, was_internal: true });
[m[32m+                cx.action(JoinLeaveRoomModalAction::Close {
[m[32m+                    successful,
[m[32m+                    was_internal: true,
[m[32m+                });
[m                 self.reset_state();
                 return;
[31m-            }
[m[31m-            else {
[m[32m+            } else {
[m                 let title: Cow<str>;
                 let description: String;
                 let accept_button_text: &str;
Diff in /app/src/join_leave_room_modal.rs:297:
                         });
                     }
                     JoinLeaveModalKind::JoinRoom { details, is_space } => {
[31m-                        title = format!("Joining this {}...", if *is_space { "space" } else { "room" }).into();
[m[32m+                        title = format!(
[m[32m+                            "Joining this {}...",
[m[32m+                            if *is_space { "space" } else { "room" }
[m[32m+                        )
[m[32m+                        .into();
[m                         description = format!(
                             "Joining \"{}\".\n\n\
                             Waiting for confirmation from the homeserver...",
Diff in /app/src/join_leave_room_modal.rs:320:
                             room_id: room.room_id().clone(),
                         });
                     }
[31m-                    JoinLeaveModalKind::LeaveSpace { details, space_request_sender } => {
[m[32m+                    JoinLeaveModalKind::LeaveSpace {
[m[32m+                        details,
[m[32m+                        space_request_sender,
[m[32m+                    } => {
[m                         title = "Leaving this space...".into();
                         description = format!(
                             "Leaving \"{}\".\n\n\
Diff in /app/src/join_leave_room_modal.rs:328:
                             details.room_name_id(),
                         );
                         accept_button_text = "Leaving...";
[31m-                        if space_request_sender.send(
[m[31m-                            SpaceRequest::LeaveSpace { space_name_id: details.room_name_id().clone() }
[m[31m-                        ).is_err() {
[m[32m+                        if space_request_sender
[m[32m+                            .send(SpaceRequest::LeaveSpace {
[m[32m+                                space_name_id: details.room_name_id().clone(),
[m[32m+                            })
[m[32m+                            .is_err()
[m[32m+                        {
[m                             enqueue_popup_notification(
                                 "Failed to send leave space request.\n\nPlease restart Robrix.",
                                 PopupKind::Error,
Diff in /app/src/join_leave_room_modal.rs:341:
                 }

                 self.view.label(ids!(title)).set_text(cx, &title);
[31m-                self.view.label(ids!(description)).set_text(cx, &description);
[m[32m+                self.view
[m[32m+                    .label(ids!(description))
[m[32m+                    .set_text(cx, &description);
[m                 self.view.view(ids!(tip_view)).set_visible(cx, false);
                 accept_button.set_text(cx, accept_button_text);
                 accept_button.set_enabled(cx, false);
Diff in /app/src/join_leave_room_modal.rs:359:
                         Some(3.0),
                     );
                     self.view.label(ids!(title)).set_text(cx, "Joined room!");
[31m-                    self.view.label(ids!(description)).set_text(cx, &format!(
[m[31m-                        "Successfully joined \"{}\".",
[m[31m-                        kind.room_name(),
[m[31m-                    ));
[m[32m+                    self.view.label(ids!(description)).set_text(
[m[32m+                        cx,
[m[32m+                        &format!("Successfully joined \"{}\".", kind.room_name(),),
[m[32m+                    );
[m                     new_final_success = Some(true);
                 }
[31m-                Some(JoinRoomResultAction::Failed { room_id, error }) if room_id == kind.room_id() => {
[m[31m-                    self.view.label(ids!(title)).set_text(cx, "Error joining room!");
[m[31m-                    let was_invite = matches!(kind, JoinLeaveModalKind::AcceptInvite(_) | JoinLeaveModalKind::RejectInvite(_));
[m[31m-                    let msg = utils::stringify_join_leave_error(error, kind.room_name(), true, was_invite);
[m[31m-                    self.view.label(ids!(description)).set_text(cx, &msg);
[m[31m-                    enqueue_popup_notification(
[m[31m-                        msg,
[m[31m-                        PopupKind::Error,
[m[31m-                        None,
[m[32m+                Some(JoinRoomResultAction::Failed { room_id, error })
[m[32m+                    if room_id == kind.room_id() =>
[m[32m+                {
[m[32m+                    self.view
[m[32m+                        .label(ids!(title))
[m[32m+                        .set_text(cx, "Error joining room!");
[m[32m+                    let was_invite = matches!(
[m[32m+                        kind,
[m[32m+                        JoinLeaveModalKind::AcceptInvite(_) | JoinLeaveModalKind::RejectInvite(_)
[m                     );
[32m+                    let msg = utils::stringify_join_leave_error(
[m[32m+                        error,
[m[32m+                        kind.room_name(),
[m[32m+                        true,
[m[32m+                        was_invite,
[m[32m+                    );
[m[32m+                    self.view.label(ids!(description)).set_text(cx, &msg);
[m[32m+                    enqueue_popup_notification(msg, PopupKind::Error, None);
[m                     new_final_success = Some(false);
                 }
                 _ => {}
Diff in /app/src/join_leave_room_modal.rs:385:
                     let title: &str;
                     let description: String;
                     let popup_msg: Cow<'static, str>;
[31m-                    if matches!(kind, JoinLeaveModalKind::AcceptInvite(_) | JoinLeaveModalKind::RejectInvite(_)) {
[m[32m+                    if matches!(
[m[32m+                        kind,
[m[32m+                        JoinLeaveModalKind::AcceptInvite(_) | JoinLeaveModalKind::RejectInvite(_)
[m[32m+                    ) {
[m                         title = "Rejected invite!";
[31m-                        description = format!(
[m[31m-                            "Successfully rejected invite to \"{}\".",
[m[31m-                            kind.room_name(),
[m[31m-                        );
[m[32m+                        description =
[m[32m+                            format!("Successfully rejected invite to \"{}\".", kind.room_name(),);
[m                         popup_msg = "Successfully rejected invite.".into();
                     } else {
                         title = "Left room!";
Diff in /app/src/join_leave_room_modal.rs:397:
[31m-                        description = format!(
[m[31m-                            "Successfully left \"{}\".",
[m[31m-                            kind.room_name(),
[m[31m-                        );
[m[32m+                        description = format!("Successfully left \"{}\".", kind.room_name(),);
[m                         popup_msg = "Successfully left room.".into();
                     }
                     self.view.label(ids!(title)).set_text(cx, title);
Diff in /app/src/join_leave_room_modal.rs:404:
[31m-                    self.view.label(ids!(description)).set_text(cx, &description);
[m[32m+                    self.view
[m[32m+                        .label(ids!(description))
[m[32m+                        .set_text(cx, &description);
[m                     enqueue_popup_notification(popup_msg, PopupKind::Success, Some(5.0));
                     new_final_success = Some(true);
                 }
Diff in /app/src/join_leave_room_modal.rs:408:
[31m-                Some(LeaveRoomResultAction::Failed { room_id, error }) if room_id == kind.room_id() => {
[m[32m+                Some(LeaveRoomResultAction::Failed { room_id, error })
[m[32m+                    if room_id == kind.room_id() =>
[m[32m+                {
[m                     let title: &str;
                     let description: String;
                     let popup_msg: Cow<'static, str>;
Diff in /app/src/join_leave_room_modal.rs:412:
[31m-                    if matches!(kind, JoinLeaveModalKind::AcceptInvite(_) | JoinLeaveModalKind::RejectInvite(_)) {
[m[32m+                    if matches!(
[m[32m+                        kind,
[m[32m+                        JoinLeaveModalKind::AcceptInvite(_) | JoinLeaveModalKind::RejectInvite(_)
[m[32m+                    ) {
[m                         title = "Error rejecting invite!";
[31m-                        description = utils::stringify_join_leave_error(error, kind.room_name(), false, true);
[m[32m+                        description =
[m[32m+                            utils::stringify_join_leave_error(error, kind.room_name(), false, true);
[m                         popup_msg = "Failed to reject invite.".into();
                     } else {
                         title = "Error leaving room!";
Diff in /app/src/join_leave_room_modal.rs:418:
[31m-                        description = utils::stringify_join_leave_error(error, kind.room_name(), false, false);
[m[32m+                        description = utils::stringify_join_leave_error(
[m[32m+                            error,
[m[32m+                            kind.room_name(),
[m[32m+                            false,
[m[32m+                            false,
[m[32m+                        );
[m                         popup_msg = "Failed to leave room.".into();
                     }

Diff in /app/src/join_leave_room_modal.rs:422:
                     self.view.label(ids!(title)).set_text(cx, title);
[31m-                    self.view.label(ids!(description)).set_text(cx, &description);
[m[32m+                    self.view
[m[32m+                        .label(ids!(description))
[m[32m+                        .set_text(cx, &description);
[m                     enqueue_popup_notification(popup_msg, PopupKind::Error, None);
                     new_final_success = Some(false);
                 }
Diff in /app/src/join_leave_room_modal.rs:427:
                 _ => {}
             }

[31m-            if let Some(SpaceRoomListAction::LeaveSpaceResult { space_name_id, result }) = action.downcast_ref() {
[m[32m+            if let Some(SpaceRoomListAction::LeaveSpaceResult {
[m[32m+                space_name_id,
[m[32m+                result,
[m[32m+            }) = action.downcast_ref()
[m[32m+            {
[m                 if space_name_id.room_id() == kind.room_id() {
                     let title: &str;
                     let description: String;
Diff in /app/src/join_leave_room_modal.rs:439:
                         }
                         Err(e) => {
                             title = "Error leaving space!";
[31m-                            description = format!("Failed to leave space \"{space_name_id}\".\n\nError: {e}");
[m[32m+                            description =
[m[32m+                                format!("Failed to leave space \"{space_name_id}\".\n\nError: {e}");
[m                             new_final_success = Some(false);
                         }
                     }
Diff in /app/src/join_leave_room_modal.rs:446:
                     self.view.label(ids!(title)).set_text(cx, title);
[31m-                    self.view.label(ids!(description)).set_text(cx, &description);
[m[32m+                    self.view
[m[32m+                        .label(ids!(description))
[m[32m+                        .set_text(cx, &description);
[m                 }
             }
         }
Diff in /app/src/join_leave_room_modal.rs:452:
         if let Some(success) = new_final_success {
             self.final_success = Some(success);
             needs_redraw = true;
[31m-            accept_button.apply_over(cx, live!{
[m[31m-                enabled: true
[m[31m-                text: "Okay"
[m[31m-                draw_bg: {
[m[31m-                    color: (COLOR_ACTIVE_PRIMARY),
[m[31m-                    border_color: (COLOR_ACTIVE_PRIMARY)
[m[31m-                }
[m[31m-                draw_text: {
[m[31m-                    color: (COLOR_PRIMARY)
[m[31m-                }
[m[31m-                draw_icon: {
[m[31m-                    color: (COLOR_PRIMARY)
[m[31m-                }
[m[31m-            });
[m[32m+            accept_button.apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    enabled: true
[m[32m+                    text: "Okay"
[m[32m+                    draw_bg: {
[m[32m+                        color: (COLOR_ACTIVE_PRIMARY),
[m[32m+                        border_color: (COLOR_ACTIVE_PRIMARY)
[m[32m+                    }
[m[32m+                    draw_text: {
[m[32m+                        color: (COLOR_PRIMARY)
[m[32m+                    }
[m[32m+                    draw_icon: {
[m[32m+                        color: (COLOR_PRIMARY)
[m[32m+                    }
[m[32m+                },
[m[32m+            );
[m             accept_button.reset_hover(cx);
             cancel_button.set_visible(cx, false);
         }
Diff in /app/src/join_leave_room_modal.rs:481:
         self.final_success = None;
     }

[31m-    /// Populates this modal with the proper info based on
[m[32m+    /// Populates this modal with the proper info based on
[m     /// the given `kind of join or leave action.
[31m-    fn set_kind(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        kind: JoinLeaveModalKind,
[m[31m-        show_tip: bool,
[m[31m-    ) {
[m[32m+    fn set_kind(&mut self, cx: &mut Cx, kind: JoinLeaveModalKind, show_tip: bool) {
[m         log!("Showing JoinLeaveRoomModal for {kind:?}");
         let title: &str;
         let description: String;
Diff in /app/src/join_leave_room_modal.rs:549:
         }

         self.view.label(ids!(title)).set_text(cx, title);
[31m-        self.view.label(ids!(description)).set_text(cx, &description);
[m[32m+        self.view
[m[32m+            .label(ids!(description))
[m[32m+            .set_text(cx, &description);
[m         if show_tip {
             self.view.view(ids!(tip_view)).set_visible(cx, true);
             self.view.label(ids!(tip)).set_text(cx, &format!(
Diff in /app/src/join_leave_room_modal.rs:562:
         let accept_button = self.button(ids!(accept_button));
         let cancel_button = self.button(ids!(cancel_button));
         accept_button.set_text(cx, "Yes");
[31m-        accept_button.apply_over(cx, live!{
[m[31m-            draw_bg: {
[m[31m-                border_color: (COLOR_FG_ACCEPT_GREEN),
[m[31m-                color: (COLOR_BG_ACCEPT_GREEN)
[m[31m-            }
[m[31m-            draw_text: {
[m[31m-                color: (COLOR_FG_ACCEPT_GREEN)
[m[31m-            }
[m[31m-            draw_icon: {
[m[31m-                color: (COLOR_FG_ACCEPT_GREEN)
[m[31m-            }
[m[31m-        });
[m[32m+        accept_button.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                draw_bg: {
[m[32m+                    border_color: (COLOR_FG_ACCEPT_GREEN),
[m[32m+                    color: (COLOR_BG_ACCEPT_GREEN)
[m[32m+                }
[m[32m+                draw_text: {
[m[32m+                    color: (COLOR_FG_ACCEPT_GREEN)
[m[32m+                }
[m[32m+                draw_icon: {
[m[32m+                    color: (COLOR_FG_ACCEPT_GREEN)
[m[32m+                }
[m[32m+            },
[m[32m+        );
[m         accept_button.set_enabled(cx, true);
         accept_button.set_visible(cx, true);
         accept_button.reset_hover(cx);
Diff in /app/src/join_leave_room_modal.rs:589:

 impl JoinLeaveRoomModalRef {
     /// Sets the details of this join/leave modal.
[31m-    pub fn set_kind(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        kind: JoinLeaveModalKind,
[m[31m-        show_tip: bool,
[m[31m-    ) {
[m[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+    pub fn set_kind(&self, cx: &mut Cx, kind: JoinLeaveModalKind, show_tip: bool) {
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_kind(cx, kind, show_tip);
     }
 }
Diff in /app/src/lib.rs:31:
 mod event_preview;
 pub mod room;

[31m-
[m /// All content related to TSP (Trust Spanning Protocol) wallets/identities.
 #[cfg(feature = "tsp")]
 pub mod tsp;
Diff in /app/src/lib.rs:38:
 /// Dummy TSP module with placeholder widgets, for builds without TSP.
 #[cfg(not(feature = "tsp"))]
 pub mod tsp_dummy;
[31m-
[m
 // Matrix stuff
 pub mod sliding_sync;
Diff in /app/src/location.rs:1:
 //! Functions for querying the device's current location.

[31m-use std::{sync::{mpsc::{self, Receiver, Sender}, Mutex}, time::SystemTime};
[m[32m+use std::{
[m[32m+    sync::{
[m[32m+        mpsc::{self, Receiver, Sender},
[m[32m+        Mutex,
[m[32m+    },
[m[32m+    time::SystemTime,
[m[32m+};
[m
 use makepad_widgets::{Cx, error, log};
 use robius_location::{Access, Accuracy, Coordinates, Location, Manager};
Diff in /app/src/location.rs:12:
     Update(LocationUpdate),
     /// The location handler encountered an error.
     Error(robius_location::Error),
[31m-    None
[m[32m+    None,
[m }

 /// An updated location sample, including coordinates and a system timestamp.
Diff in /app/src/location.rs:32:
     *(LATEST_LOCATION.lock().unwrap())
 }

[31m-
[m struct LocationHandler;

 impl robius_location::Handler for LocationHandler {
Diff in /app/src/location.rs:61:
     }
 }

[31m-
[m fn location_request_loop(
     request_receiver: Receiver<LocationRequest>,
     mut manager: ManagerWrapper,
Diff in /app/src/location.rs:68:
 ) -> Result<(), robius_location::Error> {
[31m-
[m     manager.update_once()?;

     while let Ok(request) = request_receiver.recv() {
Diff in /app/src/location.rs:86:
     error!("Location request loop exited unexpectedly (the senders all died).");
     Err(robius_location::Error::Unknown)
 }
[31m-
[m
 pub enum LocationRequest {
     UpdateOnce,
Diff in /app/src/login/login_screen.rs:72:
                     min_handle_size: 0.0
                 }
             }
[31m-
[m[32m+
[m             <RoundedView> {
                 margin: {top: 40, bottom: 40}
                 width: Fill // TODO: once Makepad supports it, use `Fill {max: 375}`
Diff in /app/src/login/login_screen.rs:168:
                             }
                         }
                     }
[31m-
[m
[32m+
[m                     login_button = <RobrixIconButton> {
                         width: 275,
                         height: 40
Diff in /app/src/login/login_screen.rs:263:
                             draw_bg: { color: #C8C8C8 }
                         }
                     }
[31m-
[m[32m+
[m                     signup_button = <RobrixIconButton> {
                         width: Fit, height: Fit
                         padding: {left: 15, right: 15, top: 10, bottom: 10}
Diff in /app/src/login/login_screen.rs:296:
     }
 }

[31m-static MATRIX_SIGN_UP_URL: &str = "https://matrix.org/docs/chat_basics/matrix-for-im/#creating-a-matrix-account";
[m[32m+static MATRIX_SIGN_UP_URL: &str =
[m[32m+    "https://matrix.org/docs/chat_basics/matrix-for-im/#creating-a-matrix-account";
[m
 #[derive(Live, LiveHook, Widget)]
 pub struct LoginScreen {
Diff in /app/src/login/login_screen.rs:303:
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m     /// Boolean to indicate if the SSO login process is still in flight
[31m-    #[rust] sso_pending: bool,
[m[32m+    #[rust]
[m[32m+    sso_pending: bool,
[m     /// The URL to redirect to after logging in with SSO.
[31m-    #[rust] sso_redirect_url: Option<String>,
[m[32m+    #[rust]
[m[32m+    sso_redirect_url: Option<String>,
[m }

[31m-
[m impl Widget for LoginScreen {
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);
Diff in /app/src/login/login_screen.rs:355:
                 login_status_modal_inner.set_title(cx, "Logging in...");
                 login_status_modal_inner.set_status(cx, "Waiting for a login response...");
                 login_status_modal_inner.button_ref().set_text(cx, "Cancel");
[31m-                submit_async_request(MatrixRequest::Login(LoginRequest::LoginByPassword(LoginByPassword {
[m[31m-                    user_id,
[m[31m-                    password,
[m[31m-                    homeserver: homeserver.is_empty().not().then_some(homeserver),
[m[31m-                })));
[m[32m+                submit_async_request(MatrixRequest::Login(LoginRequest::LoginByPassword(
[m[32m+                    LoginByPassword {
[m[32m+                        user_id,
[m[32m+                        password,
[m[32m+                        homeserver: homeserver.is_empty().not().then_some(homeserver),
[m[32m+                    },
[m[32m+                )));
[m             }
             login_status_modal.open(cx);
             self.redraw(cx);
Diff in /app/src/login/login_screen.rs:366:
         }
[31m-
[m[32m+
[m         let provider_brands = ["apple", "facebook", "github", "gitlab", "google", "twitter"];
         let button_set: &[&[LiveId]] = ids_array!(
[31m-            apple_button,
[m[31m-            facebook_button,
[m[31m-            github_button,
[m[31m-            gitlab_button,
[m[31m-            google_button,
[m[32m+            apple_button,
[m[32m+            facebook_button,
[m[32m+            github_button,
[m[32m+            gitlab_button,
[m[32m+            google_button,
[m             twitter_button
         );
         for action in actions {
Diff in /app/src/login/login_screen.rs:381:

             // Handle login-related actions received from background async tasks.
             match action.downcast_ref() {
[31m-                Some(LoginAction::CliAutoLogin { user_id, homeserver }) => {
[m[32m+                Some(LoginAction::CliAutoLogin {
[m[32m+                    user_id,
[m[32m+                    homeserver,
[m[32m+                }) => {
[m                     user_id_input.set_text(cx, user_id);
                     password_input.set_text(cx, "");
                     homeserver_input.set_text(cx, homeserver.as_deref().unwrap_or_default());
Diff in /app/src/login/login_screen.rs:388:
                     login_status_modal_inner.set_title(cx, "Logging in via CLI...");
[31m-                    login_status_modal_inner.set_status(
[m[31m-                        cx,
[m[31m-                        &format!("Auto-logging in as user {user_id}...")
[m[31m-                    );
[m[32m+                    login_status_modal_inner
[m[32m+                        .set_status(cx, &format!("Auto-logging in as user {user_id}..."));
[m                     let login_status_modal_button = login_status_modal_inner.button_ref();
                     login_status_modal_button.set_text(cx, "Cancel");
                     login_status_modal_button.set_enabled(cx, false); // Login cancel not yet supported
Diff in /app/src/login/login_screen.rs:424:
                 }
                 Some(LoginAction::SsoPending(pending)) => {
                     for view_ref in self.view_set(button_set).iter() {
[31m-                        let Some(mut view_mut) = view_ref.borrow_mut() else { continue };
[m[32m+                        let Some(mut view_mut) = view_ref.borrow_mut() else {
[m[32m+                            continue;
[m[32m+                        };
[m                         if *pending {
[31m-                            view_mut.apply_over(cx, live! {
[m[31m-                                cursor: NotAllowed,
[m[31m-                                image = { draw_bg: { mask: 1.0 } }
[m[31m-                            });
[m[32m+                            view_mut.apply_over(
[m[32m+                                cx,
[m[32m+                                live! {
[m[32m+                                    cursor: NotAllowed,
[m[32m+                                    image = { draw_bg: { mask: 1.0 } }
[m[32m+                                },
[m[32m+                            );
[m                         } else {
[31m-                            view_mut.apply_over(cx, live! {
[m[31m-                                cursor: Hand,
[m[31m-                                image = { draw_bg: { mask: 0.0 } }
[m[31m-                            });
[m[32m+                            view_mut.apply_over(
[m[32m+                                cx,
[m[32m+                                live! {
[m[32m+                                    cursor: Hand,
[m[32m+                                    image = { draw_bg: { mask: 0.0 } }
[m[32m+                                },
[m[32m+                            );
[m                         }
                     }
                     self.sso_pending = *pending;
Diff in /app/src/login/login_screen.rs:443:
                 Some(LoginAction::SsoSetRedirectUrl(url)) => {
                     self.sso_redirect_url = Some(url.to_string());
                 }
[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }

Diff in /app/src/login/login_screen.rs:452:
             let login_status_modal_button = login_status_modal_inner.button_ref();
             if login_status_modal_button.clicked(actions) {
                 let request_id = id!(SSO_CANCEL_BUTTON);
[31m-                let request = HttpRequest::new(format!("{}/?login_token=",sso_redirect_url), HttpMethod::GET);
[m[32m+                let request = HttpRequest::new(
[m[32m+                    format!("{}/?login_token=", sso_redirect_url),
[m[32m+                    HttpMethod::GET,
[m[32m+                );
[m                 cx.http_request(request_id, request);
                 self.sso_redirect_url = None;
             }
Diff in /app/src/login/login_screen.rs:461:
         // Handle any of the SSO login buttons being clicked
         for (view_ref, brand) in self.view_set(button_set).iter().zip(&provider_brands) {
             if view_ref.finger_up(actions).is_some() && !self.sso_pending {
[31m-                submit_async_request(MatrixRequest::SpawnSSOServer{
[m[31m-                    identity_provider_id: format!("oidc-{}",brand),
[m[32m+                submit_async_request(MatrixRequest::SpawnSSOServer {
[m[32m+                    identity_provider_id: format!("oidc-{}", brand),
[m                     brand: brand.to_string(),
[31m-                    homeserver_url: homeserver_input.text()
[m[32m+                    homeserver_url: homeserver_input.text(),
[m                 });
             }
         }
Diff in /app/src/login/login_screen.rs:471:
     }
[31m-
[m }

 /// Actions sent to or from the login screen.
Diff in /app/src/login/login_screen.rs:494:
     /// informing it that the SSO login process is either still in flight (`true`) or has finished (`false`).
     ///
     /// Note that an inner value of `false` does *not* imply that the login request has
[31m-    /// successfully finished.
[m[32m+    /// successfully finished.
[m     /// The login screen can use this to prevent the user from submitting
[31m-    /// additional SSO login requests while a previous request is in flight.
[m[32m+    /// additional SSO login requests while a previous request is in flight.
[m     SsoPending(bool),
     /// Set the SSO redirect URL in the LoginScreen.
     ///
Diff in /app/src/login/login_status_modal.rs:85:
 /// A modal dialog that displays the status of a login attempt.
 #[derive(Live, LiveHook, Widget)]
 pub struct LoginStatusModal {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 #[derive(Clone, Debug, DefaultNone)]
Diff in /app/src/logout/logout_confirm_modal.rs:2:

 use makepad_widgets::*;
 use tokio::sync::Notify;
[31m-use crate::{shared::styles::COLOR_FG_DANGER_RED, sliding_sync::{submit_async_request, MatrixRequest}};
[m[32m+use crate::{
[m[32m+    shared::styles::COLOR_FG_DANGER_RED,
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest},
[m[32m+};
[m use super::logout_state_machine::is_logout_past_point_of_no_return;

 live_design! {
Diff in /app/src/logout/logout_confirm_modal.rs:102:
 /// A modal dialog that displays logout confirmation.
 #[derive(Live, LiveHook, Widget)]
 pub struct LogoutConfirmModal {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m     /// Whether the modal is in a final state, meaning the user can only click "Okay" to close it.
     ///
     /// * Set to `Some(true)` after a successful logout Action
Diff in /app/src/logout/logout_confirm_modal.rs:109:
     /// * Set to `Some(false)` after a logout error occurs.
     /// * Set to `None` when the user is still able to interact with the modal.
[31m-    #[rust] final_success: Option<bool>,
[m[32m+    #[rust]
[m[32m+    final_success: Option<bool>,
[m }

 /// Actions handled by the parent widget of the [`LogoutConfirmModal`].
Diff in /app/src/logout/logout_confirm_modal.rs:127:
     None,
 }

[31m-/// Actions related to logout process
[m[32m+/// Actions related to logout process
[m pub enum LogoutAction {
     /// A positive response to a logout request from the Matrix homeserver.
     LogoutSuccess,
Diff in /app/src/logout/logout_confirm_modal.rs:134:
     /// A negative response to a logout request from the Matrix homeserver.
     LogoutFailure(String),
     /// A request from the background task to the main UI thread to clear all app state.
[31m-    ClearAppState {
[m[31m-        on_clear_appstate: Arc<Notify>,
[m[31m-    },
[m[32m+    ClearAppState { on_clear_appstate: Arc<Notify> },
[m     /// Signal that the application is in an invalid state and needs to be restarted.
     /// This happens when critical components have been cleaned up during a previous
     /// logout attempt that reached the point of no return, but the app wasn't restarted.
Diff in /app/src/logout/logout_confirm_modal.rs:145:
         cleared_component: ClearedComponentType,
     },
     /// Progress update from the logout state machine
[31m-    ProgressUpdate {
[m[31m-        message: String,
[m[31m-        percentage: u8,
[m[31m-    },
[m[32m+    ProgressUpdate { message: String, percentage: u8 },
[m     /// Indicates logout is in progress or not
     InProgress(bool),
 }
Diff in /app/src/logout/logout_confirm_modal.rs:162:
             LogoutAction::ApplicationRequiresRestart { cleared_component } => {
                 write!(f, "ApplicationRequiresRestart({:?})", cleared_component)
             }
[31m-            LogoutAction::ProgressUpdate { message, percentage } => {
[m[32m+            LogoutAction::ProgressUpdate {
[m[32m+                message,
[m[32m+                percentage,
[m[32m+            } => {
[m                 write!(f, "ProgressUpdate({}, {}%)", message, percentage)
             }
             LogoutAction::InProgress(value) => write!(f, "InProgress({})", value),
Diff in /app/src/logout/logout_confirm_modal.rs:197:
         let cancel_button = self.button(ids!(cancel_button));
         let confirm_button = self.button(ids!(confirm_button));

[31m-        let modal_dismissed = actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)));
[m[32m+        let modal_dismissed = actions
[m[32m+            .iter()
[m[32m+            .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)));
[m         let cancel_clicked = cancel_button.clicked(actions);

         if cancel_clicked || modal_dismissed {
Diff in /app/src/logout/logout_confirm_modal.rs:204:
[31m-            cx.action(LogoutConfirmModalAction::Close { successful: false, was_internal: cancel_clicked });
[m[32m+            cx.action(LogoutConfirmModalAction::Close {
[m[32m+                successful: false,
[m[32m+                was_internal: cancel_clicked,
[m[32m+            });
[m             self.reset_state(cx);
             return;
         }
Diff in /app/src/logout/logout_confirm_modal.rs:214:
                     cx.quit();
                 }

[31m-                cx.action(LogoutConfirmModalAction::Close { successful, was_internal: true });
[m[32m+                cx.action(LogoutConfirmModalAction::Close {
[m[32m+                    successful,
[m[32m+                    was_internal: true,
[m[32m+                });
[m                 self.reset_state(cx);
                 return;
             } else {
Diff in /app/src/logout/logout_confirm_modal.rs:225:
                 cancel_button.set_text(cx, "Abort");
                 cancel_button.set_enabled(cx, true);

[31m-                submit_async_request(MatrixRequest::Logout { is_desktop: cx.display_context.is_desktop() });
[m[32m+                submit_async_request(MatrixRequest::Logout {
[m[32m+                    is_desktop: cx.display_context.is_desktop(),
[m[32m+                });
[m                 needs_redraw = true;
             }
         }
Diff in /app/src/logout/logout_confirm_modal.rs:245:

                 Some(LogoutAction::LogoutFailure(error)) => {
                     if is_logout_past_point_of_no_return() {
[31m-                        self.label(ids!(title)).set_text(cx, "Logout error, please restart Robrix.");
[m[32m+                        self.label(ids!(title))
[m[32m+                            .set_text(cx, "Logout error, please restart Robrix.");
[m                         self.set_message(cx, "The logout process encountered an error when communicating with the homeserver. Since your login session has been partially invalidated, Robrix must restart in order to continue to properly function.");

                         confirm_button.set_text(cx, "Restart now");
Diff in /app/src/logout/logout_confirm_modal.rs:252:
[31m-                        confirm_button.apply_over(cx, live!{
[m[31m-                            draw_bg: {
[m[31m-                                color: (COLOR_FG_DANGER_RED)
[m[31m-                            }
[m[31m-                        });
[m[32m+                        confirm_button.apply_over(
[m[32m+                            cx,
[m[32m+                            live! {
[m[32m+                                draw_bg: {
[m[32m+                                    color: (COLOR_FG_DANGER_RED)
[m[32m+                                }
[m[32m+                            },
[m[32m+                        );
[m                         confirm_button.set_enabled(cx, true);

                         cancel_button.set_visible(cx, false);
Diff in /app/src/logout/logout_confirm_modal.rs:260:
[31m-
[m                     } else {
                         self.set_message(cx, &format!("Logout failed: {}", error));
                         confirm_button.set_text(cx, "Okay");
Diff in /app/src/logout/logout_confirm_modal.rs:270:
                 }

                 Some(LogoutAction::ApplicationRequiresRestart { .. }) => {
[31m-                    self.label(ids!(title)).set_text(cx, "Logout error, please restart Robrix.");
[m[32m+                    self.label(ids!(title))
[m[32m+                        .set_text(cx, "Logout error, please restart Robrix.");
[m                     self.set_message(cx, "Application is in an inconsistent state and needs to be restarted to continue.");

                     confirm_button.set_text(cx, "Restart now");
Diff in /app/src/logout/logout_confirm_modal.rs:277:
[31m-                    confirm_button.apply_over(cx, live!{
[m[31m-                        draw_bg: {
[m[31m-                            color: (COLOR_FG_DANGER_RED)
[m[31m-                        }
[m[31m-                    });
[m[32m+                    confirm_button.apply_over(
[m[32m+                        cx,
[m[32m+                        live! {
[m[32m+                            draw_bg: {
[m[32m+                                color: (COLOR_FG_DANGER_RED)
[m[32m+                            }
[m[32m+                        },
[m[32m+                    );
[m                     confirm_button.set_enabled(cx, true);
                     cancel_button.set_visible(cx, false);

Diff in /app/src/logout/logout_confirm_modal.rs:286:
                     needs_redraw = true;
                 }

[31m-                Some(LogoutAction::ProgressUpdate { message, percentage }) => {
[m[32m+                Some(LogoutAction::ProgressUpdate {
[m[32m+                    message,
[m[32m+                    percentage,
[m[32m+                }) => {
[m                     // Just update the message text to show progress
                     self.set_message(cx, &format!("{} ({}%)", message, percentage));
                     // Disable confirm button during logout, but keep cancel/abort enabled
Diff in /app/src/logout/logout_confirm_modal.rs:303:
         if needs_redraw {
             self.redraw(cx);
         }
[31m-
[m     }
 }

Diff in /app/src/logout/logout_confirm_modal.rs:327:
         confirm_button.reset_hover(cx);
         self.redraw(cx);
     }
[31m-
[m }

 impl LogoutConfirmModalRef {
Diff in /app/src/logout/logout_confirm_modal.rs:338:
         }
     }

[31m-    pub fn reset_state(&self,cx: &mut Cx) {
[m[32m+    pub fn reset_state(&self, cx: &mut Cx) {
[m         if let Some(mut inner) = self.borrow_mut() {
             inner.reset_state(cx);
         }
Diff in /app/src/logout/logout_confirm_modal.rs:345:
     }
[31m-
[m }

Diff in /app/src/logout/logout_errors.rs:43:
 }

 impl std::error::Error for LogoutError {}
[32m+
[mDiff in /app/src/logout/logout_state_machine.rs:147:
             step_started_at: now,
         }
     }
[31m-
[m[32m+
[m     fn update(&mut self, state: LogoutState, message: String, percentage: u8) {
         self.state = state;
         self.message = message;
Diff in /app/src/logout/logout_state_machine.rs:194:

 impl LogoutStateMachine {
     pub fn new(config: LogoutConfig) -> Self {
[31m-        let initial_progress = LogoutProgress::new(
[m[31m-            LogoutState::Idle,
[m[31m-            "Ready to logout".to_string(),
[m[31m-            0
[m[31m-        );
[m[31m-
[m[32m+        let initial_progress =
[m[32m+            LogoutProgress::new(LogoutState::Idle, "Ready to logout".to_string(), 0);
[m[32m+
[m         Self {
             current_state: Arc::new(Mutex::new(LogoutState::Idle)),
             progress: Arc::new(Mutex::new(initial_progress)),
Diff in /app/src/logout/logout_state_machine.rs:208:
             cancellation_requested: Arc::new(AtomicBool::new(false)),
         }
     }
[31m-
[m[32m+
[m     /// Get current state
     pub async fn current_state(&self) -> LogoutState {
         self.current_state.lock().await.clone()
Diff in /app/src/logout/logout_state_machine.rs:215:
     }
[31m-
[m[32m+
[m     /// Get current progress
     pub async fn progress(&self) -> LogoutProgress {
         self.progress.lock().await.clone()
Diff in /app/src/logout/logout_state_machine.rs:220:
     }
[31m-
[m[32m+
[m     /// Request cancellation (only works before point of no return)
     pub fn request_cancellation(&self) {
         if !self.point_of_no_return.load(Ordering::Acquire) {
Diff in /app/src/logout/logout_state_machine.rs:225:
             self.cancellation_requested.store(true, Ordering::Release);
         }
     }
[31m-
[m[32m+
[m     /// Check if cancellation was requested
     fn is_cancelled(&self) -> bool {
         self.cancellation_requested.load(Ordering::Acquire)
Diff in /app/src/logout/logout_state_machine.rs:232:
     }
[31m-
[m[32m+
[m     /// Transition to a new state
[31m-    async fn transition_to(&self, new_state: LogoutState, message: String, percentage: u8) -> Result<()> {
[m[32m+    async fn transition_to(
[m[32m+        &self,
[m[32m+        new_state: LogoutState,
[m[32m+        message: String,
[m[32m+        percentage: u8,
[m[32m+    ) -> Result<()> {
[m         // Check for cancellation before transitioning
[31m-        if self.is_cancelled() && !matches!(new_state, LogoutState::PointOfNoReturn | LogoutState::Failed(_)) {
[m[32m+        if self.is_cancelled()
[m[32m+            && !matches!(
[m[32m+                new_state,
[m[32m+                LogoutState::PointOfNoReturn | LogoutState::Failed(_)
[m[32m+            )
[m[32m+        {
[m             let mut state = self.current_state.lock().await;
             *state = LogoutState::Failed(LogoutError::Recoverable(RecoverableError::Cancelled));
             return Err(anyhow!("Logout cancelled by user"));
Diff in /app/src/logout/logout_state_machine.rs:241:
         }
[31m-
[m[31m-        log!("Logout state transition: {:?} -> {:?}", self.current_state.lock().await.clone(), new_state);
[m[31m-
[m[32m+
[m[32m+        log!(
[m[32m+            "Logout state transition: {:?} -> {:?}",
[m[32m+            self.current_state.lock().await.clone(),
[m[32m+            new_state
[m[32m+        );
[m[32m+
[m         // Update state and progress, then extract values for UI update
         let mut state = self.current_state.lock().await;
         *state = new_state.clone();
Diff in /app/src/logout/logout_state_machine.rs:248:
         drop(state);
[31m-
[m[32m+
[m         let mut progress = self.progress.lock().await;
         progress.update(new_state, message.clone(), percentage);
         let progress_message = progress.message.clone();
Diff in /app/src/logout/logout_state_machine.rs:253:
         let progress_percentage = progress.percentage;
         drop(progress);
[31m-
[m[32m+
[m         // Send progress update to UI
[31m-        log!("Sending progress update: {} ({}%)", progress_message, progress_percentage);
[m[31m-        Cx::post_action(LogoutAction::ProgressUpdate {
[m[32m+        log!(
[m[32m+            "Sending progress update: {} ({}%)",
[m[32m+            progress_message,
[m[32m+            progress_percentage
[m[32m+        );
[m[32m+        Cx::post_action(LogoutAction::ProgressUpdate {
[m             message: progress_message,
[31m-            percentage: progress_percentage
[m[32m+            percentage: progress_percentage,
[m         });
[31m-
[m[32m+
[m         Ok(())
     }
[31m-
[m[32m+
[m     /// Execute the logout process
     pub async fn execute(&self) -> Result<()> {
         log!("LogoutStateMachine::execute() started");
Diff in /app/src/logout/logout_state_machine.rs:269:
[31m-
[m[32m+
[m         // Set logout in progress flag
         set_logout_in_progress(true);
[31m-
[m[32m+
[m         // Reset global point of no return flag
         set_logout_point_of_no_return(false);
[31m-
[m[32m+
[m         // Start from Idle state
         self.transition_to(
             LogoutState::PreChecking,
Diff in /app/src/logout/logout_state_machine.rs:279:
             "Checking prerequisites...".to_string(),
[31m-            10
[m[31m-        ).await?;
[m[31m-
[m[32m+            10,
[m[32m+        )
[m[32m+        .await?;
[m[32m+
[m         // Pre-checks
         if let Err(e) = self.perform_prechecks().await {
             self.transition_to(
Diff in /app/src/logout/logout_state_machine.rs:286:
                 LogoutState::Failed(e.clone()),
                 format!("Precheck failed: {}", e),
[31m-                0
[m[31m-            ).await?;
[m[32m+                0,
[m[32m+            )
[m[32m+            .await?;
[m             self.handle_error(&e).await;
             return Err(anyhow!(e));
         }
Diff in /app/src/logout/logout_state_machine.rs:293:
[31m-
[m[32m+
[m         // Stop sync service
         self.transition_to(
             LogoutState::StoppingSyncService,
Diff in /app/src/logout/logout_state_machine.rs:297:
             "Stopping sync service...".to_string(),
[31m-            20
[m[31m-        ).await?;
[m[31m-
[m[32m+            20,
[m[32m+        )
[m[32m+        .await?;
[m[32m+
[m         if let Err(e) = self.stop_sync_service().await {
             self.transition_to(
                 LogoutState::Failed(e.clone()),
Diff in /app/src/logout/logout_state_machine.rs:304:
                 format!("Failed to stop sync service: {}", e),
[31m-                0
[m[31m-            ).await?;
[m[32m+                0,
[m[32m+            )
[m[32m+            .await?;
[m             self.handle_error(&e).await;
             return Err(anyhow!(e));
         }
Diff in /app/src/logout/logout_state_machine.rs:310:
[31m-
[m[32m+
[m         // Server logout
         self.transition_to(
             LogoutState::LoggingOutFromServer,
Diff in /app/src/logout/logout_state_machine.rs:314:
             "Logging out from server...".to_string(),
[31m-            30
[m[31m-        ).await?;
[m[31m-
[m[32m+            30,
[m[32m+        )
[m[32m+        .await?;
[m[32m+
[m         match self.perform_server_logout().await {
             Ok(_) => {
                 self.point_of_no_return.store(true, Ordering::Release);
Diff in /app/src/logout/logout_state_machine.rs:322:
                 self.transition_to(
                     LogoutState::PointOfNoReturn,
                     "Point of no return reached".to_string(),
[31m-                    50
[m[31m-                ).await?;
[m[31m-
[m[32m+                    50,
[m[32m+                )
[m[32m+                .await?;
[m[32m+
[m                 // We delete latest_user_id after reaching LOGOUT_POINT_OF_NO_RETURN:
                 // 1. To prevent auto-login with invalid session on next start
                 // 2. While keeping session file intact for potential future login
Diff in /app/src/logout/logout_state_machine.rs:334:
             }
             Err(e) => {
                 // Check if it's an M_UNKNOWN_TOKEN error
[31m-                if matches!(&e, LogoutError::Recoverable(RecoverableError::ServerLogoutFailed(msg)) if msg.contains("M_UNKNOWN_TOKEN")) {
[m[32m+                if matches!(&e, LogoutError::Recoverable(RecoverableError::ServerLogoutFailed(msg)) if msg.contains("M_UNKNOWN_TOKEN"))
[m[32m+                {
[m                     log!("Token already invalidated, continuing with logout");
                     self.point_of_no_return.store(true, Ordering::Release);
                     set_logout_point_of_no_return(true);
Diff in /app/src/logout/logout_state_machine.rs:341:
                     self.transition_to(
                         LogoutState::PointOfNoReturn,
                         "Token already invalidated".to_string(),
[31m-                        50
[m[31m-                    ).await?;
[m[31m-
[m[32m+                        50,
[m[32m+                    )
[m[32m+                    .await?;
[m[32m+
[m                     // Same delete operation as in the success case above
                     if let Err(e) = delete_latest_user_id().await {
                         log!("Warning: Failed to delete latest user ID: {}", e);
Diff in /app/src/logout/logout_state_machine.rs:353:
                     if let Some(sync_service) = get_sync_service() {
                         sync_service.start().await;
                     }
[31m-
[m[32m+
[m                     self.transition_to(
                         LogoutState::Failed(e.clone()),
                         format!("Server logout failed: {}", e),
Diff in /app/src/logout/logout_state_machine.rs:360:
[31m-                        0
[m[31m-                    ).await?;
[m[32m+                        0,
[m[32m+                    )
[m[32m+                    .await?;
[m                     self.handle_error(&e).await;
                     return Err(anyhow!(e));
                 }
Diff in /app/src/logout/logout_state_machine.rs:365:
             }
         }
[31m-
[m[32m+
[m         // From here on, all failures are unrecoverable
[31m-
[m[32m+
[m         // Close tabs (desktop only)
         if self.config.is_desktop {
             self.transition_to(
Diff in /app/src/logout/logout_state_machine.rs:373:
                 LogoutState::ClosingTabs,
                 "Closing all tabs...".to_string(),
[31m-                60
[m[31m-            ).await?;
[m[31m-
[m[32m+                60,
[m[32m+            )
[m[32m+            .await?;
[m[32m+
[m             if let Err(e) = self.close_all_tabs().await {
[31m-                let error = LogoutError::Unrecoverable(UnrecoverableError::PostPointOfNoReturnFailure(e.to_string()));
[m[32m+                let error = LogoutError::Unrecoverable(
[m[32m+                    UnrecoverableError::PostPointOfNoReturnFailure(e.to_string()),
[m[32m+                );
[m                 self.transition_to(
                     LogoutState::Failed(error.clone()),
                     "Failed to close tabs".to_string(),
Diff in /app/src/logout/logout_state_machine.rs:383:
[31m-                    0
[m[31m-                ).await?;
[m[32m+                    0,
[m[32m+                )
[m[32m+                .await?;
[m                 self.handle_error(&error).await;
                 return Err(anyhow!(error));
             }
Diff in /app/src/logout/logout_state_machine.rs:388:
         }
[31m-
[m[32m+
[m         // Clean app state
         self.transition_to(
             LogoutState::CleaningAppState,
Diff in /app/src/logout/logout_state_machine.rs:393:
             "Cleaning up application state...".to_string(),
[31m-            70
[m[31m-        ).await?;
[m[31m-
[m[32m+            70,
[m[32m+        )
[m[32m+        .await?;
[m[32m+
[m         // All static resources (CLIENT, SYNC_SERVICE, etc.) are defined in the sliding_sync module,
         // so the state machine delegates the cleanup operation to sliding_sync's clear_app_state function
         // rather than accessing these static variables directly from outside the module.
Diff in /app/src/logout/logout_state_machine.rs:400:
         if let Err(e) = clear_app_state(&self.config).await {
[31m-            let error = LogoutError::Unrecoverable(UnrecoverableError::PostPointOfNoReturnFailure(e.to_string()));
[m[32m+            let error = LogoutError::Unrecoverable(UnrecoverableError::PostPointOfNoReturnFailure(
[m[32m+                e.to_string(),
[m[32m+            ));
[m             self.transition_to(
                 LogoutState::Failed(error.clone()),
                 "Failed to clean app state".to_string(),
Diff in /app/src/logout/logout_state_machine.rs:405:
[31m-                0
[m[31m-            ).await?;
[m[32m+                0,
[m[32m+            )
[m[32m+            .await?;
[m             self.handle_error(&error).await;
             return Err(anyhow!(error));
         }
Diff in /app/src/logout/logout_state_machine.rs:410:
[31m-
[m[32m+
[m         // Shutdown tasks
         self.transition_to(
             LogoutState::ShuttingDownTasks,
Diff in /app/src/logout/logout_state_machine.rs:414:
             "Shutting down background tasks...".to_string(),
[31m-            80
[m[31m-        ).await?;
[m[31m-
[m[32m+            80,
[m[32m+        )
[m[32m+        .await?;
[m[32m+
[m         self.shutdown_background_tasks();
[31m-
[m[32m+
[m         // Restart runtime
         self.transition_to(
             LogoutState::RestartingRuntime,
Diff in /app/src/logout/logout_state_machine.rs:423:
             "Restarting Matrix runtime...".to_string(),
[31m-            90
[m[31m-        ).await?;
[m[31m-
[m[31m-        if let Err(e) = self.restart_runtime(){
[m[32m+            90,
[m[32m+        )
[m[32m+        .await?;
[m[32m+
[m[32m+        if let Err(e) = self.restart_runtime() {
[m             let error = LogoutError::Unrecoverable(UnrecoverableError::RuntimeRestartFailed);
             self.transition_to(
                 LogoutState::Failed(error.clone()),
Diff in /app/src/logout/logout_state_machine.rs:431:
                 format!("Failed to restart runtime: {}", e),
[31m-                0
[m[31m-            ).await?;
[m[32m+                0,
[m[32m+            )
[m[32m+            .await?;
[m             self.handle_error(&error).await;
             return Err(anyhow!(error));
         }
Diff in /app/src/logout/logout_state_machine.rs:437:
[31m-
[m[32m+
[m         // Success!
         self.transition_to(
             LogoutState::Completed,
Diff in /app/src/logout/logout_state_machine.rs:441:
             "Logout completed successfully".to_string(),
[31m-            100
[m[31m-        ).await?;
[m[32m+            100,
[m[32m+        )
[m[32m+        .await?;
[m
         // Close the settings screen after logout, since its content
         // is specific to the currently-logged-in user's account.
Diff in /app/src/logout/logout_state_machine.rs:451:
         Cx::post_action(LogoutAction::LogoutSuccess);
         Ok(())
     }
[31m-
[m[32m+
[m     // Individual step implementations
     async fn perform_prechecks(&self) -> Result<(), LogoutError> {
         log!("perform_prechecks started");
Diff in /app/src/logout/logout_state_machine.rs:458:
[31m-
[m[32m+
[m         // Check client existence
         if get_client().is_none() {
             log!("perform_prechecks: client cleared");
Diff in /app/src/logout/logout_state_machine.rs:462:
[31m-            return Err(LogoutError::Unrecoverable(UnrecoverableError::ComponentsCleared));
[m[32m+            return Err(LogoutError::Unrecoverable(
[m[32m+                UnrecoverableError::ComponentsCleared,
[m[32m+            ));
[m         }
[31m-
[m[32m+
[m         // Check sync service
         if get_sync_service().is_none() {
             log!("perform_prechecks: sync service cleared");
Diff in /app/src/logout/logout_state_machine.rs:468:
[31m-            return Err(LogoutError::Unrecoverable(UnrecoverableError::ComponentsCleared));
[m[32m+            return Err(LogoutError::Unrecoverable(
[m[32m+                UnrecoverableError::ComponentsCleared,
[m[32m+            ));
[m         }
         log!("perform_prechecks: sync service exists");
[31m-
[m[32m+
[m         // Check access token
         if let Some(client) = get_client() {
             if client.access_token().is_none() {
Diff in /app/src/logout/logout_state_machine.rs:477:
             }
             log!("perform_prechecks: access token exists");
         }
[31m-
[m[32m+
[m         log!("perform_prechecks completed successfully");
         Ok(())
     }
Diff in /app/src/logout/logout_state_machine.rs:484:
[31m-
[m[32m+
[m     async fn stop_sync_service(&self) -> Result<(), LogoutError> {
         if let Some(sync_service) = get_sync_service() {
             sync_service.stop().await;
Diff in /app/src/logout/logout_state_machine.rs:488:
             Ok(())
         } else {
[31m-            Err(LogoutError::Unrecoverable(UnrecoverableError::ComponentsCleared))
[m[32m+            Err(LogoutError::Unrecoverable(
[m[32m+                UnrecoverableError::ComponentsCleared,
[m[32m+            ))
[m         }
     }
[31m-
[m[32m+
[m     async fn perform_server_logout(&self) -> Result<(), LogoutError> {
         let Some(client) = get_client() else {
[31m-            return Err(LogoutError::Unrecoverable(UnrecoverableError::ComponentsCleared));
[m[32m+            return Err(LogoutError::Unrecoverable(
[m[32m+                UnrecoverableError::ComponentsCleared,
[m[32m+            ));
[m         };
[31m-
[m[32m+
[m         match tokio::time::timeout(
             self.config.server_logout_timeout,
[31m-            client.matrix_auth().logout()
[m[31m-        ).await {
[m[32m+            client.matrix_auth().logout(),
[m[32m+        )
[m[32m+        .await
[m[32m+        {
[m             Ok(Ok(_)) => Ok(()),
[31m-            Ok(Err(e)) => Err(LogoutError::Recoverable(RecoverableError::ServerLogoutFailed(e.to_string()))),
[m[31m-            Err(_) => Err(LogoutError::Recoverable(RecoverableError::Timeout("Server logout timed out".to_string()))),
[m[32m+            Ok(Err(e)) => Err(LogoutError::Recoverable(
[m[32m+                RecoverableError::ServerLogoutFailed(e.to_string()),
[m[32m+            )),
[m[32m+            Err(_) => Err(LogoutError::Recoverable(RecoverableError::Timeout(
[m[32m+                "Server logout timed out".to_string(),
[m[32m+            ))),
[m         }
     }
[31m-
[m[32m+
[m     async fn close_all_tabs(&self) -> Result<()> {
         let on_close_all = Arc::new(Notify::new());
[31m-        Cx::post_action(MainDesktopUiAction::CloseAllTabs { on_close_all: on_close_all.clone() });
[m[31m-
[m[32m+        Cx::post_action(MainDesktopUiAction::CloseAllTabs {
[m[32m+            on_close_all: on_close_all.clone(),
[m[32m+        });
[m[32m+
[m         match tokio::time::timeout(self.config.tab_close_timeout, on_close_all.notified()).await {
             Ok(_) => {
                 log!("Received signal that all tabs were closed successfully");
Diff in /app/src/logout/logout_state_machine.rs:518:
             Err(_) => Err(anyhow!("Timed out waiting for tabs to close")),
         }
     }
[31m-
[m[32m+
[m     fn shutdown_background_tasks(&self) {
         shutdown_background_tasks();
     }
Diff in /app/src/logout/logout_state_machine.rs:525:
[31m-
[m[32m+
[m     fn restart_runtime(&self) -> Result<()> {
         start_matrix_tokio()
             .map(|_| ())
Diff in /app/src/logout/logout_state_machine.rs:529:
             .map_err(|e| anyhow!("Failed to restart runtime: {}", e))
     }
[31m-
[m[32m+
[m     /// Handle errors by posting appropriate actions
     async fn handle_error(&self, error: &LogoutError) {
         // Reset logout in progress flag on error (unless we've reached point of no return)
Diff in /app/src/logout/logout_state_machine.rs:535:
         if !is_logout_past_point_of_no_return() {
             set_logout_in_progress(false);
         }
[31m-
[m[32m+
[m         match error {
             LogoutError::Unrecoverable(UnrecoverableError::ComponentsCleared) => {
[31m-                Cx::post_action(LogoutAction::ApplicationRequiresRestart {
[m[31m-                    cleared_component: ClearedComponentType::Client
[m[32m+                Cx::post_action(LogoutAction::ApplicationRequiresRestart {
[m[32m+                    cleared_component: ClearedComponentType::Client,
[m                 });
             }
             LogoutError::Recoverable(RecoverableError::Cancelled) => {
Diff in /app/src/logout/logout_state_machine.rs:582:

 /// Execute logout using the state machine
 pub async fn logout_with_state_machine(is_desktop: bool) -> Result<()> {
[31m-    log!("logout_with_state_machine called with is_desktop={}", is_desktop);
[m[31m-
[m[32m+    log!(
[m[32m+        "logout_with_state_machine called with is_desktop={}",
[m[32m+        is_desktop
[m[32m+    );
[m[32m+
[m     let config = LogoutConfig {
         is_desktop,
         ..Default::default()
Diff in /app/src/logout/logout_state_machine.rs:590:
     };
[31m-
[m[32m+
[m     let state_machine = LogoutStateMachine::new(config);
     let result = state_machine.execute().await;
[31m-
[m[31m-    log!("logout_with_state_machine finished with result: {:?}", result.is_ok());
[m[32m+
[m[32m+    log!(
[m[32m+        "logout_with_state_machine finished with result: {:?}",
[m[32m+        result.is_ok()
[m[32m+    );
[m     result
 }

Diff in /app/src/logout/mod.rs:7:
 pub fn live_design(cx: &mut Cx) {
     logout_confirm_modal::live_design(cx);
 }
[32m+
[mDiff in /app/src/media_cache.rs:1:
[31m-use std::{ops::{Deref, DerefMut}, sync::{Arc, Mutex}, time::SystemTime};
[m[32m+use std::{
[m[32m+    ops::{Deref, DerefMut},
[m[32m+    sync::{Arc, Mutex},
[m[32m+    time::SystemTime,
[m[32m+};
[m use hashbrown::{hash_map::RawEntryMut, HashMap};
 use makepad_widgets::{error, log, SignalToUI};
[31m-use matrix_sdk::{media::{MediaFormat, MediaRequestParameters, MediaThumbnailSettings}, ruma::{events::room::MediaSource, OwnedMxcUri}, Error, HttpError};
[m[32m+use matrix_sdk::{
[m[32m+    media::{MediaFormat, MediaRequestParameters, MediaThumbnailSettings},
[m[32m+    ruma::{events::room::MediaSource, OwnedMxcUri},
[m[32m+    Error, HttpError,
[m[32m+};
[m use reqwest::StatusCode;
[31m-use crate::{home::room_screen::TimelineUpdate, sliding_sync::{self, MatrixRequest}};
[m[32m+use crate::{
[m[32m+    home::room_screen::TimelineUpdate,
[m[32m+    sliding_sync::{self, MatrixRequest},
[m[32m+};
[m
 /// The value type in the media cache, one per Matrix URI.
 #[derive(Debug, Clone)]
Diff in /app/src/media_cache.rs:26:
 /// A reference to a media cache entry and its associated format.
 pub type MediaCacheEntryRef = Arc<Mutex<MediaCacheEntry>>;

[31m-
[m /// A cache of fetched media, indexed by Matrix URI.
 ///
 /// A single Matrix URI may have multiple media formats associated with it,
Diff in /app/src/media_cache.rs:57:
     ///
     /// It will also optionally send updates to the given timeline update sender
     /// when a media request has completed.
[31m-    pub fn new(
[m[31m-        timeline_update_sender: Option<crossbeam_channel::Sender<TimelineUpdate>>,
[m[31m-    ) -> Self {
[m[32m+    pub fn new(timeline_update_sender: Option<crossbeam_channel::Sender<TimelineUpdate>>) -> Self {
[m         Self {
             cache: HashMap::new(),
             timeline_update_sender,
Diff in /app/src/media_cache.rs:104:
                             value.thumbnail = Some((Arc::clone(&entry_ref), requested_mts.clone()));
                             // If a full-size image is already loaded, return it.
                             if let Some(existing_file) = value.full_file.as_ref() {
[31m-                                if let MediaCacheEntry::Loaded(d) = existing_file.lock().unwrap().deref() {
[m[31m-                                    post_request_retval = (
[m[31m-                                        MediaCacheEntry::Loaded(Arc::clone(d)),
[m[31m-                                        MediaFormat::File,
[m[31m-                                    );
[m[32m+                                if let MediaCacheEntry::Loaded(d) =
[m[32m+                                    existing_file.lock().unwrap().deref()
[m[32m+                                {
[m[32m+                                    post_request_retval =
[m[32m+                                        (MediaCacheEntry::Loaded(Arc::clone(d)), MediaFormat::File);
[m                                 }
                             }
                             entry_ref_to_fetch = entry_ref;
Diff in /app/src/media_cache.rs:116:
                     }
                     MediaFormat::File => {
                         if let Some(entry_ref) = value.full_file.as_ref() {
[31m-                            return (
[m[31m-                                entry_ref.lock().unwrap().deref().clone(),
[m[31m-                                MediaFormat::File,
[m[31m-                            );
[m[32m+                            return (entry_ref.lock().unwrap().deref().clone(), MediaFormat::File);
[m                         } else {
                             // Here, a full-size image was requested but not found, so fetch it.
                             let entry_ref = Arc::new(Mutex::new(MediaCacheEntry::Requested));
Diff in /app/src/media_cache.rs:126:
                             value.full_file = Some(entry_ref.clone());
                             // If a thumbnail is already loaded, return it.
[31m-                            if let Some((existing_thumbnail, existing_mts)) = value.thumbnail.as_ref() {
[m[31m-                                if let MediaCacheEntry::Loaded(d) = existing_thumbnail.lock().unwrap().deref() {
[m[32m+                            if let Some((existing_thumbnail, existing_mts)) =
[m[32m+                                value.thumbnail.as_ref()
[m[32m+                            {
[m[32m+                                if let MediaCacheEntry::Loaded(d) =
[m[32m+                                    existing_thumbnail.lock().unwrap().deref()
[m[32m+                                {
[m                                     post_request_retval = (
                                         MediaCacheEntry::Loaded(Arc::clone(d)),
                                         MediaFormat::Thumbnail(existing_mts.clone()),
Diff in /app/src/media_cache.rs:170:
     /// Removes a specific media format from the cache for the given MXC URI.
     /// If `format` is None, removes the entire cache entry for the URI.
     /// Returns the removed cache entry if found, None otherwise.
[31m-    pub fn remove_cache_entry(&mut self, mxc_uri: &OwnedMxcUri, format: Option<MediaFormat>) -> Option<MediaCacheEntryRef> {
[m[32m+    pub fn remove_cache_entry(
[m[32m+        &mut self,
[m[32m+        mxc_uri: &OwnedMxcUri,
[m[32m+        format: Option<MediaFormat>,
[m[32m+    ) -> Option<MediaCacheEntryRef> {
[m         match format {
             Some(MediaFormat::Thumbnail(_)) => {
                 if let Some(cache_value) = self.cache.get_mut(mxc_uri) {
Diff in /app/src/media_cache.rs:200:
                 // Remove the entire entry for this MXC URI
                 self.cache.remove(mxc_uri).map(|cache_value| {
                     // Return the full_file entry if it exists, otherwise the thumbnail entry
[31m-                    cache_value.full_file
[m[32m+                    cache_value
[m[32m+                        .full_file
[m                         .or_else(|| cache_value.thumbnail.map(|(entry, _)| entry))
                         .unwrap_or_else(|| Arc::new(Mutex::new(MediaCacheEntry::Requested)))
                 })
Diff in /app/src/media_cache.rs:214:
     match error {
         Error::Http(http_error) => {
             if let Some(client_error) = http_error.as_client_api_error() {
[31m-                error!("Client error for media cache: {client_error} for request: {:?}", request);
[m[32m+                error!(
[m[32m+                    "Client error for media cache: {client_error} for request: {:?}",
[m[32m+                    request
[m[32m+                );
[m                 MediaCacheEntry::Failed(client_error.status_code)
             } else {
                 match *http_error {
Diff in /app/src/media_cache.rs:223:
                         if !reqwest_error.is_connect() {
                             MediaCacheEntry::Failed(StatusCode::INTERNAL_SERVER_ERROR)
                         } else if reqwest_error.is_status() {
[31m-                            MediaCacheEntry::Failed(reqwest_error
[m[31m-                                .status()
[m[31m-                                .unwrap_or(StatusCode::INTERNAL_SERVER_ERROR))
[m[32m+                            MediaCacheEntry::Failed(
[m[32m+                                reqwest_error
[m[32m+                                    .status()
[m[32m+                                    .unwrap_or(StatusCode::INTERNAL_SERVER_ERROR),
[m[32m+                            )
[m                         } else {
                             MediaCacheEntry::Failed(StatusCode::INTERNAL_SERVER_ERROR)
                         }
Diff in /app/src/media_cache.rs:236:
         }
         Error::InsufficientData => MediaCacheEntry::Failed(StatusCode::PARTIAL_CONTENT),
         Error::AuthenticationRequired => MediaCacheEntry::Failed(StatusCode::UNAUTHORIZED),
[31m-        _ => MediaCacheEntry::Failed(StatusCode::INTERNAL_SERVER_ERROR)
[m[32m+        _ => MediaCacheEntry::Failed(StatusCode::INTERNAL_SERVER_ERROR),
[m     }
 }

Diff in /app/src/media_cache.rs:256:
                 if let MediaSource::Plain(mxc_uri) = &request.source {
                     log!("Fetched media for {mxc_uri}");
                     let mut path = crate::temp_storage::get_temp_dir_path().clone();
[31m-                    let filename = format!("{}_{}_{}",
[m[31m-                        SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_millis(),
[m[31m-                        mxc_uri.server_name().unwrap(), mxc_uri.media_id().unwrap(),
[m[32m+                    let filename = format!(
[m[32m+                        "{}_{}_{}",
[m[32m+                        SystemTime::now()
[m[32m+                            .duration_since(SystemTime::UNIX_EPOCH)
[m[32m+                            .unwrap()
[m[32m+                            .as_millis(),
[m[32m+                        mxc_uri.server_name().unwrap(),
[m[32m+                        mxc_uri.media_id().unwrap(),
[m                     );
                     path.push(filename);
                     path.set_extension("png");
Diff in /app/src/media_cache.rs:265:
                     log!("Writing user media image to disk: {:?}", path);
[31m-                    std::fs::write(path, &data)
[m[31m-                        .expect("Failed to write user media image to disk");
[m[32m+                    std::fs::write(path, &data).expect("Failed to write user media image to disk");
[m                 }
             }
             MediaCacheEntry::Loaded(data)
Diff in /app/src/media_cache.rs:271:
         }
[31m-        Err(e) => error_to_media_cache_entry(e, &request)
[m[32m+        Err(e) => error_to_media_cache_entry(e, &request),
[m     };

     *value_ref.lock().unwrap() = new_value;
Diff in /app/src/persistence/app_state.rs:5:
 use matrix_sdk::ruma::{OwnedUserId, UserId};
 use crate::{app::AppState, app_data_dir, persistence::persistent_state_dir};

[31m-
[m const LATEST_APP_STATE_FILE_NAME: &str = "latest_app_state.json";

 const WINDOW_GEOM_STATE_FILE_NAME: &str = "window_geom_state.json";
Diff in /app/src/persistence/app_state.rs:12:

[31m-
[m /// Persistable state of the window's size, position, and fullscreen status.
 #[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
 pub struct WindowGeomState {
Diff in /app/src/persistence/app_state.rs:22:
     pub is_fullscreen: bool,
 }

[31m-
[m /// Save the current app state to persistent storage.
[31m-pub fn save_app_state(
[m[31m-    app_state: AppState,
[m[31m-    user_id: OwnedUserId,
[m[31m-) -> anyhow::Result<()> {
[m[31m-    let file = std::fs::File::create(
[m[31m-        persistent_state_dir(&user_id).join(LATEST_APP_STATE_FILE_NAME)
[m[31m-    )?;
[m[32m+pub fn save_app_state(app_state: AppState, user_id: OwnedUserId) -> anyhow::Result<()> {
[m[32m+    let file =
[m[32m+        std::fs::File::create(persistent_state_dir(&user_id).join(LATEST_APP_STATE_FILE_NAME))?;
[m     let mut writer = std::io::BufWriter::new(file);
     serde_json::to_writer(&mut writer, &app_state)?;
     writer.flush()?;
Diff in /app/src/persistence/app_state.rs:67:
             log!("No saved app state found, using default.");
             return Ok(AppState::default());
         }
[31m-        Err(e) => return Err(e.into())
[m[32m+        Err(e) => return Err(e.into()),
[m     };
     match serde_json::from_slice(&file_bytes) {
         Ok(app_state) => {
Diff in /app/src/persistence/app_state.rs:75:
             Ok(app_state)
         }
         Err(e) => {
[31m-            error!("Failed to deserialize app state: {e}. This may be due to an incompatible format from a previous version.");
[m[32m+            error!(
[m[32m+                "Failed to deserialize app state: {e}. This may be due to an incompatible format from a previous version."
[m[32m+            );
[m
             // Backup the old file to preserve user's data
             let backup_path = state_path.with_extension("json.bak");
Diff in /app/src/persistence/matrix_state.rs:6:
 use matrix_sdk::{
     authentication::matrix::MatrixSession,
     ruma::{OwnedUserId, UserId},
[31m-    sliding_sync,
[m[31m-    Client,
[m[32m+    sliding_sync, Client,
[m };
 use serde::{Deserialize, Serialize};

Diff in /app/src/persistence/matrix_state.rs:14:
[31m-use crate::{
[m[31m-    app_data_dir,
[m[31m-    login::login_screen::LoginAction,
[m[31m-};
[m[32m+use crate::{app_data_dir, login::login_screen::LoginAction};
[m
 /// The data needed to re-build a client.
 #[derive(Debug, Clone, Serialize, Deserialize)]
Diff in /app/src/persistence/matrix_state.rs:47:
     pub sync_token: Option<String>,

     /// The sliding sync version to use for this client session.
[31m-    ///
[m[32m+    ///
[m     /// This determines the sync protocol used by the Matrix client:
     /// - `Native`: Uses the server's native sliding sync implementation for efficient syncing
     /// - `None`: Falls back to standard Matrix sync (without sliding sync optimizations)
Diff in /app/src/persistence/matrix_state.rs:54:
[31m-    ///
[m[32m+    ///
[m     /// The value is restored and applied to the client via `client.set_sliding_sync_version()`
     /// when rebuilding the session from persistent storage.
     #[serde(default)]
Diff in /app/src/persistence/matrix_state.rs:83:
 }

 fn user_id_to_file_name(user_id: &UserId) -> String {
[31m-    user_id.as_str()
[m[31m-        .replace(":", "_")
[m[31m-        .replace("@", "")
[m[32m+    user_id.as_str().replace(":", "_").replace("@", "")
[m }

 /// Returns the path to the persistent state directory for the given user.
Diff in /app/src/persistence/matrix_state.rs:104:

 /// Returns the user ID of the most recently-logged in user session.
 pub async fn most_recent_user_id() -> Option<OwnedUserId> {
[31m-    tokio::fs::read_to_string(
[m[31m-        app_data_dir().join(LATEST_USER_ID_FILE_NAME)
[m[31m-    )
[m[31m-    .await
[m[31m-    .ok()?
[m[31m-    .trim()
[m[31m-    .try_into()
[m[31m-    .ok()
[m[32m+    tokio::fs::read_to_string(app_data_dir().join(LATEST_USER_ID_FILE_NAME))
[m[32m+        .await
[m[32m+        .ok()?
[m[32m+        .trim()
[m[32m+        .try_into()
[m[32m+        .ok()
[m }

 /// Save which user was the most recently logged in.
Diff in /app/src/persistence/matrix_state.rs:119:
     tokio::fs::write(
         app_data_dir().join(LATEST_USER_ID_FILE_NAME),
         user_id.as_str(),
[31m-    ).await?;
[m[32m+    )
[m[32m+    .await?;
[m     Ok(())
 }

Diff in /app/src/persistence/matrix_state.rs:126:
[31m-
[m /// Restores the given user's previous session from the filesystem.
 ///
 /// If no User ID is specified, the ID of the most recently-logged in user
Diff in /app/src/persistence/matrix_state.rs:130:
 /// is retrieved from the filesystem.
 pub async fn restore_session(
[31m-    user_id: Option<OwnedUserId>
[m[32m+    user_id: Option<OwnedUserId>,
[m ) -> anyhow::Result<(Client, Option<String>)> {
     let user_id = if let Some(user_id) = user_id {
         Some(user_id)
Diff in /app/src/persistence/matrix_state.rs:155:

     // The session was serialized as JSON in a file.
     let serialized_session = tokio::fs::read_to_string(session_file).await?;
[31m-    let FullSessionPersisted { client_session, user_session, sync_token, sliding_sync_version } =
[m[31m-        serde_json::from_str(&serialized_session)?;
[m[32m+    let FullSessionPersisted {
[m[32m+        client_session,
[m[32m+        user_session,
[m[32m+        sync_token,
[m[32m+        sliding_sync_version,
[m[32m+    } = serde_json::from_str(&serialized_session)?;
[m
     let status_str = format!(
         "Loaded session file for {user_id}. Trying to connect to homeserver ({})...",
Diff in /app/src/persistence/matrix_state.rs:176:
         .await?;
     let sliding_sync_version = sliding_sync_version.into();
     client.set_sliding_sync_version(sliding_sync_version);
[31m-    let status_str = format!("Authenticating previous login session for {}...", user_session.meta.user_id);
[m[32m+    let status_str = format!(
[m[32m+        "Authenticating previous login session for {}...",
[m[32m+        user_session.meta.user_id
[m[32m+    );
[m     log!("{status_str}");
     Cx::post_action(LoginAction::Status {
         title: "Authenticating session".into(),
Diff in /app/src/persistence/matrix_state.rs:213:
         client_session,
         user_session,
         sync_token: None,
[31m-        sliding_sync_version
[m[32m+        sliding_sync_version,
[m     })?;
     if let Some(parent) = session_file.parent() {
         tokio::fs::create_dir_all(parent).await?;
Diff in /app/src/persistence/matrix_state.rs:225:
 }

 /// Remove the LATEST_USER_ID_FILE_NAME file if it exists
[31m-///
[m[32m+///
[m /// Returns:
 /// - Ok(true) if file was found and deleted
 /// - Ok(false) if file didn't exist
Diff in /app/src/persistence/matrix_state.rs:232:
 /// - Err if deletion failed
 pub async fn delete_latest_user_id() -> anyhow::Result<bool> {
     let last_login_path = app_data_dir().join(LATEST_USER_ID_FILE_NAME);
[31m-
[m[32m+
[m     if last_login_path.exists() {
[31m-        tokio::fs::remove_file(&last_login_path).await
[m[32m+        tokio::fs::remove_file(&last_login_path)
[m[32m+            .await
[m             .map_err(|e| anyhow::anyhow!("Failed to remove latest user file: {e}"))
             .map(|_| true)
     } else {
Diff in /app/src/persistence/tsp_state.rs:17:
     app_data_dir().join(WALLETS_DIR_NAME)
 }

[31m-
[m /// The TSP state that is saved to persistent storage.
 ///
 /// It contains metadata about all wallets that have been created or imported.
Diff in /app/src/persistence/tsp_state.rs:39:
 impl SavedTspState {
     /// Returns true if this TSP state has any content.
     pub fn has_content(&self) -> bool {
[31m-        !self.wallets.is_empty()
[m[31m-            || self.default_wallet.is_some()
[m[31m-            || self.default_vid.is_some()
[m[32m+        !self.wallets.is_empty() || self.default_wallet.is_some() || self.default_vid.is_some()
[m     }

     pub fn num_wallets(&self) -> usize {
Diff in /app/src/persistence/tsp_state.rs:48:
[31m-        self.default_wallet.is_some() as usize
[m[31m-            + self.wallets.len()
[m[32m+        self.default_wallet.is_some() as usize + self.wallets.len()
[m     }
 }

Diff in /app/src/persistence/tsp_state.rs:53:
[31m-
[m /// Loads the TSP state from persistent storage.
 pub async fn load_tsp_state() -> anyhow::Result<SavedTspState> {
[31m-    let content = match tokio::fs::read_to_string(
[m[31m-        app_data_dir().join(TSP_STATE_FILE_NAME)
[m[31m-    ).await {
[m[32m+    let content = match tokio::fs::read_to_string(app_data_dir().join(TSP_STATE_FILE_NAME)).await {
[m         Ok(file) => file,
         Err(e) if e.kind() == std::io::ErrorKind::NotFound => return Ok(SavedTspState::default()),
[31m-        Err(e) => return Err(e.into())
[m[32m+        Err(e) => return Err(e.into()),
[m     };
[31m-    serde_json::from_str(&content)
[m[31m-        .map_err(anyhow::Error::msg)
[m[32m+    serde_json::from_str(&content).map_err(anyhow::Error::msg)
[m }

 /// Asynchronously save the current TSP state to persistent storage.
Diff in /app/src/profile/user_profile.rs:1:
 //! Widgets and types related to displaying info about a user profile.

[31m-use std::{borrow::Cow, ops::{Deref, DerefMut}};
[m[32m+use std::{
[m[32m+    borrow::Cow,
[m[32m+    ops::{Deref, DerefMut},
[m[32m+};
[m use makepad_widgets::*;
[31m-use matrix_sdk::{room::{RoomMember, RoomMemberRole}, ruma::{events::room::member::MembershipState, OwnedRoomId, OwnedUserId}};
[m[32m+use matrix_sdk::{
[m[32m+    room::{RoomMember, RoomMemberRole},
[m[32m+    ruma::{events::room::member::MembershipState, OwnedRoomId, OwnedUserId},
[m[32m+};
[m use crate::{
[31m-    avatar_cache, shared::{avatar::{AvatarState, AvatarWidgetExt}, popup_list::{PopupKind, enqueue_popup_notification}}, sliding_sync::{MatrixRequest, current_user_id, is_user_ignored, submit_async_request}, utils
[m[32m+    avatar_cache,
[m[32m+    shared::{
[m[32m+        avatar::{AvatarState, AvatarWidgetExt},
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    },
[m[32m+    sliding_sync::{MatrixRequest, current_user_id, is_user_ignored, submit_async_request},
[m[32m+    utils,
[m };
 use super::user_profile_cache;

Diff in /app/src/profile/user_profile.rs:11:
[31m-
[m /// Information retrieved about a user: their displayable name, ID, and known avatar state.
 #[derive(Clone, Debug)]
 pub struct UserProfile {
Diff in /app/src/profile/user_profile.rs:34:
     /// skipping any leading "@" characters.
     #[allow(unused)]
     pub fn first_letter(&self) -> &str {
[31m-        self.username.as_deref()
[m[32m+        self.username
[m[32m+            .as_deref()
[m             .and_then(|un| utils::user_name_first_letter(un))
             .or_else(|| utils::user_name_first_letter(self.user_id.as_str()))
             .unwrap_or_default()
Diff in /app/src/profile/user_profile.rs:41:
     }
 }

[31m-
[m /// Basic info needed to populate the contents of an avatar widget.
 #[derive(Clone, Debug)]
 pub struct UserProfileAndRoomId {
Diff in /app/src/profile/user_profile.rs:126:
         }

         <LineH> { padding: 15 }
[31m-
[m[32m+
[m         membership = <View> {
             width: Fill,
             height: Fit,
Diff in /app/src/profile/user_profile.rs:336:
     }
 }

[31m-
[m #[derive(Clone, DefaultNone, Debug)]
 pub enum ShowUserProfileAction {
     ShowUserProfile(UserProfileAndRoomId),
Diff in /app/src/profile/user_profile.rs:371:
     }

     fn membership_status(&self) -> &str {
[31m-        self.room_member.as_ref().map_or(
[m[31m-            "Not a Member",
[m[31m-            |member| match member.membership() {
[m[32m+        self.room_member
[m[32m+            .as_ref()
[m[32m+            .map_or("Not a Member", |member| match member.membership() {
[m                 MembershipState::Join => "Status: Joined",
                 MembershipState::Leave => "Status: Left",
                 MembershipState::Ban => "Status: Banned",
Diff in /app/src/profile/user_profile.rs:380:
                 MembershipState::Invite => "Status: Invited",
                 MembershipState::Knock => "Status: Knocking",
                 _ => "Status: Unknown",
[31m-            }
[m[31m-        )
[m[32m+            })
[m     }

     fn role_in_room(&self) -> Cow<'_, str> {
Diff in /app/src/profile/user_profile.rs:388:
[31m-        self.room_member.as_ref().map_or(
[m[31m-            "Role: Unknown".into(),
[m[31m-            |member| match member.suggested_role_for_power_level() {
[m[31m-                RoomMemberRole::Creator => "Role: Creator".into(),
[m[31m-                RoomMemberRole::Administrator => "Role: Admin".into(),
[m[31m-                RoomMemberRole::Moderator => "Role: Moderator".into(),
[m[31m-                RoomMemberRole::User => "Role: Standard User".into(),
[m[31m-            }
[m[31m-        )
[m[32m+        self.room_member
[m[32m+            .as_ref()
[m[32m+            .map_or("Role: Unknown".into(), |member| {
[m[32m+                match member.suggested_role_for_power_level() {
[m[32m+                    RoomMemberRole::Creator => "Role: Creator".into(),
[m[32m+                    RoomMemberRole::Administrator => "Role: Admin".into(),
[m[32m+                    RoomMemberRole::Moderator => "Role: Moderator".into(),
[m[32m+                    RoomMemberRole::User => "Role: Standard User".into(),
[m[32m+                }
[m[32m+            })
[m     }
 }

Diff in /app/src/profile/user_profile.rs:400:
 #[derive(Live, LiveHook, Widget)]
 pub struct UserProfileSlidingPane {
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m
[31m-    #[rust] info: Option<UserProfilePaneInfo>,
[m[31m-    #[rust] is_animating_out: bool,
[m[32m+    #[rust]
[m[32m+    info: Option<UserProfilePaneInfo>,
[m[32m+    #[rust]
[m[32m+    is_animating_out: bool,
[m }

 impl Widget for UserProfileSlidingPane {
Diff in /app/src/profile/user_profile.rs:410:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);

[31m-        if !self.visible { return; }
[m[32m+        if !self.visible {
[m[32m+            return;
[m[32m+        }
[m
         let animator_action = self.animator_handle_event(cx, event);
         if animator_action.must_redraw() {
Diff in /app/src/profile/user_profile.rs:430:
                 (false, true) => {
                     self.is_animating_out = true;
                 }
[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }

Diff in /app/src/profile/user_profile.rs:446:
             matches!(
                 event,
                 Event::Actions(actions) if self.button(ids!(close_button)).clicked(actions)
[31m-            )
[m[31m-            || event.back_pressed()
[m[31m-            || match event.hits_with_capture_overload(cx, area, true) {
[m[31m-                Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[31m-                Hit::FingerDown(_fde) => {
[m[31m-                    cx.set_key_focus(area);
[m[31m-                    false
[m[32m+            ) || event.back_pressed()
[m[32m+                || match event.hits_with_capture_overload(cx, area, true) {
[m[32m+                    Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[32m+                    Hit::FingerDown(_fde) => {
[m[32m+                        cx.set_key_focus(area);
[m[32m+                        false
[m[32m+                    }
[m[32m+                    Hit::FingerUp(fue) if fue.is_over => {
[m[32m+                        fue.mouse_button().is_some_and(|b| b.is_back())
[m[32m+                            || !self
[m[32m+                                .view(ids!(main_content))
[m[32m+                                .area()
[m[32m+                                .rect(cx)
[m[32m+                                .contains(fue.abs)
[m[32m+                    }
[m[32m+                    _ => false,
[m                 }
[31m-                Hit::FingerUp(fue) if fue.is_over => {
[m[31m-                    fue.mouse_button().is_some_and(|b| b.is_back())
[m[31m-                    || !self.view(ids!(main_content)).area().rect(cx).contains(fue.abs)
[m[31m-                }
[m[31m-                _ => false,
[m[31m-            }
[m         };
         if close_pane {
             self.animator_play(cx, ids!(panel.hide));
Diff in /app/src/profile/user_profile.rs:480:
                     our_info.user_id.clone(),
                     Some(&our_info.room_id),
                     false,
[31m-                    |profile, rooms| (profile.clone(), rooms.get(&our_info.room_id).cloned())
[m[32m+                    |profile, rooms| (profile.clone(), rooms.get(&our_info.room_id).cloned()),
[m                 ) {
                     let prev_avatar_state = our_info.avatar_state.clone();
                     our_info.user_profile = new_profile;
Diff in /app/src/profile/user_profile.rs:487:
                     our_info.room_member = room_member;
                     // Use the avatar URI from the `room_member`, as it will be the most up-to-date
                     // and specific to the room that this user profile sliding pane is currently being shown for.
[31m-                    if let Some(avatar_uri) = our_info.room_member.as_ref()
[m[32m+                    if let Some(avatar_uri) = our_info
[m[32m+                        .room_member
[m[32m+                        .as_ref()
[m                         .and_then(|rm| rm.avatar_url().map(|u| u.to_owned()))
                     {
                         our_info.avatar_state = AvatarState::Known(Some(avatar_uri));
Diff in /app/src/profile/user_profile.rs:498:
                     // If the new avatar state is fully `Loaded`, keep it as is.
                     // If the new avatar state is *not* fully `Loaded`, but the previous one was, keep the previous one.
                     match (prev_avatar_state, &mut our_info.avatar_state) {
[31m-                        (_,                             AvatarState::Loaded(_)) => { }
[m[31m-                        (prev @ AvatarState::Loaded(_), existing_avatar_state ) => {
[m[32m+                        (_, AvatarState::Loaded(_)) => {}
[m[32m+                        (prev @ AvatarState::Loaded(_), existing_avatar_state) => {
[m                             *existing_avatar_state = prev;
                         }
[31m-                        _ => { }
[m[32m+                        _ => {}
[m                     }
                     redraw_this_pane = true;
                 }
Diff in /app/src/profile/user_profile.rs:512:
             }
         }

[31m-        let Some(info) = self.info.as_ref() else { return };
[m[32m+        let Some(info) = self.info.as_ref() else {
[m[32m+            return;
[m[32m+        };
[m
         if let Event::Actions(actions) = event {
             if self.button(ids!(direct_message_button)).clicked(actions) {
Diff in /app/src/profile/user_profile.rs:545:
                         room_id: info.room_id.clone(),
                         room_member: room_member.clone(),
                     });
[31m-                    log!("Submitting request to {}ignore user {}.",
[m[32m+                    log!(
[m[32m+                        "Submitting request to {}ignore user {}.",
[m                         if room_member.is_ignored() { "un" } else { "" },
                         info.user_id,
                     );
Diff in /app/src/profile/user_profile.rs:554:
         }
     }

[31m-
[m     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         let Some(info) = self.info.as_ref() else {
             self.visible = false;
Diff in /app/src/profile/user_profile.rs:562:
         };

         // Set the user name, using the user ID as a fallback.
[31m-        self.label(ids!(user_name)).set_text(cx, info.displayable_name());
[m[31m-        self.label(ids!(user_id)).set_text(cx, info.user_id.as_str());
[m[32m+        self.label(ids!(user_name))
[m[32m+            .set_text(cx, info.displayable_name());
[m[32m+        self.label(ids!(user_id))
[m[32m+            .set_text(cx, info.user_id.as_str());
[m
         // Set the avatar image, using the user name as a fallback.
         let avatar_ref = self.avatar(ids!(avatar));
Diff in /app/src/profile/user_profile.rs:570:
         info.avatar_state
             .data()
[31m-            .and_then(|data| avatar_ref.show_image(cx, None, |cx, img| utils::load_png_or_jpg(&img, cx, data)).ok())
[m[32m+            .and_then(|data| {
[m[32m+                avatar_ref
[m[32m+                    .show_image(cx, None, |cx, img| utils::load_png_or_jpg(&img, cx, data))
[m[32m+                    .ok()
[m[32m+            })
[m             .unwrap_or_else(|| avatar_ref.show_text(cx, None, None, info.displayable_name()));

         // Set the membership status and role in the room.
Diff in /app/src/profile/user_profile.rs:576:
[31m-        self.label(ids!(membership_title_label)).set_text(cx, &info.membership_title());
[m[31m-        self.label(ids!(membership_status_label)).set_text(cx, info.membership_status());
[m[31m-        self.label(ids!(role_info_label)).set_text(cx, info.role_in_room().as_ref());
[m[32m+        self.label(ids!(membership_title_label))
[m[32m+            .set_text(cx, &info.membership_title());
[m[32m+        self.label(ids!(membership_status_label))
[m[32m+            .set_text(cx, info.membership_status());
[m[32m+        self.label(ids!(role_info_label))
[m[32m+            .set_text(cx, info.role_in_room().as_ref());
[m
         // Draw and show/hide the buttons according to user and room membership info:
         // * `direct_message_button` is hidden if the user is the same as the account user,
Diff in /app/src/profile/user_profile.rs:585:
         // * `ignore_user_button` is hidden if the user is not a member of the room,
         //    or if the user is the same as the account user, since you cannot ignore yourself.
         //    * The button text changes to "Unignore" if the user is already ignored.
[31m-        let is_pane_showing_current_account = info.room_member.as_ref()
[m[32m+        let is_pane_showing_current_account = info
[m[32m+            .room_member
[m[32m+            .as_ref()
[m             .map(|rm| rm.is_account_user())
             .unwrap_or_else(|| current_user_id().is_some_and(|uid| uid == info.user_id));

Diff in /app/src/profile/user_profile.rs:592:
[31m-        self.button(ids!(direct_message_button)).set_visible(cx, !is_pane_showing_current_account);
[m[32m+        self.button(ids!(direct_message_button))
[m[32m+            .set_visible(cx, !is_pane_showing_current_account);
[m
         let ignore_user_button = self.button(ids!(ignore_user_button));
[31m-        ignore_user_button.set_visible(cx, !is_pane_showing_current_account && info.room_member.is_some());
[m[32m+        ignore_user_button.set_visible(
[m[32m+            cx,
[m[32m+            !is_pane_showing_current_account && info.room_member.is_some(),
[m[32m+        );
[m         // Unfortunately the Matrix SDK's RoomMember type does not properly track
         // the `ignored` state of a user, so we have to maintain it separately.
[31m-        let is_ignored = info.room_member.as_ref()
[m[32m+        let is_ignored = info
[m[32m+            .room_member
[m[32m+            .as_ref()
[m             .is_some_and(|rm| is_user_ignored(rm.user_id()));
         ignore_user_button.set_text(
             cx,
Diff in /app/src/profile/user_profile.rs:602:
[31m-            if is_ignored { "Unignore (Unblock) User" } else { "Ignore (Block) User" }
[m[32m+            if is_ignored {
[m[32m+                "Unignore (Unblock) User"
[m[32m+            } else {
[m[32m+                "Ignore (Block) User"
[m[32m+            },
[m         );

         self.view.draw_walk(cx, scope, walk)
Diff in /app/src/profile/user_profile.rs:606:
     }
 }

[31m-
[m impl UserProfileSlidingPane {
     /// Returns `true` if this pane is currently being shown.
     pub fn is_currently_shown(&self, _cx: &mut Cx) -> bool {
Diff in /app/src/profile/user_profile.rs:626:
                 info.user_id.clone(),
                 Some(&info.room_id),
                 true,
[31m-                |profile, rooms| (profile.clone(), rooms.get(&info.room_id).cloned())
[m[32m+                |profile, rooms| (profile.clone(), rooms.get(&info.room_id).cloned()),
[m             ) {
                 log!("Found user {} room member info in cache", info.user_id);
                 // Update avatar state, preferring that of the room member info.
Diff in /app/src/profile/user_profile.rs:633:
                 if let Some(uri) = room_member.avatar_url() {
                     info.avatar_state = AvatarState::Known(Some(uri.to_owned()));
[31m-                }
[m[31m-                else {
[m[32m+                } else {
[m                     match new_profile.avatar_state {
                         s @ AvatarState::Known(Some(_)) | s @ AvatarState::Loaded(_) => {
                             info.avatar_state = s.clone();
Diff in /app/src/profile/user_profile.rs:643:
                 }
                 // Update displayable username.
                 if info.username.is_none() {
[31m-                    info.username = room_member.display_name()
[m[32m+                    info.username = room_member
[m[32m+                        .display_name()
[m                         .map(|dn| dn.to_owned())
                         .or_else(|| new_profile.username.clone());
                 }
Diff in /app/src/profile/user_profile.rs:651:
             }
         }
         info.avatar_state.update_from_cache(cx);
[31m-
[m[32m+
[m         // If TSP is enabled, populate the TSP verification info for this user.
[31m-        #[cfg(feature = "tsp")] {
[m[32m+        #[cfg(feature = "tsp")]
[m[32m+        {
[m             use crate::tsp::verify_user::TspVerifyUserWidgetExt;
[31m-            self.view.tsp_verify_user(ids!(tsp_verify_user))
[m[32m+            self.view
[m[32m+                .tsp_verify_user(ids!(tsp_verify_user))
[m                 .show(cx, info.user_id.clone());
         }

Diff in /app/src/profile/user_profile.rs:669:
         self.view(ids!(bg_view)).set_visible(cx, true);

         self.view.button(ids!(close_button)).reset_hover(cx);
[31m-        self.view.button(ids!(direct_message_button)).reset_hover(cx);
[m[31m-        self.view.button(ids!(copy_link_to_user_button)).reset_hover(cx);
[m[31m-        self.view.button(ids!(jump_to_read_receipt_button)).reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(direct_message_button))
[m[32m+            .reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(copy_link_to_user_button))
[m[32m+            .reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(jump_to_read_receipt_button))
[m[32m+            .reset_hover(cx);
[m         self.view.button(ids!(ignore_user_button)).reset_hover(cx);
         self.redraw(cx);
     }
Diff in /app/src/profile/user_profile.rs:680:
 impl UserProfileSlidingPaneRef {
     /// See [`UserProfileSlidingPane::is_currently_shown()`]
     pub fn is_currently_shown(&self, cx: &mut Cx) -> bool {
[31m-        let Some(inner) = self.borrow() else { return false };
[m[32m+        let Some(inner) = self.borrow() else {
[m[32m+            return false;
[m[32m+        };
[m         inner.is_currently_shown(cx)
     }

Diff in /app/src/profile/user_profile.rs:687:
     /// See [`UserProfileSlidingPane::set_info()`]
     pub fn set_info(&self, _cx: &mut Cx, info: UserProfilePaneInfo) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.set_info(_cx, info);
     }

Diff in /app/src/profile/user_profile.rs:693:
     /// See [`UserProfileSlidingPane::show()`]
     pub fn show(&self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx);
     }
 }
Diff in /app/src/profile/user_profile_cache.rs:4:

 use crossbeam_queue::SegQueue;
 use makepad_widgets::{warning, Cx, SignalToUI};
[31m-use matrix_sdk::{room::RoomMember, ruma::{OwnedRoomId, OwnedUserId, UserId}};
[m[31m-use std::{cell::RefCell, collections::{btree_map::Entry, BTreeMap}};
[m[32m+use matrix_sdk::{
[m[32m+    room::RoomMember,
[m[32m+    ruma::{OwnedRoomId, OwnedUserId, UserId},
[m[32m+};
[m[32m+use std::{
[m[32m+    cell::RefCell,
[m[32m+    collections::{btree_map::Entry, BTreeMap},
[m[32m+};
[m
[31m-use crate::{shared::avatar::AvatarState, sliding_sync::{submit_async_request, MatrixRequest}};
[m[32m+use crate::{
[m[32m+    shared::avatar::AvatarState,
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest},
[m[32m+};
[m
 use super::user_profile::UserProfile;

Diff in /app/src/profile/user_profile_cache.rs:67:
     /// Applies this update to the given user profile info cache.
     fn apply_to_cache(self, cache: &mut BTreeMap<OwnedUserId, UserProfileCacheEntry>) {
         match self {
[31m-            UserProfileUpdate::Full { new_profile, room_id, room_member } => {
[m[31m-                match cache.entry(new_profile.user_id.clone()) {
[m[31m-                    Entry::Occupied(mut entry) => match entry.get_mut() {
[m[31m-                        e @ UserProfileCacheEntry::Requested => {
[m[31m-                            *e = UserProfileCacheEntry::Loaded {
[m[31m-                                user_profile: new_profile,
[m[31m-                                rooms: {
[m[31m-                                    let mut room_members_map = BTreeMap::new();
[m[31m-                                    room_members_map.insert(room_id, room_member);
[m[31m-                                    room_members_map
[m[31m-                                },
[m[31m-                            };
[m[31m-                        }
[m[31m-                        UserProfileCacheEntry::Loaded { user_profile, rooms } => {
[m[31m-                            *user_profile = new_profile;
[m[31m-                            rooms.insert(room_id, room_member);
[m[31m-                        }
[m[31m-                    }
[m[31m-                    Entry::Vacant(entry) => {
[m[31m-                        entry.insert(UserProfileCacheEntry::Loaded {
[m[32m+            UserProfileUpdate::Full {
[m[32m+                new_profile,
[m[32m+                room_id,
[m[32m+                room_member,
[m[32m+            } => match cache.entry(new_profile.user_id.clone()) {
[m[32m+                Entry::Occupied(mut entry) => match entry.get_mut() {
[m[32m+                    e @ UserProfileCacheEntry::Requested => {
[m[32m+                        *e = UserProfileCacheEntry::Loaded {
[m                             user_profile: new_profile,
                             rooms: {
                                 let mut room_members_map = BTreeMap::new();
Diff in /app/src/profile/user_profile_cache.rs:93:
                                 room_members_map.insert(room_id, room_member);
                                 room_members_map
                             },
[31m-                        });
[m[32m+                        };
[m                     }
[32m+                    UserProfileCacheEntry::Loaded {
[m[32m+                        user_profile,
[m[32m+                        rooms,
[m[32m+                    } => {
[m[32m+                        *user_profile = new_profile;
[m[32m+                        rooms.insert(room_id, room_member);
[m[32m+                    }
[m[32m+                },
[m[32m+                Entry::Vacant(entry) => {
[m[32m+                    entry.insert(UserProfileCacheEntry::Loaded {
[m[32m+                        user_profile: new_profile,
[m[32m+                        rooms: {
[m[32m+                            let mut room_members_map = BTreeMap::new();
[m[32m+                            room_members_map.insert(room_id, room_member);
[m[32m+                            room_members_map
[m[32m+                        },
[m[32m+                    });
[m                 }
[31m-            }
[m[31m-            UserProfileUpdate::RoomMemberOnly { room_id, room_member } => {
[m[32m+            },
[m[32m+            UserProfileUpdate::RoomMemberOnly {
[m[32m+                room_id,
[m[32m+                room_member,
[m[32m+            } => {
[m                 match cache.entry(room_member.user_id().to_owned()) {
                     Entry::Occupied(mut entry) => match entry.get_mut() {
                         e @ UserProfileCacheEntry::Requested => {
Diff in /app/src/profile/user_profile_cache.rs:104:
                             // This shouldn't happen, but we can still technically handle it correctly.
[31m-                            warning!("BUG: User profile cache entry was `Requested` for user {} when handling RoomMemberOnly update", room_member.user_id());
[m[32m+                            warning!(
[m[32m+                                "BUG: User profile cache entry was `Requested` for user {} when handling RoomMemberOnly update",
[m[32m+                                room_member.user_id()
[m[32m+                            );
[m                             *e = UserProfileCacheEntry::Loaded {
                                 user_profile: UserProfile {
                                     user_id: room_member.user_id().to_owned(),
Diff in /app/src/profile/user_profile_cache.rs:109:
                                     username: None,
[31m-                                    avatar_state: AvatarState::Known(room_member.avatar_url().map(|url| url.to_owned())),
[m[32m+                                    avatar_state: AvatarState::Known(
[m[32m+                                        room_member.avatar_url().map(|url| url.to_owned()),
[m[32m+                                    ),
[m                                 },
                                 rooms: {
                                     let mut room_members_map = BTreeMap::new();
Diff in /app/src/profile/user_profile_cache.rs:119:
                         UserProfileCacheEntry::Loaded { rooms, .. } => {
                             rooms.insert(room_id, room_member);
                         }
[31m-                    }
[m[32m+                    },
[m                     Entry::Vacant(entry) => {
                         // This shouldn't happen, but we can still technically handle it correctly.
[31m-                        warning!("BUG: User profile cache entry not found for user {} when handling RoomMemberOnly update", room_member.user_id());
[m[32m+                        warning!(
[m[32m+                            "BUG: User profile cache entry not found for user {} when handling RoomMemberOnly update",
[m[32m+                            room_member.user_id()
[m[32m+                        );
[m                         entry.insert(UserProfileCacheEntry::Loaded {
                             user_profile: UserProfile {
                                 user_id: room_member.user_id().to_owned(),
Diff in /app/src/profile/user_profile_cache.rs:129:
                                 username: None,
[31m-                                avatar_state: AvatarState::Known(room_member.avatar_url().map(|url| url.to_owned())),
[m[32m+                                avatar_state: AvatarState::Known(
[m[32m+                                    room_member.avatar_url().map(|url| url.to_owned()),
[m[32m+                                ),
[m                             },
                             rooms: {
                                 let mut room_members_map = BTreeMap::new();
Diff in /app/src/profile/user_profile_cache.rs:150:
                         UserProfileCacheEntry::Loaded { user_profile, .. } => {
                             *user_profile = new_profile;
                         }
[31m-                    }
[m[32m+                    },
[m                     Entry::Vacant(entry) => {
                         entry.insert(UserProfileCacheEntry::Loaded {
                             user_profile: new_profile,
Diff in /app/src/profile/user_profile_cache.rs:193:
 where
     F: FnOnce(&UserProfile, &BTreeMap<OwnedRoomId, RoomMember>) -> R,
 {
[31m-    USER_PROFILE_CACHE.with_borrow_mut(|cache|
[m[31m-        match cache.entry(user_id) {
[m[31m-            Entry::Occupied(entry) => match entry.get() {
[m[31m-                UserProfileCacheEntry::Loaded { user_profile, rooms } => {
[m[31m-                    if room_id.is_some_and(|id| !rooms.contains_key(id)) {
[m[31m-                        submit_async_request(MatrixRequest::GetUserProfile {
[m[31m-                            user_id: entry.key().clone(),
[m[31m-                            room_id: room_id.cloned(),
[m[31m-                            local_only: false,
[m[31m-                        });
[m[31m-                    }
[m[31m-                    Some(f(user_profile, rooms))
[m[31m-                }
[m[31m-                UserProfileCacheEntry::Requested => {
[m[31m-                    // log!("User {} profile request is already in flight....", entry.key());
[m[31m-                    None
[m[31m-                }
[m[31m-            }
[m[31m-            Entry::Vacant(entry) => {
[m[31m-                if fetch_if_missing {
[m[31m-                    // log!("Did not find User {} in cache, fetching from server.", entry.key());
[m[31m-                    // TODO: use the extra `via` parameters from `matrix_to_uri.via()`.
[m[32m+    USER_PROFILE_CACHE.with_borrow_mut(|cache| match cache.entry(user_id) {
[m[32m+        Entry::Occupied(entry) => match entry.get() {
[m[32m+            UserProfileCacheEntry::Loaded {
[m[32m+                user_profile,
[m[32m+                rooms,
[m[32m+            } => {
[m[32m+                if room_id.is_some_and(|id| !rooms.contains_key(id)) {
[m                     submit_async_request(MatrixRequest::GetUserProfile {
                         user_id: entry.key().clone(),
                         room_id: room_id.cloned(),
Diff in /app/src/profile/user_profile_cache.rs:221:
                         local_only: false,
                     });
[31m-                    entry.insert(UserProfileCacheEntry::Requested);
[m                 }
[32m+                Some(f(user_profile, rooms))
[m[32m+            }
[m[32m+            UserProfileCacheEntry::Requested => {
[m[32m+                // log!("User {} profile request is already in flight....", entry.key());
[m                 None
             }
[32m+        },
[m[32m+        Entry::Vacant(entry) => {
[m[32m+            if fetch_if_missing {
[m[32m+                // log!("Did not find User {} in cache, fetching from server.", entry.key());
[m[32m+                // TODO: use the extra `via` parameters from `matrix_to_uri.via()`.
[m[32m+                submit_async_request(MatrixRequest::GetUserProfile {
[m[32m+                    user_id: entry.key().clone(),
[m[32m+                    room_id: room_id.cloned(),
[m[32m+                    local_only: false,
[m[32m+                });
[m[32m+                entry.insert(UserProfileCacheEntry::Requested);
[m[32m+            }
[m[32m+            None
[m         }
[31m-    )
[m[32m+    })
[m }

[31m-
[m /// Returns the given user's displayable name (optionally in the given room),
 /// using the user's account-wide displayable name as a fallback.
 ///
Diff in /app/src/profile/user_profile_cache.rs:276:

     pub fn as_deref(&self) -> Option<&str> {
         match self {
[31m-            CachedName::FoundInRoom(name)
[m[31m-            | CachedName::FoundInProfile(name) => name.as_deref(),
[m[32m+            CachedName::FoundInRoom(name) | CachedName::FoundInProfile(name) => name.as_deref(),
[m             CachedName::NotFound => None,
         }
     }
Diff in /app/src/profile/user_profile_cache.rs:294:

 /// Clears cached user profile.
 /// This function requires passing in a reference to `Cx`,
[31m-/// which acts as a guarantee that these thread-local caches are cleared on the main UI thread,
[m[32m+/// which acts as a guarantee that these thread-local caches are cleared on the main UI thread,
[m pub fn clear_user_profile_cache(_cx: &mut Cx) {
     // Clear user profile cache
     USER_PROFILE_CACHE.with_borrow_mut(|cache| {
Diff in /app/src/room/mod.rs:3:
 use std::sync::Arc;
 use makepad_widgets::Cx;
 use matrix_sdk::{RoomDisplayName, RoomHero, RoomState, SuccessorRoom, room_preview::RoomPreview};
[31m-use ruma::{OwnedRoomAliasId, OwnedRoomId, room::{JoinRuleSummary, RoomType}};
[m[32m+use ruma::{
[m[32m+    OwnedRoomAliasId, OwnedRoomId,
[m[32m+    room::{JoinRuleSummary, RoomType},
[m[32m+};
[m
 use crate::utils::RoomNameId;

Diff in /app/src/room/mod.rs:50:
 }
 impl From<FetchedRoomPreview> for BasicRoomDetails {
     fn from(frp: FetchedRoomPreview) -> Self {
[31m-       BasicRoomDetails::FetchedRoomPreview(frp)
[m[32m+        BasicRoomDetails::FetchedRoomPreview(frp)
[m     }
 }
 impl BasicRoomDetails {
Diff in /app/src/room/mod.rs:58:
         match self {
             Self::RoomId(room_name_id)
             | Self::Name(room_name_id)
[31m-            | Self::NameAndAvatar { room_name_id, ..} => room_name_id.room_id(),
[m[32m+            | Self::NameAndAvatar { room_name_id, .. } => room_name_id.room_id(),
[m             Self::FetchedRoomPreview(frp) => frp.room_name_id.room_id(),
         }
     }
Diff in /app/src/room/mod.rs:80:
     /// If this is the `RoomId` or `Name` variants, the avatar will be empty.
     pub fn room_avatar(&self) -> &FetchedRoomAvatar {
         match self {
[31m-            Self::RoomId(_)
[m[31m-            | Self::Name(_) => &EMPTY_AVATAR,
[m[31m-            Self::NameAndAvatar { room_avatar, ..} => room_avatar,
[m[32m+            Self::RoomId(_) | Self::Name(_) => &EMPTY_AVATAR,
[m[32m+            Self::NameAndAvatar { room_avatar, .. } => room_avatar,
[m             Self::FetchedRoomPreview(frp) => &frp.room_avatar,
         }
     }
Diff in /app/src/room/mod.rs:89:
 }

[31m-
[m /// Actions related to room previews being fetched.
 #[derive(Debug)]
 pub enum RoomPreviewAction {
Diff in /app/src/room/mod.rs:104:
     pub room_avatar: FetchedRoomAvatar,

     // Below: copied from the `RoomPreview` struct.
[31m-
[m     /// The canonical alias for the room.
     pub canonical_alias: Option<OwnedRoomAliasId>,
     /// The room's topic, if set.
Diff in /app/src/room/mod.rs:131:
 }
 impl FetchedRoomPreview {
     pub fn from(room_preview: RoomPreview, room_avatar: FetchedRoomAvatar) -> Self {
[31m-        let display_name = room_preview.name.map_or(
[m[31m-            RoomDisplayName::Empty,
[m[31m-            RoomDisplayName::Named,
[m[31m-        );
[m[32m+        let display_name = room_preview
[m[32m+            .name
[m[32m+            .map_or(RoomDisplayName::Empty, RoomDisplayName::Named);
[m         Self {
             room_name_id: RoomNameId::new(display_name, room_preview.room_id),
             room_avatar,
Diff in /app/src/room/mod.rs:151:
         }
     }
 }
[31m-
[m
 static EMPTY_AVATAR: FetchedRoomAvatar = FetchedRoomAvatar::Text(String::new());

Diff in /app/src/room/room_display_filter.rs:1:
 use std::{
[31m-    borrow::Cow, cmp::Ordering, collections::{BTreeMap, HashSet}, ops::Deref
[m[32m+    borrow::Cow,
[m[32m+    cmp::Ordering,
[m[32m+    collections::{BTreeMap, HashSet},
[m[32m+    ops::Deref,
[m };
 use bitflags::bitflags;
[31m-use matrix_sdk::{RoomDisplayName, ruma::{
[m[31m-    OwnedRoomAliasId, RoomAliasId, RoomId, events::tag::{TagName, Tags}
[m[31m-}};
[m[32m+use matrix_sdk::{
[m[32m+    RoomDisplayName,
[m[32m+    ruma::{
[m[32m+        OwnedRoomAliasId, RoomAliasId, RoomId,
[m[32m+        events::tag::{TagName, Tags},
[m[32m+    },
[m[32m+};
[m
[31m-use crate::{home::rooms_list::{InvitedRoomInfo, JoinedRoomInfo}, home::spaces_bar::JoinedSpaceInfo};
[m[32m+use crate::{
[m[32m+    home::rooms_list::{InvitedRoomInfo, JoinedRoomInfo},
[m[32m+    home::spaces_bar::JoinedSpaceInfo,
[m[32m+};
[m
 static EMPTY_TAGS: Tags = BTreeMap::new();

Diff in /app/src/room/room_display_filter.rs:142:
     }
 }

[31m-
[m pub type RoomFilterFn = dyn Fn(&dyn FilterableRoom) -> bool;
 pub type SortFn = dyn Fn(&dyn FilterableRoom, &dyn FilterableRoom) -> Ordering;

Diff in /app/src/room/room_display_filter.rs:245:
     }

     fn matches_room_name(room: &dyn FilterableRoom, keywords: &str) -> bool {
[31m-        room.room_name()
[m[31m-            .to_lowercase()
[m[31m-            .contains(keywords)
[m[32m+        room.room_name().to_lowercase().contains(keywords)
[m     }

     fn matches_room_alias(room: &dyn FilterableRoom, keywords: &str) -> bool {
Diff in /app/src/room/room_display_filter.rs:254:
         room.canonical_alias()
             .is_some_and(|alias| alias.as_str().eq_ignore_ascii_case(keywords))
[31m-        ||
[m[31m-        room.alt_aliases()
[m[31m-            .iter()
[m[31m-            .any(|alias| alias.as_str().eq_ignore_ascii_case(keywords))
[m[32m+            || room
[m[32m+                .alt_aliases()
[m[32m+                .iter()
[m[32m+                .any(|alias| alias.as_str().eq_ignore_ascii_case(keywords))
[m     }

     fn matches_room_tags(room: &dyn FilterableRoom, search_tags: &HashSet<String>) -> bool {
Diff in /app/src/room/room_display_filter.rs:267:
                     ["low_priority", "low-priority", "lowpriority", "lowPriority"]
                         .contains(&search_tag)
                 }
[31m-                TagName::ServerNotice => {
[m[31m-                    ["server_notice", "server-notice", "servernotice", "serverNotice"]
[m[31m-                        .contains(&search_tag)
[m[31m-                }
[m[32m+                TagName::ServerNotice => [
[m[32m+                    "server_notice",
[m[32m+                    "server-notice",
[m[32m+                    "servernotice",
[m[32m+                    "serverNotice",
[m[32m+                ]
[m[32m+                .contains(&search_tag),
[m                 TagName::User(user_tag) => user_tag.as_ref().eq_ignore_ascii_case(search_tag),
                 _ => false,
             }
Diff in /app/src/room/room_display_filter.rs:316:
                     RoomFilterCriteria::RoomId if criteria.contains(RoomFilterCriteria::RoomId) => {
                         Self::matches_room_id(room, &keywords)
                     }
[31m-                    RoomFilterCriteria::RoomAlias if criteria.contains(RoomFilterCriteria::RoomAlias) => {
[m[32m+                    RoomFilterCriteria::RoomAlias
[m[32m+                        if criteria.contains(RoomFilterCriteria::RoomAlias) =>
[m[32m+                    {
[m                         Self::matches_room_alias(room, &keywords)
                     }
[31m-                    RoomFilterCriteria::RoomTags if criteria.contains(RoomFilterCriteria::RoomTags) => {
[m[32m+                    RoomFilterCriteria::RoomTags
[m[32m+                        if criteria.contains(RoomFilterCriteria::RoomTags) =>
[m[32m+                    {
[m                         Self::matches_room_tags(room, &search_tags)
                     }
                     _ => false,
Diff in /app/src/room/room_input_bar.rs:15:
 //! * A "cannot-send-message" notice, which is shown if the user cannot send messages to the room.
 //!

[31m-
[m use makepad_widgets::*;
 use matrix_sdk::room::reply::{EnforceThread, Reply};
 use matrix_sdk_ui::timeline::{EmbeddedEvent, EventTimelineItem, TimelineEventItemId};
Diff in /app/src/room/room_input_bar.rs:22:
[31m-use ruma::{events::room::message::{LocationMessageEventContent, MessageType, RoomMessageEventContent}, OwnedRoomId};
[m[31m-use crate::{home::{editing_pane::{EditingPaneState, EditingPaneWidgetExt}, location_preview::LocationPreviewWidgetExt, room_screen::{populate_preview_of_timeline_item, MessageAction, RoomScreenProps}, tombstone_footer::{SuccessorRoomDetails, TombstoneFooterWidgetExt}}, location::init_location_subscriber, shared::{avatar::AvatarWidgetRefExt, html_or_plaintext::HtmlOrPlaintextWidgetRefExt, mentionable_text_input::MentionableTextInputWidgetExt, popup_list::{enqueue_popup_notification, PopupKind}, styles::*}, sliding_sync::{submit_async_request, MatrixRequest, UserPowerLevels}, utils};
[m[32m+use ruma::{
[m[32m+    events::room::message::{LocationMessageEventContent, MessageType, RoomMessageEventContent},
[m[32m+    OwnedRoomId,
[m[32m+};
[m[32m+use crate::{
[m[32m+    home::{
[m[32m+        editing_pane::{EditingPaneState, EditingPaneWidgetExt},
[m[32m+        location_preview::LocationPreviewWidgetExt,
[m[32m+        room_screen::{populate_preview_of_timeline_item, MessageAction, RoomScreenProps},
[m[32m+        tombstone_footer::{SuccessorRoomDetails, TombstoneFooterWidgetExt},
[m[32m+    },
[m[32m+    location::init_location_subscriber,
[m[32m+    shared::{
[m[32m+        avatar::AvatarWidgetRefExt,
[m[32m+        html_or_plaintext::HtmlOrPlaintextWidgetRefExt,
[m[32m+        mentionable_text_input::MentionableTextInputWidgetExt,
[m[32m+        popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+        styles::*,
[m[32m+    },
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest, UserPowerLevels},
[m[32m+    utils,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/room/room_input_bar.rs:170:
 /// Main component for message input with @mention support
 #[derive(Live, LiveHook, Widget)]
 pub struct RoomInputBar {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// Whether the `ReplyingPreview` was visible when the `EditingPane` was shown.
     /// If true, when the `EditingPane` gets hidden, we need to re-show the `ReplyingPreview`.
Diff in /app/src/room/room_input_bar.rs:177:
[31m-    #[rust] was_replying_preview_visible: bool,
[m[32m+    #[rust]
[m[32m+    was_replying_preview_visible: bool,
[m     /// Info about the message event that the user is currently replying to, if any.
[31m-    #[rust] replying_to: Option<(EventTimelineItem, EmbeddedEvent)>,
[m[32m+    #[rust]
[m[32m+    replying_to: Option<(EventTimelineItem, EmbeddedEvent)>,
[m }

 impl Widget for RoomInputBar {
Diff in /app/src/room/room_input_bar.rs:186:
             .get::<RoomScreenProps>()
             .expect("BUG: RoomScreenProps should be available in Scope::props for RoomInputBar");

[31m-        match event.hits(cx, self.view.view(ids!(replying_preview.reply_preview_content)).area()) {
[m[32m+        match event.hits(
[m[32m+            cx,
[m[32m+            self.view
[m[32m+                .view(ids!(replying_preview.reply_preview_content))
[m[32m+                .area(),
[m[32m+        ) {
[m             // If the hit occurred on the replying message preview, jump to it.
             Hit::FingerUp(fe) if fe.is_over && fe.is_primary_hit() && fe.was_tap() => {
[31m-                if let Some(event_id) = self.replying_to.as_ref()
[m[32m+                if let Some(event_id) = self
[m[32m+                    .replying_to
[m[32m+                    .as_ref()
[m                     .and_then(|(event_tl_item, _)| event_tl_item.event_id().map(ToOwned::to_owned))
                 {
                     cx.widget_action(
Diff in /app/src/room/room_input_bar.rs:232:

         // Clear the replying-to preview pane if the "cancel reply" button was clicked
         // or if the `Escape` key was pressed within the message input box.
[31m-        if self.button(ids!(cancel_reply_button)).clicked(actions)
[m[31m-            || text_input.escaped(actions)
[m[31m-        {
[m[32m+        if self.button(ids!(cancel_reply_button)).clicked(actions) || text_input.escaped(actions) {
[m             self.clear_replying_to(cx);
             self.redraw(cx);
         }
Diff in /app/src/room/room_input_bar.rs:255:
         }

         // Handle the send location button being clicked.
[31m-        if self.button(ids!(location_preview.send_location_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .button(ids!(location_preview.send_location_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             let location_preview = self.location_preview(ids!(location_preview));
             if let Some((coords, _system_time_opt)) = location_preview.get_current_data() {
[31m-                let geo_uri = format!("{}{},{}", utils::GEO_URI_SCHEME, coords.latitude, coords.longitude);
[m[31m-                let message = RoomMessageEventContent::new(
[m[31m-                    MessageType::Location(
[m[31m-                        LocationMessageEventContent::new(geo_uri.clone(), geo_uri)
[m[31m-                    )
[m[32m+                let geo_uri = format!(
[m[32m+                    "{}{},{}",
[m[32m+                    utils::GEO_URI_SCHEME,
[m[32m+                    coords.latitude,
[m[32m+                    coords.longitude
[m                 );
[32m+                let message = RoomMessageEventContent::new(MessageType::Location(
[m[32m+                    LocationMessageEventContent::new(geo_uri.clone(), geo_uri),
[m[32m+                ));
[m                 submit_async_request(MatrixRequest::SendMessage {
                     room_id: room_screen_props.room_name_id.room_id().clone(),
                     message,
Diff in /app/src/room/room_input_bar.rs:270:
[31m-                    replied_to: self.replying_to.take().and_then(|(event_tl_item, _emb)|
[m[31m-                        event_tl_item.event_id().map(|event_id|
[m[31m-                            Reply {
[m[31m-                                event_id: event_id.to_owned(),
[m[31m-                                enforce_thread: EnforceThread::MaybeThreaded,
[m[31m-                            }
[m[31m-                        )
[m[31m-                    ),
[m[32m+                    replied_to: self.replying_to.take().and_then(|(event_tl_item, _emb)| {
[m[32m+                        event_tl_item.event_id().map(|event_id| Reply {
[m[32m+                            event_id: event_id.to_owned(),
[m[32m+                            enforce_thread: EnforceThread::MaybeThreaded,
[m[32m+                        })
[m[32m+                    }),
[m                     #[cfg(feature = "tsp")]
                     sign_with_tsp: self.is_tsp_signing_enabled(cx),
                 });
Diff in /app/src/room/room_input_bar.rs:287:

         // Handle the send message button being clicked or Cmd/Ctrl + Return being pressed.
         if self.button(ids!(send_message_button)).clicked(actions)
[31m-            || text_input.returned(actions).is_some_and(|(_, m)| m.is_primary())
[m[32m+            || text_input
[m[32m+                .returned(actions)
[m[32m+                .is_some_and(|(_, m)| m.is_primary())
[m         {
             let entered_text = mentionable_text_input.text().trim().to_string();
             if !entered_text.is_empty() {
Diff in /app/src/room/room_input_bar.rs:295:
                 submit_async_request(MatrixRequest::SendMessage {
                     room_id: room_screen_props.room_name_id.room_id().clone(),
                     message,
[31m-                    replied_to: self.replying_to.take().and_then(|(event_tl_item, _emb)|
[m[31m-                        event_tl_item.event_id().map(|event_id|
[m[31m-                            Reply {
[m[31m-                                event_id: event_id.to_owned(),
[m[31m-                                enforce_thread: EnforceThread::MaybeThreaded,
[m[31m-                            }
[m[31m-                        )
[m[31m-                    ),
[m[32m+                    replied_to: self.replying_to.take().and_then(|(event_tl_item, _emb)| {
[m[32m+                        event_tl_item.event_id().map(|event_id| Reply {
[m[32m+                            event_id: event_id.to_owned(),
[m[32m+                            enforce_thread: EnforceThread::MaybeThreaded,
[m[32m+                        })
[m[32m+                    }),
[m                     #[cfg(feature = "tsp")]
                     sign_with_tsp: self.is_tsp_signing_enabled(cx),
                 });
Diff in /app/src/room/room_input_bar.rs:332:
         if is_text_input_empty {
             if let Some(KeyEvent {
                 key_code: KeyCode::ArrowUp,
[31m-                modifiers: KeyModifiers { shift: false, control: false, alt: false, logo: false },
[m[32m+                modifiers:
[m[32m+                    KeyModifiers {
[m[32m+                        shift: false,
[m[32m+                        control: false,
[m[32m+                        alt: false,
[m[32m+                        logo: false,
[m[32m+                    },
[m                 ..
[31m-            }) = text_input.key_down_unhandled(actions) {
[m[32m+            }) = text_input.key_down_unhandled(actions)
[m[32m+            {
[m                 cx.widget_action(
                     room_screen_props.room_screen_widget_uid,
                     &HeapLiveIdPath::default(),
Diff in /app/src/room/room_input_bar.rs:344:
         }

         // If the EditingPane has been hidden, handle that.
[31m-        if self.view.editing_pane(ids!(editing_pane)).was_hidden(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .editing_pane(ids!(editing_pane))
[m[32m+            .was_hidden(actions)
[m[32m+        {
[m             self.on_editing_pane_hidden(cx);
         }
     }
Diff in /app/src/room/room_input_bar.rs:398:
         //    so that the user can immediately start typing their reply
         //    without having to manually click on the message input box.
         if grab_key_focus {
[31m-            self.text_input(ids!(input_bar.mentionable_text_input.text_input)).set_key_focus(cx);
[m[32m+            self.text_input(ids!(input_bar.mentionable_text_input.text_input))
[m[32m+                .set_key_focus(cx);
[m         }
         self.redraw(cx);
     }
Diff in /app/src/room/room_input_bar.rs:454:
         self.redraw(cx);
         // We don't need to do anything with the editing pane itself here,
         // because it has already been hidden by the time this function gets called.
[31m-    }
[m[32m+    }
[m
     /// Updates (populates and shows or hides) this room's tombstone footer
     /// based on the given successor room details.
Diff in /app/src/room/room_input_bar.rs:488:
         } else {
             (COLOR_FG_DISABLED, COLOR_BG_DISABLED)
         };
[31m-        send_message_button.apply_over(cx, live! {
[m[31m-            enabled: (enable),
[m[31m-            draw_icon: {
[m[31m-                color: (fg_color),
[m[31m-                // color_hover: (fg_color),
[m[31m-            }
[m[31m-            draw_bg: {
[m[31m-                color: (bg_color),
[m[31m-            }
[m[31m-        });
[m[32m+        send_message_button.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                enabled: (enable),
[m[32m+                draw_icon: {
[m[32m+                    color: (fg_color),
[m[32m+                    // color_hover: (fg_color),
[m[32m+                }
[m[32m+                draw_bg: {
[m[32m+                    color: (bg_color),
[m[32m+                }
[m[32m+            },
[m[32m+        );
[m     }

     /// Updates the visibility of select views based on the user's new power levels.
Diff in /app/src/room/room_input_bar.rs:504:
     ///
     /// This will show/hide the `input_bar` and the `can_not_send_message_notice` views.
[31m-    fn update_user_power_levels(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        user_power_levels: UserPowerLevels,
[m[31m-    ) {
[m[32m+    fn update_user_power_levels(&mut self, cx: &mut Cx, user_power_levels: UserPowerLevels) {
[m         let can_send = user_power_levels.can_send_message();
         self.view.view(ids!(input_bar)).set_visible(cx, can_send);
[31m-        self.view.view(ids!(can_not_send_message_notice)).set_visible(cx, !can_send);
[m[32m+        self.view
[m[32m+            .view(ids!(can_not_send_message_notice))
[m[32m+            .set_visible(cx, !can_send);
[m     }

     /// Returns true if the TSP signing checkbox is checked, false otherwise.
Diff in /app/src/room/room_input_bar.rs:531:
         replying_to: (EventTimelineItem, EmbeddedEvent),
         room_id: &OwnedRoomId,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show_replying_to(cx, replying_to, room_id, true);
     }

Diff in /app/src/room/room_input_bar.rs:542:
         event_tl_item: EventTimelineItem,
         room_id: OwnedRoomId,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show_editing_pane(
             cx,
             ShowEditingPaneBehavior::ShowNew { event_tl_item },
Diff in /app/src/room/room_input_bar.rs:553:
     /// Updates the visibility of select views based on the user's new power levels.
     ///
     /// This will show/hide the `input_bar` and the `can_not_send_message_notice` views.
[31m-    pub fn update_user_power_levels(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        user_power_levels: UserPowerLevels,
[m[31m-    ) {
[m[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+    pub fn update_user_power_levels(&self, cx: &mut Cx, user_power_levels: UserPowerLevels) {
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.update_user_power_levels(cx, user_power_levels);
     }

Diff in /app/src/room/room_input_bar.rs:569:
         tombstoned_room_id: &OwnedRoomId,
         successor_room_details: Option<&SuccessorRoomDetails>,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.update_tombstone_footer(cx, tombstoned_room_id, successor_room_details);
     }

Diff in /app/src/room/room_input_bar.rs:581:
         timeline_event_item_id: TimelineEventItemId,
         edit_result: Result<(), matrix_sdk_ui::timeline::Error>,
     ) {
[31m-        let Some(inner) = self.borrow_mut() else { return };
[m[31m-        inner.editing_pane(ids!(editing_pane))
[m[31m-            .handle_edit_result(cx, timeline_event_item_id, edit_result);
[m[32m+        let Some(inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m[32m+        inner.editing_pane(ids!(editing_pane)).handle_edit_result(
[m[32m+            cx,
[m[32m+            timeline_event_item_id,
[m[32m+            edit_result,
[m[32m+        );
[m     }

     /// Save a snapshot of the UI state of this `RoomInputBar`.
Diff in /app/src/room/room_input_bar.rs:590:
     pub fn save_state(&self) -> RoomInputBarState {
[31m-        let Some(inner) = self.borrow() else { return Default::default() };
[m[32m+        let Some(inner) = self.borrow() else {
[m[32m+            return Default::default();
[m[32m+        };
[m         // Clear the location preview. We don't save this state because the
         // current location might change by the next time the user opens this same room.
         inner.location_preview(ids!(location_preview)).clear();
Diff in /app/src/room/room_input_bar.rs:596:
             was_replying_preview_visible: inner.was_replying_preview_visible,
             replying_to: inner.replying_to.clone(),
             editing_pane_state: inner.editing_pane(ids!(editing_pane)).save_state(),
[31m-            text_input_state: inner.text_input(ids!(input_bar.mentionable_text_input.text_input)).save_state(),
[m[32m+            text_input_state: inner
[m[32m+                .text_input(ids!(input_bar.mentionable_text_input.text_input))
[m[32m+                .save_state(),
[m         }
     }

Diff in /app/src/room/room_input_bar.rs:609:
         user_power_levels: UserPowerLevels,
         tombstone_info: Option<&SuccessorRoomDetails>,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         let RoomInputBarState {
             was_replying_preview_visible,
             text_input_state,
Diff in /app/src/room/room_input_bar.rs:625:
         inner.update_user_power_levels(cx, user_power_levels);

         // 1. Restore the state of the TextInput within the MentionableTextInput.
[31m-        inner.text_input(ids!(input_bar.mentionable_text_input.text_input))
[m[32m+        inner
[m[32m+            .text_input(ids!(input_bar.mentionable_text_input.text_input))
[m             .restore_state(cx, text_input_state);

         // 2. Restore the state of the replying-to preview.
Diff in /app/src/room/room_input_bar.rs:670:
 /// Defines what to do when showing the `EditingPane` from the `RoomInputBar`.
 enum ShowEditingPaneBehavior {
     /// Show a new edit session, e.g., when first clicking "edit" on a message.
[31m-    ShowNew {
[m[31m-        event_tl_item: EventTimelineItem,
[m[31m-    },
[m[32m+    ShowNew { event_tl_item: EventTimelineItem },
[m     /// Restore the state of an `EditingPane` that already existed, e.g., when
     /// reopening a room that had an `EditingPane` open when it was closed.
     RestoreExisting {
Diff in /app/src/room/typing_notice.rs:66:
 /// A notice that slides into view when someone is typing.
 #[derive(Live, LiveHook, Widget)]
 pub struct TypingNotice {
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m }

 impl Widget for TypingNotice {
Diff in /app/src/room/typing_notice.rs:90:
             [] => {
                 // Animate out the typing notice view (sliding it out towards the bottom).
                 self.animator_play(cx, ids!(typing_notice_animator.hide));
[31m-                self.view.bouncing_dots(ids!(bouncing_dots)).stop_animation(cx);
[m[32m+                self.view
[m[32m+                    .bouncing_dots(ids!(bouncing_dots))
[m[32m+                    .stop_animation(cx);
[m                 return;
             }
             [user] => format!("{user} is typing "),
Diff in /app/src/room/typing_notice.rs:99:
                 if others.len() > 1 {
                     format!("{user1}, {user2}, and {} are typing ", &others[0])
                 } else {
[31m-                    format!(
[m[31m-                        "{user1}, {user2}, and {} others are typing ",
[m[31m-                        others.len()
[m[31m-                    )
[m[32m+                    format!("{user1}, {user2}, and {} others are typing ", others.len())
[m                 }
             }
         };
Diff in /app/src/room/typing_notice.rs:109:
         // Set the typing notice text and make its view visible.
[31m-        self.view.label(ids!(typing_label)).set_text(cx, &typing_notice_text);
[m[32m+        self.view
[m[32m+            .label(ids!(typing_label))
[m[32m+            .set_text(cx, &typing_notice_text);
[m         self.view.set_visible(cx, true);
         // Animate in the typing notice view (sliding it up from the bottom).
         self.animator_play(cx, ids!(typing_notice_animator.show));
Diff in /app/src/room/typing_notice.rs:114:
         // Start the typing notice text animation of bouncing dots.
[31m-        self.view.bouncing_dots(ids!(bouncing_dots)).start_animation(cx);
[m[32m+        self.view
[m[32m+            .bouncing_dots(ids!(bouncing_dots))
[m[32m+            .start_animation(cx);
[m     }
 }

Diff in /app/src/settings/account_settings.rs:2:

 use makepad_widgets::{text::selection::Cursor, *};

[31m-use crate::{app::ConfirmDeleteAction, avatar_cache::{self}, logout::logout_confirm_modal::{LogoutAction, LogoutConfirmModalAction}, profile::user_profile::UserProfile, shared::{avatar::{AvatarState, AvatarWidgetExt}, callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition}, confirmation_modal::ConfirmationModalContent, popup_list::{PopupKind, enqueue_popup_notification}, styles::*}, sliding_sync::{AccountDataAction, MatrixRequest, submit_async_request}, utils};
[m[32m+use crate::{
[m[32m+    app::ConfirmDeleteAction,
[m[32m+    avatar_cache::{self},
[m[32m+    logout::logout_confirm_modal::{LogoutAction, LogoutConfirmModalAction},
[m[32m+    profile::user_profile::UserProfile,
[m[32m+    shared::{
[m[32m+        avatar::{AvatarState, AvatarWidgetExt},
[m[32m+        callout_tooltip::{CalloutTooltipOptions, TooltipAction, TooltipPosition},
[m[32m+        confirmation_modal::ConfirmationModalContent,
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+        styles::*,
[m[32m+    },
[m[32m+    sliding_sync::{AccountDataAction, MatrixRequest, submit_async_request},
[m[32m+    utils,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/settings/account_settings.rs:238:
             spacing: 10

             manage_account_button = <RobrixIconButton> {
[31m-
[m[32m+
[m                 padding: {top: 10, bottom: 10, left: 12, right: 15}
                 margin: {left: 5}
                 draw_bg: {
Diff in /app/src/settings/account_settings.rs:280:
 /// The view containing all user account-related settings.
 #[derive(Live, LiveHook, Widget)]
 pub struct AccountSettings {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
[31m-    #[rust] own_profile: Option<UserProfile>,
[m[32m+    #[rust]
[m[32m+    own_profile: Option<UserProfile>,
[m }

 impl Widget for AccountSettings {
Diff in /app/src/settings/account_settings.rs:347:
             // Handle LogoutAction::InProgress to update button state
             if let Some(LogoutAction::InProgress(is_in_progress)) = action.downcast_ref() {
                 let logout_button = self.view.button(ids!(logout_button));
[31m-                logout_button.set_text(cx, if *is_in_progress { "Logging out..." } else { "Log out" });
[m[32m+                logout_button.set_text(
[m[32m+                    cx,
[m[32m+                    if *is_in_progress {
[m[32m+                        "Logging out..."
[m[32m+                    } else {
[m[32m+                        "Log out"
[m[32m+                    },
[m[32m+                );
[m                 logout_button.set_enabled(cx, !*is_in_progress);
                 logout_button.reset_hover(cx);
                 continue;
Diff in /app/src/settings/account_settings.rs:358:
             // so here, we only need to update this widget's local profile info.
             match action.downcast_ref() {
                 Some(AccountDataAction::AvatarChanged(new_avatar_url)) => {
[31m-                    self.view.widget(ids!(upload_avatar_spinner)).set_visible(cx, false);
[m[31m-                    self.view.widget(ids!(delete_avatar_spinner)).set_visible(cx, false);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(upload_avatar_spinner))
[m[32m+                        .set_visible(cx, false);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(delete_avatar_spinner))
[m[32m+                        .set_visible(cx, false);
[m                     // Update our cached profile with the new avatar URL
                     if let Some(profile) = self.own_profile.as_mut() {
                         profile.avatar_state = AvatarState::Known(new_avatar_url.clone());
Diff in /app/src/settings/account_settings.rs:366:
                         profile.avatar_state.update_from_cache(cx);
                         self.populate_avatar_views(cx);
                         enqueue_popup_notification(
[31m-                            format!("Successfully {} avatar.", if new_avatar_url.is_some() { "updated" } else { "deleted" }),
[m[32m+                            format!(
[m[32m+                                "Successfully {} avatar.",
[m[32m+                                if new_avatar_url.is_some() {
[m[32m+                                    "updated"
[m[32m+                                } else {
[m[32m+                                    "deleted"
[m[32m+                                }
[m[32m+                            ),
[m                             PopupKind::Success,
                             Some(4.0),
                         );
Diff in /app/src/settings/account_settings.rs:374:
                     continue;
                 }
                 Some(AccountDataAction::AvatarChangeFailed(err_msg)) => {
[31m-                    self.view.widget(ids!(upload_avatar_spinner)).set_visible(cx, false);
[m[31m-                    self.view.widget(ids!(delete_avatar_spinner)).set_visible(cx, false);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(upload_avatar_spinner))
[m[32m+                        .set_visible(cx, false);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(delete_avatar_spinner))
[m[32m+                        .set_visible(cx, false);
[m                     // Re-enable the avatar buttons so user can try again
                     Self::enable_upload_avatar_button(cx, true, &upload_avatar_button);
                     Self::enable_delete_avatar_button(
Diff in /app/src/settings/account_settings.rs:382:
                         cx,
[31m-                        self.own_profile.as_ref().is_some_and(|p| p.avatar_state.has_avatar()),
[m[31m-                        &delete_avatar_button
[m[32m+                        self.own_profile
[m[32m+                            .as_ref()
[m[32m+                            .is_some_and(|p| p.avatar_state.has_avatar()),
[m[32m+                        &delete_avatar_button,
[m                     );
[31m-                    enqueue_popup_notification(
[m[31m-                        err_msg.clone(),
[m[31m-                        PopupKind::Error,
[m[31m-                        Some(4.0),
[m[31m-                    );
[m[32m+                    enqueue_popup_notification(err_msg.clone(), PopupKind::Error, Some(4.0));
[m                     continue;
                 }
                 Some(AccountDataAction::DisplayNameChanged(new_name)) => {
Diff in /app/src/settings/account_settings.rs:394:
[31m-                    self.view.widget(ids!(save_name_spinner)).set_visible(cx, false);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(save_name_spinner))
[m[32m+                        .set_visible(cx, false);
[m                     // Update our cached profile with the new display name
                     if let Some(profile) = self.own_profile.as_mut() {
                         profile.username = new_name.clone();
Diff in /app/src/settings/account_settings.rs:398:
                     }
                     // Update the display name text input and disable buttons
[31m-                    let (text, len) = new_name.as_deref().map(|s| (s, s.len())).unwrap_or_default();
[m[32m+                    let (text, len) = new_name
[m[32m+                        .as_deref()
[m[32m+                        .map(|s| (s, s.len()))
[m[32m+                        .unwrap_or_default();
[m                     display_name_input.set_text(cx, text);
[31m-                    display_name_input.set_cursor(cx, Cursor { index: len, prefer_next_row: false }, false);
[m[32m+                    display_name_input.set_cursor(
[m[32m+                        cx,
[m[32m+                        Cursor {
[m[32m+                            index: len,
[m[32m+                            prefer_next_row: false,
[m[32m+                        },
[m[32m+                        false,
[m[32m+                    );
[m                     display_name_input.set_is_read_only(cx, false);
                     display_name_input.set_disabled(cx, false);
[31m-                    Self::enable_display_name_buttons(cx, false, &accept_display_name_button, &cancel_display_name_button);
[m[32m+                    Self::enable_display_name_buttons(
[m[32m+                        cx,
[m[32m+                        false,
[m[32m+                        &accept_display_name_button,
[m[32m+                        &cancel_display_name_button,
[m[32m+                    );
[m                     enqueue_popup_notification(
[31m-                        format!("Successfully {} display name.", if new_name.is_some() { "updated" } else { "removed" }),
[m[32m+                        format!(
[m[32m+                            "Successfully {} display name.",
[m[32m+                            if new_name.is_some() {
[m[32m+                                "updated"
[m[32m+                            } else {
[m[32m+                                "removed"
[m[32m+                            }
[m[32m+                        ),
[m                         PopupKind::Success,
                         Some(4.0),
                     );
Diff in /app/src/settings/account_settings.rs:411:
                     continue;
                 }
                 Some(AccountDataAction::DisplayNameChangeFailed(err_msg)) => {
[31m-                    self.view.widget(ids!(save_name_spinner)).set_visible(cx, false);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(save_name_spinner))
[m[32m+                        .set_visible(cx, false);
[m                     // Re-enable the buttons and text input so that the user can try again
                     display_name_input.set_is_read_only(cx, false);
                     display_name_input.set_disabled(cx, false);
Diff in /app/src/settings/account_settings.rs:418:
[31m-                    Self::enable_display_name_buttons(cx, true, &accept_display_name_button, &cancel_display_name_button);
[m[31m-                    enqueue_popup_notification(
[m[31m-                        err_msg.clone(),
[m[31m-                        PopupKind::Error,
[m[31m-                        Some(4.0),
[m[32m+                    Self::enable_display_name_buttons(
[m[32m+                        cx,
[m[32m+                        true,
[m[32m+                        &accept_display_name_button,
[m[32m+                        &cancel_display_name_button,
[m                     );
[32m+                    enqueue_popup_notification(err_msg.clone(), PopupKind::Error, Some(4.0));
[m                     continue;
                 }
                 _ => {}
Diff in /app/src/settings/account_settings.rs:428:

             match action.downcast_ref() {
                 Some(AccountSettingsAction::AvatarDeleteStarted) => {
[31m-                    self.view.widget(ids!(delete_avatar_spinner)).set_visible(cx, true);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(delete_avatar_spinner))
[m[32m+                        .set_visible(cx, true);
[m                     Self::enable_upload_avatar_button(cx, false, &upload_avatar_button);
                     Self::enable_delete_avatar_button(cx, false, &delete_avatar_button);
                     continue;
Diff in /app/src/settings/account_settings.rs:435:
                 }
                 Some(AccountSettingsAction::AvatarUploadStarted) => {
[31m-                    self.view.widget(ids!(upload_avatar_spinner)).set_visible(cx, true);
[m[32m+                    self.view
[m[32m+                        .widget(ids!(upload_avatar_spinner))
[m[32m+                        .set_visible(cx, true);
[m                     Self::enable_upload_avatar_button(cx, false, &upload_avatar_button);
                     Self::enable_delete_avatar_button(cx, false, &delete_avatar_button);
                     continue;
Diff in /app/src/settings/account_settings.rs:443:
             }
         }

[31m-        let Some(own_profile) = &self.own_profile else { return };
[m[32m+        let Some(own_profile) = &self.own_profile else {
[m[32m+            return;
[m[32m+        };
[m
         if upload_avatar_button.clicked(actions) {
             // TODO: uncomment the below once avatar uploading is implemented
Diff in /app/src/settings/account_settings.rs:483:
             let trimmed = new_name.trim();
             let current_name = own_profile.username.as_deref().unwrap_or("");
             let enable = trimmed != current_name;
[31m-            Self::enable_display_name_buttons(cx, enable, &accept_display_name_button, &cancel_display_name_button);
[m[32m+            Self::enable_display_name_buttons(
[m[32m+                cx,
[m[32m+                enable,
[m[32m+                &accept_display_name_button,
[m[32m+                &cancel_display_name_button,
[m[32m+            );
[m         }

         if cancel_display_name_button.clicked(actions) {
Diff in /app/src/settings/account_settings.rs:490:
             // Reset the display name input and disable the name change buttons.
             let new_text = own_profile.username.as_deref().unwrap_or("");
             display_name_input.set_text(cx, new_text);
[31m-            display_name_input.set_cursor(cx, Cursor { index: new_text.len(), prefer_next_row: false }, false);
[m[31m-            Self::enable_display_name_buttons(cx, false, &accept_display_name_button, &cancel_display_name_button);
[m[32m+            display_name_input.set_cursor(
[m[32m+                cx,
[m[32m+                Cursor {
[m[32m+                    index: new_text.len(),
[m[32m+                    prefer_next_row: false,
[m[32m+                },
[m[32m+                false,
[m[32m+            );
[m[32m+            Self::enable_display_name_buttons(
[m[32m+                cx,
[m[32m+                false,
[m[32m+                &accept_display_name_button,
[m[32m+                &cancel_display_name_button,
[m[32m+            );
[m         }

         if accept_display_name_button.clicked(actions) {
Diff in /app/src/settings/account_settings.rs:501:
             };
             // While the request is in flight, show the loading spinner and disable the buttons & text input
             submit_async_request(MatrixRequest::SetDisplayName { new_display_name });
[31m-            self.view.widget(ids!(save_name_spinner)).set_visible(cx, true);
[m[32m+            self.view
[m[32m+                .widget(ids!(save_name_spinner))
[m[32m+                .set_visible(cx, true);
[m             display_name_input.set_disabled(cx, true);
             display_name_input.set_is_read_only(cx, true);
[31m-            Self::enable_display_name_buttons(cx, false, &accept_display_name_button, &cancel_display_name_button);
[m[31m-            enqueue_popup_notification(
[m[31m-                "Uploading new display name...",
[m[31m-                PopupKind::Info,
[m[31m-                Some(5.0),
[m[32m+            Self::enable_display_name_buttons(
[m[32m+                cx,
[m[32m+                false,
[m[32m+                &accept_display_name_button,
[m[32m+                &cancel_display_name_button,
[m             );
[32m+            enqueue_popup_notification("Uploading new display name...", PopupKind::Info, Some(5.0));
[m         }

         if self.view.button(ids!(copy_user_id_button)).clicked(actions) {
Diff in /app/src/settings/account_settings.rs:521:
             );
         }

[31m-        if self.view.button(ids!(manage_account_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(manage_account_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             // TODO: support opening the user's account management page in a browser,
             //       or perhaps in an in-app pane if that's what is needed for regular UN+PW login.
             enqueue_popup_notification(
Diff in /app/src/settings/account_settings.rs:550:
         let our_own_avatar = self.view.avatar(ids!(our_own_avatar));
         let mut drew_avatar = false;
         if let Some(avatar_img_data) = own_profile.avatar_state.data() {
[31m-            drew_avatar = our_own_avatar.show_image(
[m[31m-                cx,
[m[31m-                None, // don't make this avatar clickable; we handle clicks on this ProfileIcon widget directly.
[m[31m-                |cx, img| utils::load_png_or_jpg(&img, cx, avatar_img_data),
[m[31m-            ).is_ok();
[m[32m+            drew_avatar = our_own_avatar
[m[32m+                .show_image(
[m[32m+                    cx,
[m[32m+                    None, // don't make this avatar clickable; we handle clicks on this ProfileIcon widget directly.
[m[32m+                    |cx, img| utils::load_png_or_jpg(&img, cx, avatar_img_data),
[m[32m+                )
[m[32m+                .is_ok();
[m         }
         if !drew_avatar {
             our_own_avatar.show_text(
Diff in /app/src/settings/account_settings.rs:565:
             );
         }

[31m-        Self::enable_upload_avatar_button(
[m[31m-            cx,
[m[31m-            true,
[m[31m-            &self.view.button(ids!(upload_avatar_button))
[m[31m-        );
[m[32m+        Self::enable_upload_avatar_button(cx, true, &self.view.button(ids!(upload_avatar_button)));
[m         Self::enable_delete_avatar_button(
             cx,
             own_profile.avatar_state.has_avatar(),
Diff in /app/src/settings/account_settings.rs:576:
[31m-            &self.view.button(ids!(delete_avatar_button))
[m[32m+            &self.view.button(ids!(delete_avatar_button)),
[m         );
     }

Diff in /app/src/settings/account_settings.rs:580:
     /// Show and initializes the account settings within the SettingsScreen.
     pub fn populate(&mut self, cx: &mut Cx, own_profile: UserProfile) {
[31m-        self.view.label(ids!(user_id))
[m[32m+        self.view
[m[32m+            .label(ids!(user_id))
[m             .set_text(cx, own_profile.user_id.as_str());
[31m-        self.view.text_input(ids!(display_name_input))
[m[32m+        self.view
[m[32m+            .text_input(ids!(display_name_input))
[m             .set_text(cx, own_profile.username.as_deref().unwrap_or_default());
         Self::enable_display_name_buttons(
             cx,
Diff in /app/src/settings/account_settings.rs:595:

         self.view.button(ids!(upload_avatar_button)).reset_hover(cx);
         self.view.button(ids!(delete_avatar_button)).reset_hover(cx);
[31m-        self.view.button(ids!(accept_display_name_button)).reset_hover(cx);
[m[31m-        self.view.button(ids!(cancel_display_name_button)).reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(accept_display_name_button))
[m[32m+            .reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(cancel_display_name_button))
[m[32m+            .reset_hover(cx);
[m         self.view.button(ids!(copy_user_id_button)).reset_hover(cx);
[31m-        self.view.button(ids!(manage_account_button)).reset_hover(cx);
[m[32m+        self.view
[m[32m+            .button(ids!(manage_account_button))
[m[32m+            .reset_hover(cx);
[m         self.view.button(ids!(logout_button)).reset_hover(cx);
         self.view.redraw(cx);
     }
Diff in /app/src/settings/account_settings.rs:605:

     /// Enable or disable the delete avatar button.
[31m-    fn enable_delete_avatar_button(
[m[31m-        cx: &mut Cx,
[m[31m-        enable: bool,
[m[31m-        delete_avatar_button: &ButtonRef,
[m[31m-    ) {
[m[32m+    fn enable_delete_avatar_button(cx: &mut Cx, enable: bool, delete_avatar_button: &ButtonRef) {
[m         let (delete_button_fg_color, delete_button_bg_color) = if enable {
             (COLOR_FG_DANGER_RED, COLOR_BG_DANGER_RED)
         } else {
Diff in /app/src/settings/account_settings.rs:615:
             (COLOR_FG_DISABLED, COLOR_BG_DISABLED)
         };
[31m-        delete_avatar_button.apply_over(cx, live!{
[m[31m-            enabled: (enable),
[m[31m-            draw_bg: {
[m[31m-                color: (delete_button_bg_color),
[m[31m-                border_color: (delete_button_fg_color),
[m[31m-            }
[m[31m-            draw_icon: {
[m[31m-                color: (delete_button_fg_color),
[m[31m-            }
[m[31m-            draw_text: {
[m[31m-                color: (delete_button_fg_color),
[m[31m-            }
[m[31m-        });
[m[32m+        delete_avatar_button.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                enabled: (enable),
[m[32m+                draw_bg: {
[m[32m+                    color: (delete_button_bg_color),
[m[32m+                    border_color: (delete_button_fg_color),
[m[32m+                }
[m[32m+                draw_icon: {
[m[32m+                    color: (delete_button_fg_color),
[m[32m+                }
[m[32m+                draw_text: {
[m[32m+                    color: (delete_button_fg_color),
[m[32m+                }
[m[32m+            },
[m[32m+        );
[m     }

     /// Enable or disable the upload avatar button.
Diff in /app/src/settings/account_settings.rs:633:
[31m-    fn enable_upload_avatar_button(
[m[31m-        cx: &mut Cx,
[m[31m-        enable: bool,
[m[31m-        upload_avatar_button: &ButtonRef,
[m[31m-    ) {
[m[32m+    fn enable_upload_avatar_button(cx: &mut Cx, enable: bool, upload_avatar_button: &ButtonRef) {
[m         let (upload_button_fg_color, upload_button_bg_color) = if enable {
             (COLOR_PRIMARY, COLOR_ACTIVE_PRIMARY)
         } else {
Diff in /app/src/settings/account_settings.rs:641:
             (COLOR_FG_DISABLED, COLOR_BG_DISABLED)
         };
[31m-        upload_avatar_button.apply_over(cx, live!{
[m[31m-            enabled: (enable),
[m[31m-            draw_bg: {
[m[31m-                color: (upload_button_bg_color),
[m[31m-                border_color: (upload_button_fg_color),
[m[31m-            }
[m[31m-            draw_icon: {
[m[31m-                color: (upload_button_fg_color),
[m[31m-            }
[m[31m-            draw_text: {
[m[31m-                color: (upload_button_fg_color),
[m[31m-            }
[m[31m-        });
[m[32m+        upload_avatar_button.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                enabled: (enable),
[m[32m+                draw_bg: {
[m[32m+                    color: (upload_button_bg_color),
[m[32m+                    border_color: (upload_button_fg_color),
[m[32m+                }
[m[32m+                draw_icon: {
[m[32m+                    color: (upload_button_fg_color),
[m[32m+                }
[m[32m+                draw_text: {
[m[32m+                    color: (upload_button_fg_color),
[m[32m+                }
[m[32m+            },
[m[32m+        );
[m     }

     /// Enable or disable the display name accept and cancel buttons.
Diff in /app/src/settings/account_settings.rs:673:
             (COLOR_FG_DISABLED, COLOR_BG_DISABLED)
         };

[31m-        accept_display_name_button.apply_over(cx, live!(
[m[31m-            enabled: (enable),
[m[31m-            draw_bg: {
[m[31m-                color: (accept_button_bg_color),
[m[31m-                border_color: (accept_button_fg_color),
[m[31m-            },
[m[31m-            draw_text: {
[m[31m-                color: (accept_button_fg_color),
[m[31m-            },
[m[31m-            draw_icon: {
[m[31m-                color: (accept_button_fg_color),
[m[31m-            }
[m[31m-        ));
[m[31m-        cancel_display_name_button.apply_over(cx, live!(
[m[31m-            enabled: (enable),
[m[31m-            draw_bg: {
[m[31m-                color: (cancel_button_bg_color),
[m[31m-                border_color: (cancel_button_fg_color),
[m[31m-            },
[m[31m-            draw_text: {
[m[31m-                color: (cancel_button_fg_color),
[m[31m-            },
[m[31m-            draw_icon: {
[m[31m-                color: (cancel_button_fg_color),
[m[31m-            }
[m[31m-        ));
[m[32m+        accept_display_name_button.apply_over(
[m[32m+            cx,
[m[32m+            live!(
[m[32m+                enabled: (enable),
[m[32m+                draw_bg: {
[m[32m+                    color: (accept_button_bg_color),
[m[32m+                    border_color: (accept_button_fg_color),
[m[32m+                },
[m[32m+                draw_text: {
[m[32m+                    color: (accept_button_fg_color),
[m[32m+                },
[m[32m+                draw_icon: {
[m[32m+                    color: (accept_button_fg_color),
[m[32m+                }
[m[32m+            ),
[m[32m+        );
[m[32m+        cancel_display_name_button.apply_over(
[m[32m+            cx,
[m[32m+            live!(
[m[32m+                enabled: (enable),
[m[32m+                draw_bg: {
[m[32m+                    color: (cancel_button_bg_color),
[m[32m+                    border_color: (cancel_button_fg_color),
[m[32m+                },
[m[32m+                draw_text: {
[m[32m+                    color: (cancel_button_fg_color),
[m[32m+                },
[m[32m+                draw_icon: {
[m[32m+                    color: (cancel_button_fg_color),
[m[32m+                }
[m[32m+            ),
[m[32m+        );
[m     }
 }

Diff in /app/src/settings/account_settings.rs:705:
 impl AccountSettingsRef {
     /// See [`AccountSettings::show()`].
     pub fn populate(&self, cx: &mut Cx, own_profile: UserProfile) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.populate(cx, own_profile);
     }
 }
Diff in /app/src/settings/settings_screen.rs:1:
[31m-
[m use makepad_widgets::*;

[31m-use crate::{home::navigation_tab_bar::{NavigationBarAction, get_own_profile}, profile::user_profile::UserProfile, settings::account_settings::AccountSettingsWidgetExt};
[m[32m+use crate::{
[m[32m+    home::navigation_tab_bar::{NavigationBarAction, get_own_profile},
[m[32m+    profile::user_profile::UserProfile,
[m[32m+    settings::account_settings::AccountSettingsWidgetExt,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/settings/settings_screen.rs:101:
     }
 }

[31m-
[m /// The top-level widget showing all app and user settings/preferences.
 #[derive(Live, LiveHook, Widget)]
 pub struct SettingsScreen {
Diff in /app/src/settings/settings_screen.rs:108:
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 impl Widget for SettingsScreen {
Diff in /app/src/settings/settings_screen.rs:122:
             matches!(
                 event,
                 Event::Actions(actions) if self.button(ids!(close_button)).clicked(actions)
[31m-            )
[m[31m-            || event.back_pressed()
[m[31m-            || match event.hits(cx, area) {
[m[31m-                Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[31m-                Hit::FingerDown(_fde) => {
[m[31m-                    cx.set_key_focus(area);
[m[31m-                    false
[m[32m+            ) || event.back_pressed()
[m[32m+                || match event.hits(cx, area) {
[m[32m+                    Hit::KeyUp(key) => key.key_code == KeyCode::Escape,
[m[32m+                    Hit::FingerDown(_fde) => {
[m[32m+                        cx.set_key_focus(area);
[m[32m+                        false
[m[32m+                    }
[m[32m+                    _ => false,
[m                 }
[31m-                _ => false,
[m[31m-            }
[m         };
         if close_pane {
             cx.action(NavigationBarAction::CloseSettings);
Diff in /app/src/settings/settings_screen.rs:149:
                 match action.downcast_ref() {
                     Some(CreateWalletModalAction::Open) => {
                         use crate::tsp::create_wallet_modal::CreateWalletModalWidgetExt;
[31m-                        self.view.create_wallet_modal(ids!(create_wallet_modal_inner)).show(cx);
[m[32m+                        self.view
[m[32m+                            .create_wallet_modal(ids!(create_wallet_modal_inner))
[m[32m+                            .show(cx);
[m                         self.view.modal(ids!(create_wallet_modal)).open(cx);
                     }
                     Some(CreateWalletModalAction::Close) => {
Diff in /app/src/settings/settings_screen.rs:156:
                         self.view.modal(ids!(create_wallet_modal)).close(cx);
                     }
[31m-                    None => { }
[m[32m+                    None => {}
[m                 }

                 // Handle the create DID modal being opened or closed.
Diff in /app/src/settings/settings_screen.rs:162:
                 match action.downcast_ref() {
                     Some(CreateDidModalAction::Open) => {
                         use crate::tsp::create_did_modal::CreateDidModalWidgetExt;
[31m-                        self.view.create_did_modal(ids!(create_did_modal_inner)).show(cx);
[m[32m+                        self.view
[m[32m+                            .create_did_modal(ids!(create_did_modal_inner))
[m[32m+                            .show(cx);
[m                         self.view.modal(ids!(create_did_modal)).open(cx);
                     }
                     Some(CreateDidModalAction::Close) => {
Diff in /app/src/settings/settings_screen.rs:169:
                         self.view.modal(ids!(create_did_modal)).close(cx);
                     }
[31m-                    None => { }
[m[32m+                    None => {}
[m                 }
             }
         }
Diff in /app/src/settings/settings_screen.rs:186:
             error!("Failed to get own profile for settings screen.");
             return;
         };
[31m-        self.view.account_settings(ids!(account_settings)).populate(cx, profile);
[m[32m+        self.view
[m[32m+            .account_settings(ids!(account_settings))
[m[32m+            .populate(cx, profile);
[m         self.view.button(ids!(close_button)).reset_hover(cx);
         cx.set_key_focus(self.view.area());
         self.redraw(cx);
Diff in /app/src/settings/settings_screen.rs:196:
 impl SettingsScreenRef {
     /// See [`SettingsScreen::populate()`].
     pub fn populate(&self, cx: &mut Cx, own_profile: Option<UserProfile>) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return; };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.populate(cx, own_profile);
     }
 }
Diff in /app/src/shared/avatar.rs:9:
 use std::sync::Arc;

 use makepad_widgets::*;
[31m-use matrix_sdk::{ruma::{EventId, OwnedRoomId, OwnedUserId, RoomId, UserId}};
[m[32m+use matrix_sdk::{
[m[32m+    ruma::{EventId, OwnedRoomId, OwnedUserId, RoomId, UserId},
[m[32m+};
[m use matrix_sdk_ui::timeline::{Profile, TimelineDetails};
 use ruma::OwnedMxcUri;

Diff in /app/src/shared/avatar.rs:16:
 use crate::{
[31m-    avatar_cache::{self, AvatarCacheEntry}, profile::{user_profile::{ShowUserProfileAction, UserProfile, UserProfileAndRoomId}, user_profile_cache}, sliding_sync::{submit_async_request, MatrixRequest}, utils
[m[32m+    avatar_cache::{self, AvatarCacheEntry},
[m[32m+    profile::{
[m[32m+        user_profile::{ShowUserProfileAction, UserProfile, UserProfileAndRoomId},
[m[32m+        user_profile_cache,
[m[32m+    },
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest},
[m[32m+    utils,
[m };

 live_design! {
Diff in /app/src/shared/avatar.rs:89:
     }
 }

[31m-
[m #[derive(LiveHook, Live, Widget)]
 pub struct Avatar {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// Information about the user profile being shown in this Avatar.
     /// If `Some`, this Avatar will respond to clicks/taps.
Diff in /app/src/shared/avatar.rs:99:
[31m-    #[rust] info: Option<UserProfileAndRoomId>,
[m[32m+    #[rust]
[m[32m+    info: Option<UserProfileAndRoomId>,
[m }

 impl Widget for Avatar {
Diff in /app/src/shared/avatar.rs:103:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);

[31m-        let Some(info) = self.info.clone() else { return };
[m[32m+        let Some(info) = self.info.clone() else {
[m[32m+            return;
[m[32m+        };
[m         let area = self.view.area();
         let widget_uid = self.widget_uid();
         match event.hits(cx, area) {
Diff in /app/src/shared/avatar.rs:110:
             Hit::FingerDown(_fde) => {
                 cx.set_key_focus(area);
             }
[31m-            Hit::FingerUp(fue) => if fue.is_over && fue.is_primary_hit() && fue.was_tap() {
[m[31m-                cx.widget_action(
[m[31m-                    widget_uid,
[m[31m-                    &scope.path,
[m[31m-                    ShowUserProfileAction::ShowUserProfile(info),
[m[31m-                );
[m[32m+            Hit::FingerUp(fue) => {
[m[32m+                if fue.is_over && fue.is_primary_hit() && fue.was_tap() {
[m[32m+                    cx.widget_action(
[m[32m+                        widget_uid,
[m[32m+                        &scope.path,
[m[32m+                        ShowUserProfileAction::ShowUserProfile(info),
[m[32m+                    );
[m[32m+                }
[m             }
[31m-            _ =>()
[m[32m+            _ => (),
[m         }
     }

Diff in /app/src/shared/avatar.rs:127:

     fn set_text(&mut self, cx: &mut Cx, v: &str) {
         let f = utils::user_name_first_letter(v)
[31m-            .unwrap_or("?").to_uppercase();
[m[32m+            .unwrap_or("?")
[m[32m+            .to_uppercase();
[m         self.label(ids!(text_view.text)).set_text(cx, &f);
         self.view(ids!(img_view)).set_visible(cx, false);
         self.view(ids!(text_view)).set_visible(cx, true);
Diff in /app/src/shared/avatar.rs:152:
         info: Option<AvatarTextInfo>,
         username: T,
     ) {
[31m-        if let Some(AvatarTextInfo { user_id, username, room_id }) = info {
[m[32m+        if let Some(AvatarTextInfo {
[m[32m+            user_id,
[m[32m+            username,
[m[32m+            room_id,
[m[32m+        }) = info
[m[32m+        {
[m             self.info = Some(UserProfileAndRoomId {
                 user_profile: UserProfile {
                     user_id,
Diff in /app/src/shared/avatar.rs:161:
                 },
                 room_id,
             });
[31m-            self.view.apply_over(cx, live!{ cursor: Hand });
[m[32m+            self.view.apply_over(cx, live! { cursor: Hand });
[m         } else {
[31m-            self.view.apply_over(cx, live!{ cursor: Default });
[m[32m+            self.view.apply_over(cx, live! { cursor: Default });
[m         }
         self.set_text(cx, username.as_ref());

Diff in /app/src/shared/avatar.rs:170:
         // Apply background color if provided
         if let Some(color) = bg_color {
[31m-            self.view(ids!(text_view)).apply_over(cx, live! {
[m[31m-                draw_bg: {
[m[31m-                    background_color: (color)
[m[31m-                }
[m[31m-            });
[m[32m+            self.view(ids!(text_view)).apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    draw_bg: {
[m[32m+                        background_color: (color)
[m[32m+                    }
[m[32m+                },
[m[32m+            );
[m         }
     }

Diff in /app/src/shared/avatar.rs:195:
         info: Option<AvatarImageInfo>,
         image_set_function: F,
     ) -> Result<(), E>
[31m-        where F: FnOnce(&mut Cx, ImageRef) -> Result<(), E>
[m[32m+    where
[m[32m+        F: FnOnce(&mut Cx, ImageRef) -> Result<(), E>,
[m     {
         let img_ref = self.image(ids!(img_view.img));
         let res = image_set_function(cx, img_ref);
Diff in /app/src/shared/avatar.rs:203:
             self.view(ids!(img_view)).set_visible(cx, true);
             self.view(ids!(text_view)).set_visible(cx, false);

[31m-            if let Some(AvatarImageInfo { user_id, username, room_id, img_data }) = info {
[m[32m+            if let Some(AvatarImageInfo {
[m[32m+                user_id,
[m[32m+                username,
[m[32m+                room_id,
[m[32m+                img_data,
[m[32m+            }) = info
[m[32m+            {
[m                 self.info = Some(UserProfileAndRoomId {
                     user_profile: UserProfile {
                         user_id,
Diff in /app/src/shared/avatar.rs:212:
                     },
                     room_id,
                 });
[31m-                self.view.apply_over(cx, live!{ cursor: Hand });
[m[32m+                self.view.apply_over(cx, live! { cursor: Hand });
[m             } else {
[31m-                self.view.apply_over(cx, live!{ cursor: Default });
[m[32m+                self.view.apply_over(cx, live! { cursor: Default });
[m             }
         }
         res
Diff in /app/src/shared/avatar.rs:275:
                 Some(&room_id.to_owned()),
                 true,
                 |profile, rooms| {
[31m-                    rooms.get(room_id).map(|rm| {
[m[31m-                        (
[m[31m-                            rm.display_name().map(|n| n.to_owned()),
[m[31m-                            AvatarState::Known(rm.avatar_url().map(|u| u.to_owned())),
[m[31m-                        )
[m[31m-                    })
[m[31m-                    .unwrap_or_else(|| (profile.username.clone(), profile.avatar_state.clone()))
[m[31m-                }
[m[32m+                    rooms
[m[32m+                        .get(room_id)
[m[32m+                        .map(|rm| {
[m[32m+                            (
[m[32m+                                rm.display_name().map(|n| n.to_owned()),
[m[32m+                                AvatarState::Known(rm.avatar_url().map(|u| u.to_owned())),
[m[32m+                            )
[m[32m+                        })
[m[32m+                        .unwrap_or_else(|| (profile.username.clone(), profile.avatar_state.clone()))
[m[32m+                },
[m             )
         };

Diff in /app/src/shared/avatar.rs:329:
             .and_then(|data| {
                 self.show_image(
                     cx,
[31m-                    is_clickable.then(|| AvatarImageInfo::from((
[m[31m-                        avatar_user_id.to_owned(),
[m[31m-                        username_opt.clone(),
[m[31m-                        room_id.to_owned(),
[m[31m-                        data.clone()
[m[31m-                    ))),
[m[32m+                    is_clickable.then(|| {
[m[32m+                        AvatarImageInfo::from((
[m[32m+                            avatar_user_id.to_owned(),
[m[32m+                            username_opt.clone(),
[m[32m+                            room_id.to_owned(),
[m[32m+                            data.clone(),
[m[32m+                        ))
[m[32m+                    }),
[m                     |cx, img| utils::load_png_or_jpg(&img, cx, &data),
                 )
                 .ok()
Diff in /app/src/shared/avatar.rs:343:
                 self.show_text(
                     cx,
                     None,
[31m-                    is_clickable.then(|| AvatarTextInfo::from((
[m[31m-                        avatar_user_id.to_owned(),
[m[31m-                        username_opt,
[m[31m-                        room_id.to_owned(),
[m[31m-                    ))),
[m[32m+                    is_clickable.then(|| {
[m[32m+                        AvatarTextInfo::from((
[m[32m+                            avatar_user_id.to_owned(),
[m[32m+                            username_opt,
[m[32m+                            room_id.to_owned(),
[m[32m+                        ))
[m[32m+                    }),
[m                     &username,
                 )
             });
Diff in /app/src/shared/avatar.rs:376:
         info: Option<AvatarImageInfo>,
         image_set_function: F,
     ) -> Result<(), E>
[31m-        where F: FnOnce(&mut Cx, ImageRef) -> Result<(), E>
[m[32m+    where
[m[32m+        F: FnOnce(&mut Cx, ImageRef) -> Result<(), E>,
[m     {
         if let Some(mut inner) = self.borrow_mut() {
             inner.show_image(cx, info, image_set_function)
Diff in /app/src/shared/avatar.rs:435:
 }
 impl From<(OwnedUserId, Option<String>, OwnedRoomId)> for AvatarTextInfo {
     fn from((user_id, username, room_id): (OwnedUserId, Option<String>, OwnedRoomId)) -> Self {
[31m-        Self { user_id, username, room_id }
[m[32m+        Self {
[m[32m+            user_id,
[m[32m+            username,
[m[32m+            room_id,
[m[32m+        }
[m     }
 }

Diff in /app/src/shared/avatar.rs:447:
     pub img_data: Arc<[u8]>,
 }
 impl From<(OwnedUserId, Option<String>, OwnedRoomId, Arc<[u8]>)> for AvatarImageInfo {
[31m-    fn from((user_id, username, room_id, img_data): (OwnedUserId, Option<String>, OwnedRoomId, Arc<[u8]>)) -> Self {
[m[31m-        Self { user_id, username, room_id, img_data }
[m[32m+    fn from(
[m[32m+        (user_id, username, room_id, img_data): (
[m[32m+            OwnedUserId,
[m[32m+            Option<String>,
[m[32m+            OwnedRoomId,
[m[32m+            Arc<[u8]>,
[m[32m+        ),
[m[32m+    ) -> Self {
[m[32m+        Self {
[m[32m+            user_id,
[m[32m+            username,
[m[32m+            room_id,
[m[32m+            img_data,
[m[32m+        }
[m     }
 }

Diff in /app/src/shared/avatar.rs:455:
[31m-
[m /// The currently-known state of an avatar for a user, room, or space.
 #[derive(Clone)]
 pub enum AvatarState {
Diff in /app/src/shared/avatar.rs:468:
 impl std::fmt::Debug for AvatarState {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
[31m-            AvatarState::Unknown        => write!(f, "Unknown"),
[m[32m+            AvatarState::Unknown => write!(f, "Unknown"),
[m             AvatarState::Known(Some(_)) => write!(f, "Known(Some)"),
[31m-            AvatarState::Known(None)    => write!(f, "Known(None)"),
[m[31m-            AvatarState::Loaded(data)   => write!(f, "Loaded({} bytes)", data.len()),
[m[31m-            AvatarState::Failed         => write!(f, "Failed"),
[m[32m+            AvatarState::Known(None) => write!(f, "Known(None)"),
[m[32m+            AvatarState::Loaded(data) => write!(f, "Loaded({} bytes)", data.len()),
[m[32m+            AvatarState::Failed => write!(f, "Failed"),
[m         }
     }
 }
Diff in /app/src/shared/bouncing_dots.rs:23:
                 let center_y = self.rect_size.y * 0.5;
                 // Create three circle SDFs
                 sdf.circle(
[31m-                    self.rect_size.x * 0.25,
[m[31m-                    amplitude * sin(self.anim_time * 2.0 * PI * self.freq) + center_y,
[m[32m+                    self.rect_size.x * 0.25,
[m[32m+                    amplitude * sin(self.anim_time * 2.0 * PI * self.freq) + center_y,
[m                     self.dot_radius
                 );
                 sdf.fill(self.color);
Diff in /app/src/shared/bouncing_dots.rs:31:
                 sdf.circle(
[31m-                    self.rect_size.x * 0.5,
[m[31m-                    amplitude * sin(self.anim_time * 2.0 * PI * self.freq + self.phase_offset) + center_y,
[m[32m+                    self.rect_size.x * 0.5,
[m[32m+                    amplitude * sin(self.anim_time * 2.0 * PI * self.freq + self.phase_offset) + center_y,
[m                     self.dot_radius
                 );
                 sdf.fill(self.color);
Diff in /app/src/shared/bouncing_dots.rs:37:
                 sdf.circle(
[31m-                    self.rect_size.x * 0.75,
[m[31m-                    amplitude * sin(self.anim_time * 2.0 * PI * self.freq + self.phase_offset * 2) + center_y,
[m[32m+                    self.rect_size.x * 0.75,
[m[32m+                    amplitude * sin(self.anim_time * 2.0 * PI * self.freq + self.phase_offset * 2) + center_y,
[m                     self.dot_radius
                 );
                 sdf.fill(self.color);
Diff in /app/src/shared/bouncing_dots.rs:61:
                 }
             }
         }
[31m-
[m[32m+
[m     }
 }

Diff in /app/src/shared/bouncing_dots.rs:68:
 #[derive(Live, LiveHook, Widget)]
 pub struct BouncingDots {
[31m-    #[deref] view: View,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m }
 impl Widget for BouncingDots {
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
Diff in /app/src/shared/bouncing_dots.rs:80:
         self.view.draw_walk(cx, scope, walk)
     }
 }
[31m-
[m
 impl BouncingDotsRef {
     /// Starts animation of the bouncing dots.
Diff in /app/src/shared/callout_tooltip.rs:33:
                     instance target_pos: vec2(0.0, 0.0),
                     // Size of the moused over widget
                     instance target_size: vec2(0.0, 0.0),
[31m-                    // Expected Width of the the tooltip
[m[32m+                    // Expected Width of the the tooltip
[m                     instance expected_dimension_x: 0.0,
                     // Determine height of the triangle in the callout pointer
                     instance triangle_height: 7.5,
Diff in /app/src/shared/callout_tooltip.rs:57:
                             max(1.0, self.border_radius)
                         )
                         sdf.fill(self.background_color);
[31m-
[m[32m+
[m                         let mut vertex1 = vec2(0.0, 0.0);
                         let mut vertex2 = vec2(0.0, 0.0);
                         let mut vertex3 = vec2(0.0, 0.0);
Diff in /app/src/shared/callout_tooltip.rs:72:
                             vertex2 = vec2(vertex1.x + triangle_height, vertex1.y - triangle_height);
                             vertex3 = vec2(vertex1.x + triangle_height * 2.0, vertex1.y);
                         } else if self.callout_position == 90.0 {
[31m-                            // Point rightwards
[m[32m+                            // Point rightwards
[m                             // Triangle points to the right from the left edge of the tooltip
                             vertex1 = vec2(rect_size.x - 2.0, rect_size.y * 0.5);
                             vertex2 = vec2(vertex1.x - triangle_height, vertex1.y + triangle_height);
Diff in /app/src/shared/callout_tooltip.rs:156:
     /// The tooltip will be drawn to the left of the target widget.
     Left,
     /// (Default) The tooltip will be drawn to the right of the target widget.
[31m-    #[default] Right,
[m[32m+    #[default]
[m[32m+    Right,
[m }

 /// A tooltip widget that a callout pointing towards the referenced widget.
Diff in /app/src/shared/callout_tooltip.rs:163:
 #[derive(Live, LiveHook, Widget)]
 pub struct CalloutTooltip {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     // The below items are a hack to re-populate this tooltip automatically
     // after a certain time interval, because its repositioning code is
Diff in /app/src/shared/callout_tooltip.rs:169:
     // currently broken and needs to be rewritten entirely.
[31m-    #[rust] timer_redraw: Timer,
[m[31m-    #[rust] latest_options: Option<(String, Rect, CalloutTooltipOptions)>,
[m[32m+    #[rust]
[m[32m+    timer_redraw: Timer,
[m[32m+    #[rust]
[m[32m+    latest_options: Option<(String, Rect, CalloutTooltipOptions)>,
[m }

[31m-
[m #[derive(Debug)]
 struct PositionCalculation {
     tooltip_pos: DVec2,
Diff in /app/src/shared/callout_tooltip.rs:243:
             }
             TooltipPosition::Right => {
                 tooltip_pos.x = widget_rect.pos.x + widget_rect.size.x;
[31m-                tooltip_pos.y = widget_rect.pos.y + 0.5 * widget_rect.size.y - expected_dimension.y * 0.5;
[m[32m+                tooltip_pos.y =
[m[32m+                    widget_rect.pos.y + 0.5 * widget_rect.size.y - expected_dimension.y * 0.5;
[m                 width_to_be_fixed = max(
                     screen_size.x - (pos.x + widget_rect.size.x + triangle_height * 2.0),
                     expected_dimension.x,
Diff in /app/src/shared/callout_tooltip.rs:251:
                 callout_position = 270.0;
             }
         }
[31m-
[m[32m+
[m         Self::apply_edge_case_fix(
             &options.position,
             &mut tooltip_pos,
Diff in /app/src/shared/callout_tooltip.rs:275:
     fn needs_width_fix(tooltip_x: f64, screen_width: f64, expected_width: f64) -> bool {
         tooltip_x == screen_width - expected_width && tooltip_x < 0.0
     }
[31m-
[m[32m+
[m     /// Apply edge case handling for position and width fixing
     fn apply_edge_case_fix(
         position: &TooltipPosition,
Diff in /app/src/shared/callout_tooltip.rs:324:
         text_color: Vec4,
         bg_color: Vec4,
     ) {
[31m-        let tooltip_pos = vec2(position_calc.tooltip_pos.x as f32, position_calc.tooltip_pos.y as f32);
[m[31m-
[m[32m+        let tooltip_pos = vec2(
[m[32m+            position_calc.tooltip_pos.x as f32,
[m[32m+            position_calc.tooltip_pos.y as f32,
[m[32m+        );
[m[32m+
[m         if position_calc.fixed_width {
             tooltip.apply_over(
                 cx,
Diff in /app/src/shared/callout_tooltip.rs:351:
                 }),
             );
         } else {
[31m-            tooltip.apply_over(cx, live!(
[m[31m-                content: {
[m[31m-                    margin: { left: (tooltip_pos.x), top: (tooltip_pos.y) },
[m[31m-                    rounded_view = {
[m[31m-                        height: Fit,
[m[31m-                        draw_bg: {
[m[31m-                            triangle_height: (triangle_height),
[m[31m-                            background_color: (bg_color),
[m[31m-                            tooltip_pos: (tooltip_pos),
[m[31m-                            target_pos: (target),
[m[31m-                            target_size: (target_size),
[m[31m-                            expected_dimension_x: (expected_dimension.x),
[m[31m-                            callout_position: (position_calc.callout_position)
[m[32m+            tooltip.apply_over(
[m[32m+                cx,
[m[32m+                live!(
[m[32m+                    content: {
[m[32m+                        margin: { left: (tooltip_pos.x), top: (tooltip_pos.y) },
[m[32m+                        rounded_view = {
[m[32m+                            height: Fit,
[m[32m+                            draw_bg: {
[m[32m+                                triangle_height: (triangle_height),
[m[32m+                                background_color: (bg_color),
[m[32m+                                tooltip_pos: (tooltip_pos),
[m[32m+                                target_pos: (target),
[m[32m+                                target_size: (target_size),
[m[32m+                                expected_dimension_x: (expected_dimension.x),
[m[32m+                                callout_position: (position_calc.callout_position)
[m[32m+                            }
[m[32m+                            tooltip_label = {
[m[32m+                                width: Fit,
[m[32m+                                draw_text: { color: (text_color) }
[m[32m+                            }
[m                         }
[31m-                        tooltip_label = {
[m[31m-                            width: Fit,
[m[31m-                            draw_text: { color: (text_color) }
[m[31m-                        }
[m                     }
[31m-                }
[m[31m-            ));
[m[32m+                ),
[m[32m+            );
[m         }
     }

Diff in /app/src/shared/callout_tooltip.rs:392:
         is_internal_redraw: bool,
     ) {
         if !is_internal_redraw {
[31m-            self.latest_options = Some((
[m[31m-                text.to_owned(),
[m[31m-                widget_rect,
[m[31m-                options.clone(),
[m[31m-            ));
[m[32m+            self.latest_options = Some((text.to_owned(), widget_rect, options.clone()));
[m         }

         let mut tooltip = self.view.tooltip(ids!(tooltip));
Diff in /app/src/shared/callout_tooltip.rs:412:
             options.triangle_height,
         );

[31m-        let target = vec2(
[m[31m-            widget_rect.pos.x as f32,
[m[31m-            widget_rect.pos.y as f32,
[m[31m-        );
[m[31m-        let target_size = vec2(
[m[31m-            widget_rect.size.x as f32,
[m[31m-            widget_rect.size.y as f32,
[m[31m-        );
[m[32m+        let target = vec2(widget_rect.pos.x as f32, widget_rect.pos.y as f32);
[m[32m+        let target_size = vec2(widget_rect.size.x as f32, widget_rect.size.y as f32);
[m
         let mut text_color = options.text_color;
         if expected_dimension.x == 0.0 {
Diff in /app/src/shared/collapsible_header.rs:108:

 #[derive(Live, LiveHook, Widget)]
 pub struct CollapsibleHeader {
[31m-    #[deref] view: View,
[m[31m-    #[rust(true)] is_expanded: bool,
[m[31m-    #[rust] category: HeaderCategory,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust(true)]
[m[32m+    is_expanded: bool,
[m[32m+    #[rust]
[m[32m+    category: HeaderCategory,
[m }

 impl Widget for CollapsibleHeader {
Diff in /app/src/shared/collapsible_header.rs:122:
                 cx.set_key_focus(self.view.area());
             }
             Hit::FingerUp(fe) => {
[31m-                if !rooms_list_props.was_scrolling && fe.is_over && fe.is_primary_hit() && fe.was_tap() {
[m[32m+                if !rooms_list_props.was_scrolling
[m[32m+                    && fe.is_over
[m[32m+                    && fe.is_primary_hit()
[m[32m+                    && fe.was_tap()
[m[32m+                {
[m                     self.toggle_collapse(cx, scope);
                 }
             }
Diff in /app/src/shared/collapsible_header.rs:129:
[31m-            _ => { }
[m[32m+            _ => {}
[m         }
         self.view.handle_event(cx, event, scope);
     }
Diff in /app/src/shared/collapsible_header.rs:133:

     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
[31m-        let angle = if self.is_expanded {
[m[31m-            180.0
[m[31m-        } else {
[m[31m-            90.0
[m[31m-        };
[m[32m+        let angle = if self.is_expanded { 180.0 } else { 90.0 };
[m         self.icon(ids!(collapse_icon)).apply_over(
             cx,
             live! {
Diff in /app/src/shared/confirmation_modal.rs:4:

 use makepad_widgets::*;

[31m-
[m live_design! {
     use link::theme::*;
     use link::widgets::*;
Diff in /app/src/shared/confirmation_modal.rs:76:
                     align: {x: 0.5, y: 0.5}
                     padding: 15,
                     icon_walk: {width: 0, height: 0, margin: 0}
[31m-
[m[32m+
[m                     draw_bg: {
                         border_size: 0.75
                         border_color: (COLOR_BG_DISABLED),
Diff in /app/src/shared/confirmation_modal.rs:179:
     /// The contained boolean indicates whether the user clicked the
     /// accept button (true) or cancel button (false).
     Close(bool),
[31m-    None
[m[32m+    None,
[m }

 /// Defines the content and behavior of a confirmation modal.
Diff in /app/src/shared/confirmation_modal.rs:224:
     }
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct ConfirmationModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] content: ConfirmationModalContent,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    content: ConfirmationModalContent,
[m }

 impl Widget for ConfirmationModal {
Diff in /app/src/shared/confirmation_modal.rs:249:

         // Handle canceling/closing the modal.
         let cancel_clicked = cancel_button.clicked(actions);
[31m-        if cancel_clicked ||
[m[31m-            actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m[32m+        if cancel_clicked
[m[32m+            || actions
[m[32m+                .iter()
[m[32m+                .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m         {
             // If the modal was dismissed by clicking outside of it, we MUST NOT emit
             // a `ConfirmationModalAction::Close` action, as that would cause
Diff in /app/src/shared/confirmation_modal.rs:289:
     }

     fn apply_content(&mut self, cx: &mut Cx) {
[31m-        self.view.label(ids!(title)).set_text(cx, &self.content.title_text);
[m[31m-        self.view.label(ids!(body)).set_text(cx, &self.content.body_text);
[m[32m+        self.view
[m[32m+            .label(ids!(title))
[m[32m+            .set_text(cx, &self.content.title_text);
[m[32m+        self.view
[m[32m+            .label(ids!(body))
[m[32m+            .set_text(cx, &self.content.body_text);
[m         self.view.button(ids!(accept_button)).set_text(
             cx,
[31m-            self.content.accept_button_text.as_deref().unwrap_or("Confirm"),
[m[32m+            self.content
[m[32m+                .accept_button_text
[m[32m+                .as_deref()
[m[32m+                .unwrap_or("Confirm"),
[m         );
         self.view.button(ids!(cancel_button)).set_text(
             cx,
Diff in /app/src/shared/confirmation_modal.rs:300:
[31m-            self.content.cancel_button_text.as_deref().unwrap_or("Cancel"),
[m[32m+            self.content
[m[32m+                .cancel_button_text
[m[32m+                .as_deref()
[m[32m+                .unwrap_or("Cancel"),
[m         );

         self.view.button(ids!(cancel_button)).reset_hover(cx);
Diff in /app/src/shared/confirmation_modal.rs:311:
 impl ConfirmationModalRef {
     /// Shows the confirmation modal with the given content.
     pub fn show(&self, cx: &mut Cx, content: ConfirmationModalContent) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx, content);
     }

Diff in /app/src/shared/confirmation_modal.rs:320:
     /// If `true`, the user clicked the accept button; if `false`, the user clicked the cancel button.
     /// See [`ConfirmationModalAction::Close`] for more.
     pub fn closed(&self, actions: &Actions) -> Option<bool> {
[31m-        if let ConfirmationModalAction::Close(accepted) = actions.find_widget_action(self.widget_uid()).cast_ref() {
[m[32m+        if let ConfirmationModalAction::Close(accepted) =
[m[32m+            actions.find_widget_action(self.widget_uid()).cast_ref()
[m[32m+        {
[m             Some(*accepted)
         } else {
             None
Diff in /app/src/shared/html_or_plaintext.rs:1:
 //! A `HtmlOrPlaintext` view can display either plaintext or rich HTML content.

 use makepad_widgets::{makepad_html::HtmlDoc, *};
[31m-use matrix_sdk::{ruma::{matrix_uri::MatrixId, OwnedMxcUri}, OwnedServerName};
[m[32m+use matrix_sdk::{
[m[32m+    ruma::{matrix_uri::MatrixId, OwnedMxcUri},
[m[32m+    OwnedServerName,
[m[32m+};
[m
[31m-use crate::{avatar_cache::{self, AvatarCacheEntry}, profile::user_profile_cache, sliding_sync::{current_user_id, submit_async_request, MatrixRequest}, utils};
[m[32m+use crate::{
[m[32m+    avatar_cache::{self, AvatarCacheEntry},
[m[32m+    profile::user_profile_cache,
[m[32m+    sliding_sync::{current_user_id, submit_async_request, MatrixRequest},
[m[32m+    utils,
[m[32m+};
[m
 use super::avatar::AvatarWidgetExt;

Diff in /app/src/shared/html_or_plaintext.rs:171:
 }

 #[derive(Debug, Clone, DefaultNone)]
[31m-pub enum RobrixHtmlLinkAction{
[m[32m+pub enum RobrixHtmlLinkAction {
[m     ClickedMatrixLink {
         /// The URL of the link, which is only temporarily needed here
         /// because we don't fully handle MatrixId links directly in-app yet.
Diff in /app/src/shared/html_or_plaintext.rs:188:
 /// Matrix links are displayed using the [`MatrixLinkPill`] widget.
 #[derive(Live, Widget)]
 struct RobrixHtmlLink {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// The displayable text of the link.
     /// This should be set automatically by the Html widget
Diff in /app/src/shared/html_or_plaintext.rs:195:
     /// when it parses and draws an Html `<a>` tag.
[31m-    #[live] pub text: ArcStringMut,
[m[32m+    #[live]
[m[32m+    pub text: ArcStringMut,
[m     /// The URL of the link.
     /// This is set by the `after_apply()` logic below.
[31m-    #[live] pub url: String,
[m[32m+    #[live]
[m[32m+    pub url: String,
[m }

 impl LiveHook for RobrixHtmlLink {
Diff in /app/src/shared/html_or_plaintext.rs:280:
 /// This can be a link to a user, a room, or a message in a room.
 #[derive(Live, LiveHook, Widget)]
 struct MatrixLinkPill {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
[31m-    #[rust] matrix_id: Option<MatrixId>,
[m[31m-    #[rust] via: Vec<OwnedServerName>,
[m[31m-    #[rust] state: MatrixLinkPillState,
[m[31m-    #[rust] url: String,
[m[32m+    #[rust]
[m[32m+    matrix_id: Option<MatrixId>,
[m[32m+    #[rust]
[m[32m+    via: Vec<OwnedServerName>,
[m[32m+    #[rust]
[m[32m+    state: MatrixLinkPillState,
[m[32m+    #[rust]
[m[32m+    url: String,
[m }

 impl Widget for MatrixLinkPill {
Diff in /app/src/shared/html_or_plaintext.rs:292:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         if let Event::Actions(actions) = event {
             for action in actions {
[31m-                if let Some(loaded @ MatrixLinkPillState::Loaded { matrix_id, .. }) = action.downcast_ref() {
[m[32m+                if let Some(loaded @ MatrixLinkPillState::Loaded { matrix_id, .. }) =
[m[32m+                    action.downcast_ref()
[m[32m+                {
[m                     if self.matrix_id.as_ref() == Some(matrix_id) {
                         self.state = loaded.clone();
                         self.redraw(cx);
Diff in /app/src/shared/html_or_plaintext.rs:317:
                             via: self.via.clone(),
                             key_modifiers: fe.modifiers,
                             url: self.url.clone(),
[31m-                        }
[m[32m+                        },
[m                     );
                 }
             }
Diff in /app/src/shared/html_or_plaintext.rs:339:

 impl MatrixLinkPill {
     /// Populates this pill's info based on the given Matrix ID and via servers.
[31m-    fn populate_pill(&mut self, cx: &mut Cx, url: String, matrix_id: &MatrixId, via: &[OwnedServerName]) {
[m[32m+    fn populate_pill(
[m[32m+        &mut self,
[m[32m+        cx: &mut Cx,
[m[32m+        url: String,
[m[32m+        matrix_id: &MatrixId,
[m[32m+        via: &[OwnedServerName],
[m[32m+    ) {
[m         self.url = url;
         self.matrix_id = Some(matrix_id.clone());
         self.via = via.to_vec();
Diff in /app/src/shared/html_or_plaintext.rs:348:
         if let MatrixId::User(user_id) = matrix_id {
             // Apply red background for current user
             if current_user_id().is_some_and(|u| &u == user_id) {
[31m-                self.apply_over(cx, live! {
[m[31m-                    draw_bg: { color: #d91b38 }
[m[31m-                });
[m[32m+                self.apply_over(
[m[32m+                    cx,
[m[32m+                    live! {
[m[32m+                        draw_bg: { color: #d91b38 }
[m[32m+                    },
[m[32m+                );
[m             }

             match user_profile_cache::with_user_profile(
Diff in /app/src/shared/html_or_plaintext.rs:358:
                 user_id.clone(),
                 None,
                 true,
[31m-                |profile, _| { (profile.displayable_name().to_owned(), profile.avatar_state.clone()) }
[m[32m+                |profile, _| {
[m[32m+                    (
[m[32m+                        profile.displayable_name().to_owned(),
[m[32m+                        profile.avatar_state.clone(),
[m[32m+                    )
[m[32m+                },
[m             ) {
                 Some((name, avatar)) => {
                     self.set_text(cx, &name);
Diff in /app/src/shared/html_or_plaintext.rs:374:

         // Handle room ID or alias
         match &self.state {
[31m-            MatrixLinkPillState::Loaded { name, avatar_url, .. } => {
[m[32m+            MatrixLinkPillState::Loaded {
[m[32m+                name, avatar_url, ..
[m[32m+            } => {
[m                 self.label(ids!(title)).set_text(cx, name);
                 self.populate_avatar(cx, avatar_url.as_ref());
                 return;
Diff in /app/src/shared/html_or_plaintext.rs:386:
                 });
                 self.state = MatrixLinkPillState::Requested;
             }
[31m-            MatrixLinkPillState::Requested => { }
[m[32m+            MatrixLinkPillState::Requested => {}
[m         }
         // While waiting for the async request to complete, show the matrix room ID/alias.
         match matrix_id {
Diff in /app/src/shared/html_or_plaintext.rs:393:
             MatrixId::Room(room_id) => self.set_text(cx, room_id.as_str()),
             MatrixId::RoomAlias(alias) => self.set_text(cx, alias.as_str()),
[31m-            MatrixId::Event(room_or_alias, _) => self.set_text(cx, &format!("Message in {}", room_or_alias.as_str())),
[m[31m-            _ => { }
[m[32m+            MatrixId::Event(room_or_alias, _) => {
[m[32m+                self.set_text(cx, &format!("Message in {}", room_or_alias.as_str()))
[m[32m+            }
[m[32m+            _ => {}
[m         }
         self.populate_avatar(cx, None);
     }
Diff in /app/src/shared/html_or_plaintext.rs:401:
     fn populate_avatar(&self, cx: &mut Cx, avatar_url: Option<&OwnedMxcUri>) {
         let avatar_ref = self.avatar(ids!(avatar));
         if let Some(avatar_url) = avatar_url {
[31m-            if let AvatarCacheEntry::Loaded(data) = avatar_cache::get_or_fetch_avatar(cx, avatar_url) {
[m[32m+            if let AvatarCacheEntry::Loaded(data) =
[m[32m+                avatar_cache::get_or_fetch_avatar(cx, avatar_url)
[m[32m+            {
[m                 let res = avatar_ref.show_image(
                     cx,
                     None, // Don't make this avatar clickable
Diff in /app/src/shared/html_or_plaintext.rs:415:
         // Show a text avatar if we couldn't load an image into the avatar.
         avatar_ref.show_text(cx, None, None, self.text());
     }
[31m-
[m }

 impl MatrixLinkPillRef {
Diff in /app/src/shared/html_or_plaintext.rs:424:
     }

     pub fn get_via(&self) -> Vec<OwnedServerName> {
[31m-        self.borrow().map(|inner| inner.via.clone()).unwrap_or_default()
[m[32m+        self.borrow()
[m[32m+            .map(|inner| inner.via.clone())
[m[32m+            .unwrap_or_default()
[m     }
 }

Diff in /app/src/shared/html_or_plaintext.rs:433:
 struct MatrixHtmlSpan {
     // TODO: this is unused; just here to invalidly satisfy the area provider.
     //       I'm not sure how to implement `fn area()` given that it has multiple area rects.
[31m-    #[redraw] #[area] area: Area,
[m[32m+    #[redraw]
[m[32m+    #[area]
[m[32m+    area: Area,
[m
     // TODO: remove these if they're unneeded
[31m-    #[walk] walk: Walk,
[m[31m-    #[layout] layout: Layout,
[m[32m+    #[walk]
[m[32m+    walk: Walk,
[m[32m+    #[layout]
[m[32m+    layout: Layout,
[m
[31m-    #[rust] drawn_areas: SmallVec<[Area; 2]>,
[m[32m+    #[rust]
[m[32m+    drawn_areas: SmallVec<[Area; 2]>,
[m
     /// Whether to grab key focus when pressed.
[31m-    #[live(true)] grab_key_focus: bool,
[m[32m+    #[live(true)]
[m[32m+    grab_key_focus: bool,
[m
     /// The text content within the `<span>` tag.
[31m-    #[live] text: ArcStringMut,
[m[32m+    #[live]
[m[32m+    text: ArcStringMut,
[m     /// The current display state of the spoiler.
[31m-    #[rust] spoiler: SpoilerDisplay,
[m[32m+    #[rust]
[m[32m+    spoiler: SpoilerDisplay,
[m     /// Foreground (text) color: the `data-mx-color` or `color` attributes.
[31m-    #[rust] fg_color: Option<Vec4>,
[m[32m+    #[rust]
[m[32m+    fg_color: Option<Vec4>,
[m     /// Background color: the `data-mx-bg-color` attribute.
[31m-    #[rust] bg_color: Option<Vec4>,
[m[32m+    #[rust]
[m[32m+    bg_color: Option<Vec4>,
[m }

[31m-
[m /// The possible states that a spoiler can be in: hidden or revealed.
 ///
 /// The enclosed `reason` string is an optional reason given for why
Diff in /app/src/shared/html_or_plaintext.rs:481:
                 let s = std::mem::take(reason);
                 *self = SpoilerDisplay::Hidden { reason: s };
             }
[31m-            SpoilerDisplay::None => { }
[m[32m+            SpoilerDisplay::None => {}
[m         }
     }

Diff in /app/src/shared/html_or_plaintext.rs:499:
         // * in `<font>` tags: `color`
         // * in `<span>` tags: `data-mx-color`, `data-mx-bg-color`, `data-mx-spoiler`

[31m-        if let ApplyFrom::NewFromDoc {..} = apply.from {
[m[32m+        if let ApplyFrom::NewFromDoc { .. } = apply.from {
[m             if let Some(scope) = apply.scope.as_ref() {
                 if let Some(doc) = scope.props.get::<HtmlDoc>() {
                     let mut walker = doc.new_walker_with_index(scope.index + 1);
Diff in /app/src/shared/html_or_plaintext.rs:506:
                     while let Some((lc, attr)) = walker.while_attr_lc() {
                         let attr = attr.trim_matches(['"', '\'']);
                         match lc {
[31m-                            id!(color)
[m[31m-                            | id!(data-mx-color) => self.fg_color = Vec4::from_hex_str(attr).ok(),
[m[31m-                            id!(data-mx-bg-color) => self.bg_color = Vec4::from_hex_str(attr).ok(),
[m[31m-                            id!(data-mx-spoiler) => self.spoiler = SpoilerDisplay::Hidden { reason: attr.into() },
[m[31m-                            _ => ()
[m[32m+                            id!(color) | id!(data - mx - color) => {
[m[32m+                                self.fg_color = Vec4::from_hex_str(attr).ok()
[m[32m+                            }
[m[32m+                            id!(data - mx - bg - color) => {
[m[32m+                                self.bg_color = Vec4::from_hex_str(attr).ok()
[m[32m+                            }
[m[32m+                            id!(data - mx - spoiler) => {
[m[32m+                                self.spoiler = SpoilerDisplay::Hidden {
[m[32m+                                    reason: attr.into(),
[m[32m+                                }
[m[32m+                            }
[m[32m+                            _ => (),
[m                         }
                     }
                 }
Diff in /app/src/shared/html_or_plaintext.rs:517:
             } else {
[31m-                error!("BUG: MatrixHtmlSpan::after_apply(): scope not found, cannot set attributes.");
[m[32m+                error!(
[m[32m+                    "BUG: MatrixHtmlSpan::after_apply(): scope not found, cannot set attributes."
[m[32m+                );
[m             }
         }
     }
Diff in /app/src/shared/html_or_plaintext.rs:572:
         }

         match &self.spoiler {
[31m-            SpoilerDisplay::Hidden { reason }
[m[31m-            | SpoilerDisplay::Revealed { reason } => {
[m[32m+            SpoilerDisplay::Hidden { reason } | SpoilerDisplay::Revealed { reason } => {
[m                 // Draw the spoiler reason text in an italic gray font.
                 tf.font_colors.push(COLOR_SPOILER_REASON);
                 tf.italic.push();
Diff in /app/src/shared/html_or_plaintext.rs:588:
                 tf.font_colors.pop();

                 // Now, draw the spoiler context text itself, either hidden or revealed.
[31m-                if matches!(self.spoiler, SpoilerDisplay::Hidden {..}) {
[m[32m+                if matches!(self.spoiler, SpoilerDisplay::Hidden { .. }) {
[m                     // Use a background color that is the same as the foreground color,
                     // which is a hacky way to make the spoiled text non-readable.
                     // In the future, we should use a proper blur effect.
Diff in /app/src/shared/html_or_plaintext.rs:595:
[31m-                    let spoiler_bg_color = self.fg_color
[m[32m+                    let spoiler_bg_color = self
[m[32m+                        .fg_color
[m                         .or_else(|| tf.font_colors.last().copied())
                         .unwrap_or(tf.font_color);

Diff in /app/src/shared/html_or_plaintext.rs:604:

                     tf.draw_block.code_color = old_bg_color;
                     tf.inline_code.pop();
[31m-
[m                 } else {
                     tf.draw_text(cx, self.text.as_ref());
                 }
Diff in /app/src/shared/html_or_plaintext.rs:625:
         }

         let (start, end) = tf.areas_tracker.pop_tracker();
[31m-        self.drawn_areas = SmallVec::from(
[m[31m-            &tf.areas_tracker.areas[start..end]
[m[31m-        );
[m[32m+        self.drawn_areas = SmallVec::from(&tf.areas_tracker.areas[start..end]);
[m
         DrawStep::done()
     }
Diff in /app/src/shared/html_or_plaintext.rs:642:
     }
 }

[31m-
[m #[derive(LiveHook, Live, Widget)]
 pub struct HtmlOrPlaintext {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 impl Widget for HtmlOrPlaintext {
Diff in /app/src/shared/html_or_plaintext.rs:663:
     pub fn show_plaintext<T: AsRef<str>>(&mut self, cx: &mut Cx, text: T) {
         self.view(ids!(html_view)).set_visible(cx, false);
         self.view(ids!(plaintext_view)).set_visible(cx, true);
[31m-        self.label(ids!(plaintext_view.pt_label)).set_text(cx, text.as_ref());
[m[32m+        self.label(ids!(plaintext_view.pt_label))
[m[32m+            .set_text(cx, text.as_ref());
[m     }

     /// Sets the HTML content, making the HTML visible and the plaintext invisible.
Diff in /app/src/shared/html_or_plaintext.rs:670:
     pub fn show_html<T: AsRef<str>>(&mut self, cx: &mut Cx, html_body: T) {
[31m-        self.html(ids!(html_view.html)).set_text(cx, html_body.as_ref());
[m[32m+        self.html(ids!(html_view.html))
[m[32m+            .set_text(cx, html_body.as_ref());
[m         self.view(ids!(html_view)).set_visible(cx, true);
         self.view(ids!(plaintext_view)).set_visible(cx, false);
     }
Diff in /app/src/shared/image_viewer.rs:24:
 /// Returns an error if either load fails or if the image format is unknown.
 pub fn get_png_or_jpg_image_buffer(data: Vec<u8>) -> Result<ImageBuffer, ImageError> {
     match imghdr::from_bytes(&data) {
[31m-        Some(imghdr::Type::Png) => {
[m[31m-            ImageBuffer::from_png(&data)
[m[31m-        },
[m[31m-        Some(imghdr::Type::Jpeg) => {
[m[31m-            ImageBuffer::from_jpg(&data)
[m[31m-        },
[m[31m-        Some(_unsupported) => {
[m[31m-            Err(ImageError::UnsupportedFormat)
[m[31m-        }
[m[31m-        None => {
[m[31m-            Err(ImageError::UnsupportedFormat)
[m[31m-        }
[m[32m+        Some(imghdr::Type::Png) => ImageBuffer::from_png(&data),
[m[32m+        Some(imghdr::Type::Jpeg) => ImageBuffer::from_jpg(&data),
[m[32m+        Some(_unsupported) => Err(ImageError::UnsupportedFormat),
[m[32m+        None => Err(ImageError::UnsupportedFormat),
[m     }
 }

Diff in /app/src/shared/image_viewer.rs:117:
     ImageViewerButton = <RobrixIconButton> {
         width: 44, height: 44
         align: {x: 0.5, y: 0.5},
[31m-        spacing: 0,
[m[32m+        spacing: 0,
[m         padding: 0,
         draw_bg: {
             color: (COLOR_SECONDARY * 0.925)
Diff in /app/src/shared/image_viewer.rs:223:
                     flow: Right,
                     spacing: 13,
                     align: { y: 0.5 }
[31m-
[m[32m+
[m                     avatar = <Avatar> {
                         width: 45, height: 45,
                         text_view = { text = { draw_text: {
Diff in /app/src/shared/image_viewer.rs:471:

 #[derive(Live, LiveHook, Widget)]
 struct ImageViewer {
[31m-    #[deref] view: View,
[m[31m-    #[rust] drag_state: DragState,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    drag_state: DragState,
[m     /// The current rotation angle of the image. Max of 4, each step represents 90 degrees
[31m-    #[rust] rotation_step: i8,
[m[32m+    #[rust]
[m[32m+    rotation_step: i8,
[m     /// A lock to prevent multiple rotation animations from running at the same time
[31m-    #[rust] is_animating_rotation: bool,
[m[31m-    #[animator] animator: Animator,
[m[32m+    #[rust]
[m[32m+    is_animating_rotation: bool,
[m[32m+    #[animator]
[m[32m+    animator: Animator,
[m     /// Zoom constraints for the image viewer
[31m-    #[rust] config: ImageViewerZoomConfig,
[m[32m+    #[rust]
[m[32m+    config: ImageViewerZoomConfig,
[m     /// Indicates if the mouse cursor is currently hovering over the image.
     /// If true, allows wheel scroll to zoom the image.
[31m-    #[rust] mouse_cursor_hover_over_image: bool,
[m[32m+    #[rust]
[m[32m+    mouse_cursor_hover_over_image: bool,
[m     /// Distance between two touch points for pinch-to-zoom functionality
[31m-    #[rust] previous_pinch_distance: Option<f64>,
[m[32m+    #[rust]
[m[32m+    previous_pinch_distance: Option<f64>,
[m     /// The ID of the background task that is currently running
[31m-    #[rust] background_task_id: u32,
[m[32m+    #[rust]
[m[32m+    background_task_id: u32,
[m     /// The mpsc::Receiver used to receive the result of the background task
[31m-    #[rust] receiver: Option<(u32, Receiver<Result<ImageBuffer, ImageError>>)>,
[m[32m+    #[rust]
[m[32m+    receiver: Option<(u32, Receiver<Result<ImageBuffer, ImageError>>)>,
[m     /// Whether the full image file has been loaded
[31m-    #[rust] is_loaded: bool,
[m[32m+    #[rust]
[m[32m+    is_loaded: bool,
[m     /// The size of the image container.
     ///
     /// Used to compute the necessary width and height for the full screen image.
Diff in /app/src/shared/image_viewer.rs:497:
[31m-    #[rust] image_container_size: DVec2,
[m[32m+    #[rust]
[m[32m+    image_container_size: DVec2,
[m     /// The texture containing the loaded image
[31m-    #[rust] texture: Option<Texture>,
[m[32m+    #[rust]
[m[32m+    texture: Option<Texture>,
[m     /// The event to trigger displaying with the loaded image after peek_walk_turtle of the widget.
[31m-    #[rust] next_frame: NextFrame,
[m[32m+    #[rust]
[m[32m+    next_frame: NextFrame,
[m     /// Whether to display the UI overlay, including buttons and metadata.
[31m-    #[rust] ui_visible_toggle: bool,
[m[32m+    #[rust]
[m[32m+    ui_visible_toggle: bool,
[m     /// Timer used to animate-out (hide) the UI view after the latest user input.
[31m-    #[rust] hide_ui_timer: Timer,
[m[31m-    #[rust] capped_dimension: DVec2,
[m[32m+    #[rust]
[m[32m+    hide_ui_timer: Timer,
[m[32m+    #[rust]
[m[32m+    capped_dimension: DVec2,
[m }

 impl Widget for ImageViewer {
Diff in /app/src/shared/image_viewer.rs:688:
             self.handle_pinch_to_zoom(cx, touch_event);
         }

[31m-        if let (Event::Signal, Some((_background_task_id, receiver))) = (event, &mut self.receiver) {
[m[32m+        if let (Event::Signal, Some((_background_task_id, receiver))) = (event, &mut self.receiver)
[m[32m+        {
[m             let mut remove_receiver = false;
             match receiver.try_recv() {
                 Ok(Ok(image_buffer)) => {
Diff in /app/src/shared/image_viewer.rs:722:
         let animator_action = self.animator_handle_event(cx, event);
         if self.next_frame.is_event(event).is_some() {
             self.display_using_texture(cx);
[31m-        }
[m[31m-        else if let Event::NextFrame(_) = event {
[m[32m+        } else if let Event::NextFrame(_) = event {
[m             let animation_id = match self.rotation_step {
                 0 => ids!(mode.upright),    // 0°
                 1 => ids!(mode.degree_90),  // 90°
Diff in /app/src/shared/image_viewer.rs:737:
         }

         if event.back_pressed()
[31m-            || matches!(event, Event::KeyDown(KeyEvent { key_code: KeyCode::Escape, .. }))
[m[32m+            || matches!(
[m[32m+                event,
[m[32m+                Event::KeyDown(KeyEvent {
[m[32m+                    key_code: KeyCode::Escape,
[m[32m+                    ..
[m[32m+                })
[m[32m+            )
[m         {
             self.reset(cx);
             cx.action(ImageViewerAction::Hide);
Diff in /app/src/shared/image_viewer.rs:767:
         if self.view.button(ids!(reset_button)).clicked(actions) {
             self.reset(cx);
         }
[31m-        if self
[m[31m-            .view
[m[31m-            .button(ids!(zoom_out_button))
[m[31m-            .clicked(actions)
[m[31m-        {
[m[32m+        if self.view.button(ids!(zoom_out_button)).clicked(actions) {
[m             self.adjust_zoom(cx, 1.0 / self.config.zoom_scale_factor);
         }

Diff in /app/src/shared/image_viewer.rs:778:
[31m-        if self
[m[31m-            .view
[m[31m-            .button(ids!(zoom_in_button))
[m[31m-            .clicked(actions)
[m[31m-        {
[m[32m+        if self.view.button(ids!(zoom_in_button)).clicked(actions) {
[m             self.adjust_zoom(cx, self.config.zoom_scale_factor);
         }

Diff in /app/src/shared/image_viewer.rs:786:
[31m-        if self
[m[31m-            .view
[m[31m-            .button(ids!(rotate_cw_button))
[m[31m-            .clicked(actions)
[m[31m-        {
[m[32m+        if self.view.button(ids!(rotate_cw_button)).clicked(actions) {
[m             if !self.is_animating_rotation {
                 self.is_animating_rotation = true;
                 if self.rotation_step == 3 {
Diff in /app/src/shared/image_viewer.rs:798:
             }
         }

[31m-        if self
[m[31m-            .view
[m[31m-            .button(ids!(rotate_ccw_button))
[m[31m-            .clicked(actions)
[m[31m-        {
[m[32m+        if self.view.button(ids!(rotate_ccw_button)).clicked(actions) {
[m             if !self.is_animating_rotation {
                 self.is_animating_rotation = true;
                 if self.rotation_step == 0 {
Diff in /app/src/shared/image_viewer.rs:831:
                     LoadState::FinishedBackgroundDecoding => {
                         self.is_loaded = true;
                         self.hide_footer(cx);
[31m-                    },
[m[32m+                    }
[m                     LoadState::Error(error) => {
                         self.show_error(cx, error);
                     }
Diff in /app/src/shared/image_viewer.rs:860:
         let rotated_image_ref = self
             .view
             .rotated_image(ids!(rotated_image_container.rotated_image));
[31m-        rotated_image_ref.apply_over(cx, live! {
[m[31m-            draw_bg: { scale: 1.0 }
[m[31m-        });
[m[32m+        rotated_image_ref.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                draw_bg: { scale: 1.0 }
[m[32m+            },
[m[32m+        );
[m         rotated_image_ref.set_texture(cx, None);
     }

Diff in /app/src/shared/image_viewer.rs:922:
     }

     /// Displays an image in the image viewer widget using the provided texture.
[31m-    ///
[m[32m+    ///
[m     /// `Texture` is an optional `Texture` that can be set to display an image. If `None`, the image is cleared.
     pub fn display_using_texture(&mut self, cx: &mut Cx) {
         if self.image_container_size.length() == 0.0 {
Diff in /app/src/shared/image_viewer.rs:934:
             .as_ref()
             .and_then(|texture| texture.get_format(cx).vec_width_height())
             .unwrap_or_default();
[31m-
[m[32m+
[m         // Calculate scaling factors for both dimensions
         let scale_x = self.image_container_size.x / texture_width as f64;
         let scale_y = self.image_container_size.y / texture_height as f64;
Diff in /app/src/shared/image_viewer.rs:941:
[31m-
[m[32m+
[m         // Use the smaller scale factor to ensure image fits within container
         let scale = scale_x.min(scale_y);
[31m-
[m[32m+
[m         let capped_width = (texture_width as f64 * scale).floor();
         let capped_height = (texture_height as f64 * scale).floor();
[31m-        self.capped_dimension = DVec2{
[m[32m+        self.capped_dimension = DVec2 {
[m             x: capped_width,
[31m-            y: capped_height
[m[32m+            y: capped_height,
[m         };
[31m-
[m[32m+
[m         rotated_image.set_texture(cx, texture);
         rotated_image.apply_over(
             cx,
Diff in /app/src/shared/image_viewer.rs:966:
         let capped_dimension = self.capped_dimension;
         let target_zoom = self.drag_state.zoom_level * zoom_factor;
         let (width, height) = if target_zoom < self.config.min_zoom {
[31m-            (capped_dimension.x * self.config.min_zoom, capped_dimension.y * self.config.min_zoom)
[m[32m+            (
[m[32m+                capped_dimension.x * self.config.min_zoom,
[m[32m+                capped_dimension.y * self.config.min_zoom,
[m[32m+            )
[m         } else {
             let actual_zoom_factor = target_zoom / self.drag_state.zoom_level;
             self.drag_state.zoom_level = target_zoom;
Diff in /app/src/shared/image_viewer.rs:976:
             (width, height)
         };

[31m-        rotated_image.apply_over(cx, live! {
[m[31m-            width: (width),
[m[31m-            height: (height),
[m[31m-        });
[m[32m+        rotated_image.apply_over(
[m[32m+            cx,
[m[32m+            live! {
[m[32m+                width: (width),
[m[32m+                height: (height),
[m[32m+            },
[m[32m+        );
[m     }

     /// Handle touch update events, specifically the pinch gesture to zoom in/out.
Diff in /app/src/shared/image_viewer.rs:1084:
                 .set_date_time(cx, timestamp);
         }

[31m-        if let Some((room_id, event_timeline_item)) = &metadata.avatar_parameter {
[m[31m-            let (sender, _) = self.view.avatar(ids!(user_profile_view.avatar)).set_avatar_and_get_username(
[m[31m-                cx,
[m[31m-                room_id,
[m[31m-                event_timeline_item.sender(),
[m[31m-                Some(event_timeline_item.sender_profile()),
[m[31m-                event_timeline_item.event_id(),
[m[31m-                false,
[m[31m-            );
[m[32m+        if let Some((room_id, event_timeline_item)) = &metadata.avatar_parameter {
[m[32m+            let (sender, _) = self
[m[32m+                .view
[m[32m+                .avatar(ids!(user_profile_view.avatar))
[m[32m+                .set_avatar_and_get_username(
[m[32m+                    cx,
[m[32m+                    room_id,
[m[32m+                    event_timeline_item.sender(),
[m[32m+                    Some(event_timeline_item.sender_profile()),
[m[32m+                    event_timeline_item.event_id(),
[m[32m+                    false,
[m[32m+                );
[m             if sender.len() > MAX_USERNAME_LENGTH {
                 meta_view
                     .label(ids!(user_profile_view.content.username))
Diff in /app/src/shared/image_viewer.rs:1109:
 impl ImageViewerRef {
     /// Configure zoom and pan settings for the image viewer
     pub fn configure_zoom(&mut self, config: ImageViewerZoomConfig) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.config = config;
     }

Diff in /app/src/shared/image_viewer.rs:1116:
     /// See [`ImageViewer::show_loaded()`].
     pub fn show_loaded(&mut self, cx: &mut Cx, image_bytes: &[u8]) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show_loaded(cx, image_bytes)
     }

Diff in /app/src/shared/image_viewer.rs:1126:
         texture: Option<Texture>,
         metadata: &Option<ImageViewerMetaData>,
     ) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.texture = texture.clone();
         inner.next_frame = cx.new_next_frame();
         if let Some(metadata) = metadata {
Diff in /app/src/shared/image_viewer.rs:1137:

     /// See [`ImageViewer::show_error()`].
     pub fn show_error(&mut self, cx: &mut Cx, error: &ImageViewerError) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show_error(cx, error);
     }

Diff in /app/src/shared/image_viewer.rs:1144:
     /// See [`ImageViewer::hide_footer()`].
     pub fn hide_footer(&mut self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.hide_footer(cx);
     }

Diff in /app/src/shared/image_viewer.rs:1150:
     /// See [`ImageViewer::reset()`].
     pub fn reset(&mut self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.reset(cx);
     }
 }
Diff in /app/src/shared/jump_to_bottom_button.rs:40:
                         sdf.fill_keep(self.background_color);
                         return sdf.result
                     }
[31m-                }
[m[32m+                }
[m                 enable_long_press: true,
             }

Diff in /app/src/shared/jump_to_bottom_button.rs:60:
                     draw_bg: {
                         color: (COLOR_UNREAD_BADGE_MESSAGES)
                         instance border_radius: 4.0
[31m-                        // Adjust this border_size to larger value to make oval smaller
[m[32m+                        // Adjust this border_size to larger value to make oval smaller
[m                         instance border_size: 2.0
                         fn pixel(self) -> vec4 {
                             let sdf = Sdf2d::viewport(self.pos * self.rect_size)
Diff in /app/src/shared/jump_to_bottom_button.rs:89:
                 }
             }
         }
[31m-
[m[32m+
[m     }
 }

Diff in /app/src/shared/jump_to_bottom_button.rs:96:
[31m-
[m #[derive(LiveHook, Live, Widget)]
 pub struct JumpToBottomButton {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 impl Widget for JumpToBottomButton {
Diff in /app/src/shared/jump_to_bottom_button.rs:118:
                 );
             }
             Hit::FingerHoverOut(_) => {
[31m-                cx.widget_action(
[m[31m-                    self.widget_uid(),
[m[31m-                    &scope.path,
[m[31m-                    TooltipAction::HoverOut,
[m[31m-                );
[m[32m+                cx.widget_action(self.widget_uid(), &scope.path, TooltipAction::HoverOut);
[m             }
             _ => {}
         }
Diff in /app/src/shared/jump_to_bottom_button.rs:181:
                 };
                 self.label(ids!(unread_messages_count)).set_text(
                     cx,
[31m-                    &format!("{}{plus_sign}", std::cmp::min(unread_message_count, 99))
[m[32m+                    &format!("{}{plus_sign}", std::cmp::min(unread_message_count, 99)),
[m                 );
[31m-                self.view(ids!(unread_message_badge.green_rounded_label)).apply_over(cx, live!{
[m[31m-                    draw_bg: {
[m[31m-                        border_size: (border_size),
[m[31m-                    }
[m[31m-                });
[m[32m+                self.view(ids!(unread_message_badge.green_rounded_label))
[m[32m+                    .apply_over(
[m[32m+                        cx,
[m[32m+                        live! {
[m[32m+                            draw_bg: {
[m[32m+                                border_size: (border_size),
[m[32m+                            }
[m[32m+                        },
[m[32m+                    );
[m             }
         }
[31m-
[m     }

     /// Updates the visibility of the jump to bottom button and the unread message badge
Diff in /app/src/shared/jump_to_bottom_button.rs:212:
         //       query the portallist's `at_end` state and set the visibility accordingly.

         if self.button(ids!(jump_to_bottom_button)).clicked(actions) {
[31m-            portal_list.smooth_scroll_to_end(
[m[31m-                cx,
[m[31m-                SCROLL_TO_BOTTOM_SPEED,
[m[31m-                None,
[m[31m-            );
[m[32m+            portal_list.smooth_scroll_to_end(cx, SCROLL_TO_BOTTOM_SPEED, None);
[m             self.update_visibility(cx, false);
         } else {
             self.update_visibility(cx, portal_list.is_at_end());
Diff in /app/src/shared/jump_to_bottom_button.rs:226:
             self.redraw(cx);
         }
     }
[31m-
[m }

 impl JumpToBottomButtonRef {
Diff in /app/src/shared/jump_to_bottom_button.rs:245:
     }

     /// See [`JumpToBottomButton::update_from_actions()`].
[31m-    pub fn update_from_actions(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        portal_list: &PortalListRef,
[m[31m-        actions: &Actions,
[m[31m-    ) {
[m[32m+    pub fn update_from_actions(&self, cx: &mut Cx, portal_list: &PortalListRef, actions: &Actions) {
[m         if let Some(mut inner) = self.borrow_mut() {
             inner.update_from_actions(cx, portal_list, actions);
         }
Diff in /app/src/shared/jump_to_bottom_button.rs:263:
     /// There are unread messages, but we do not know how many.
     Unknown,
     /// There are unread messages, and we know exactly how many.
[31m-    Known(u64)
[m[32m+    Known(u64),
[m }

Diff in /app/src/shared/mentionable_text_input.rs:7:
 use crate::shared::styles::COLOR_UNKNOWN_ROOM_AVATAR;
 use crate::utils;

[31m-
[m use makepad_widgets::{text::selection::Cursor, *};
[31m-use matrix_sdk::ruma::{events::{room::message::RoomMessageEventContent, Mentions}, OwnedRoomId, OwnedUserId};
[m[32m+use matrix_sdk::ruma::{
[m[32m+    events::{room::message::RoomMessageEventContent, Mentions},
[m[32m+    OwnedRoomId, OwnedUserId,
[m[32m+};
[m use matrix_sdk::room::RoomMember;
 use std::collections::{BTreeMap, BTreeSet};
 use unicode_segmentation::UnicodeSegmentation;
Diff in /app/src/shared/mentionable_text_input.rs:286:
 // /// from normal `@` characters.
 // const MENTION_START_STRING: &str = "\u{8288}@\u{8288}";

[31m-
[m #[derive(Debug)]
 pub enum MentionableTextInputAction {
     /// Notifies the MentionableTextInput about updated power levels for the room.
Diff in /app/src/shared/mentionable_text_input.rs:293:
     PowerLevelsUpdated {
         room_id: OwnedRoomId,
         can_notify_room: bool,
[31m-    }
[m[32m+    },
[m }

 /// Widget that extends CommandTextInput with @mention capabilities
Diff in /app/src/shared/mentionable_text_input.rs:300:
 #[derive(Live, LiveHook, Widget)]
 pub struct MentionableTextInput {
     /// Base command text input
[31m-    #[deref] cmd_text_input: CommandTextInput,
[m[32m+    #[deref]
[m[32m+    cmd_text_input: CommandTextInput,
[m     /// Template for user list items
[31m-    #[live] user_list_item: Option<LivePtr>,
[m[32m+    #[live]
[m[32m+    user_list_item: Option<LivePtr>,
[m     /// Template for the @room mention list item
[31m-    #[live] room_mention_list_item: Option<LivePtr>,
[m[32m+    #[live]
[m[32m+    room_mention_list_item: Option<LivePtr>,
[m     /// Template for loading indicator
[31m-    #[live] loading_indicator: Option<LivePtr>,
[m[32m+    #[live]
[m[32m+    loading_indicator: Option<LivePtr>,
[m     /// Template for no matches indicator
[31m-    #[live] no_matches_indicator: Option<LivePtr>,
[m[32m+    #[live]
[m[32m+    no_matches_indicator: Option<LivePtr>,
[m     /// Position where the @ mention starts
[31m-    #[rust] current_mention_start_index: Option<usize>,
[m[32m+    #[rust]
[m[32m+    current_mention_start_index: Option<usize>,
[m     /// The set of users that were mentioned (at one point) in this text input.
     /// Due to characters being deleted/removed, this list is a *superset*
     /// of possible users who may have been mentioned.
Diff in /app/src/shared/mentionable_text_input.rs:317:
     /// All of these mentions may not exist in the final text input content;
     /// this is just a list of users to search the final sent message for
     /// when adding in new mentions.
[31m-    #[rust] possible_mentions: BTreeMap<OwnedUserId, String>,
[m[32m+    #[rust]
[m[32m+    possible_mentions: BTreeMap<OwnedUserId, String>,
[m     /// Indicates if the `@room` option was explicitly selected.
[31m-    #[rust] possible_room_mention: bool,
[m[32m+    #[rust]
[m[32m+    possible_room_mention: bool,
[m     /// Indicates if currently in mention search mode
[31m-    #[rust] is_searching: bool,
[m[32m+    #[rust]
[m[32m+    is_searching: bool,
[m     /// Whether the current user can notify everyone in the room (@room mention)
[31m-    #[rust] can_notify_room: bool,
[m[32m+    #[rust]
[m[32m+    can_notify_room: bool,
[m     /// Whether the room members are currently being loaded
[31m-    #[rust] members_loading: bool,
[m[32m+    #[rust]
[m[32m+    members_loading: bool,
[m }

[31m-
[m impl Widget for MentionableTextInput {
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.cmd_text_input.handle_event(cx, event, scope);
Diff in /app/src/shared/mentionable_text_input.rs:335:

         // Best practice: Always check Scope first to get current context
         // Scope represents the current widget context as passed down from parents
[31m-        let scope_room_id = scope.props.get::<RoomScreenProps>()
[m[31m-            .expect("BUG: RoomScreenProps should be available in Scope::props for MentionableTextInput")
[m[32m+        let scope_room_id = scope
[m[32m+            .props
[m[32m+            .get::<RoomScreenProps>()
[m[32m+            .expect(
[m[32m+                "BUG: RoomScreenProps should be available in Scope::props for MentionableTextInput",
[m[32m+            )
[m             .room_name_id
             .room_id()
             .clone();
Diff in /app/src/shared/mentionable_text_input.rs:377:
                 }

                 // Handle MentionableTextInputAction actions
[31m-                if let Some(MentionableTextInputAction::PowerLevelsUpdated { room_id, can_notify_room }) = action.downcast_ref() {
[m[32m+                if let Some(MentionableTextInputAction::PowerLevelsUpdated {
[m[32m+                    room_id,
[m[32m+                    can_notify_room,
[m[32m+                }) = action.downcast_ref()
[m[32m+                {
[m                     if &scope_room_id != room_id {
                         continue;
                     }
Diff in /app/src/shared/mentionable_text_input.rs:429:
     }
 }

[31m-
[m impl MentionableTextInput {
[31m-
[m     /// Check if members are loading and show loading indicator if needed.
     ///
     /// Returns true if we should return early because we're in the loading state.
Diff in /app/src/shared/mentionable_text_input.rs:481:
             return false;
         }

[31m-        let Some(ptr) = self.room_mention_list_item else { return false };
[m[32m+        let Some(ptr) = self.room_mention_list_item else {
[m[32m+            return false;
[m[32m+        };
[m         let room_mention_item = WidgetRef::new_from_ptr(cx, Some(ptr));
         let mut room_avatar_shown = false;

Diff in /app/src/shared/mentionable_text_input.rs:508:
                     } else {
                         log!("Failed to show @room avatar with room avatar image");
                     }
[31m-                },
[m[32m+                }
[m                 AvatarCacheEntry::Requested => {
[31m-                    avatar_ref.show_text(cx, Some(COLOR_UNKNOWN_ROOM_AVATAR), None, &room_name_first_char);
[m[32m+                    avatar_ref.show_text(
[m[32m+                        cx,
[m[32m+                        Some(COLOR_UNKNOWN_ROOM_AVATAR),
[m[32m+                        None,
[m[32m+                        &room_name_first_char,
[m[32m+                    );
[m                     room_avatar_shown = true;
[31m-                },
[m[32m+                }
[m                 AvatarCacheEntry::Failed => {
                     log!("Failed to load room avatar for @room");
                 }
Diff in /app/src/shared/mentionable_text_input.rs:521:

         // If unable to display room avatar, show first character of room name
         if !room_avatar_shown {
[31m-            avatar_ref.show_text(cx, Some(COLOR_UNKNOWN_ROOM_AVATAR), None, &room_name_first_char);
[m[32m+            avatar_ref.show_text(
[m[32m+                cx,
[m[32m+                Some(COLOR_UNKNOWN_ROOM_AVATAR),
[m[32m+                None,
[m[32m+                &room_name_first_char,
[m[32m+            );
[m         }

         // Apply layout and height styling based on device type
Diff in /app/src/shared/mentionable_text_input.rs:528:
[31m-        let new_height = if is_desktop { DESKTOP_ITEM_HEIGHT } else { MOBILE_ITEM_HEIGHT };
[m[32m+        let new_height = if is_desktop {
[m[32m+            DESKTOP_ITEM_HEIGHT
[m[32m+        } else {
[m[32m+            MOBILE_ITEM_HEIGHT
[m[32m+        };
[m         if is_desktop {
[31m-            room_mention_item.apply_over(cx, live! {
[m[31m-                height: (new_height),
[m[31m-                flow: Right,
[m[31m-            });
[m[32m+            room_mention_item.apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    height: (new_height),
[m[32m+                    flow: Right,
[m[32m+                },
[m[32m+            );
[m         } else {
[31m-            room_mention_item.apply_over(cx, live! {
[m[31m-                height: (new_height),
[m[31m-                flow: Down,
[m[31m-            });
[m[32m+            room_mention_item.apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    height: (new_height),
[m[32m+                    flow: Down,
[m[32m+                },
[m[32m+            );
[m         }

         self.cmd_text_input.add_item(room_mention_item);
Diff in /app/src/shared/mentionable_text_input.rs:599:
     ) -> usize {
         let mut items_added = 0;

[31m-        for (index, (display_name, member)) in matched_members.into_iter().take(user_items_limit).enumerate() {
[m[31m-            let Some(user_list_item_ptr) = self.user_list_item else { continue };
[m[32m+        for (index, (display_name, member)) in matched_members
[m[32m+            .into_iter()
[m[32m+            .take(user_items_limit)
[m[32m+            .enumerate()
[m[32m+        {
[m[32m+            let Some(user_list_item_ptr) = self.user_list_item else {
[m[32m+                continue;
[m[32m+            };
[m             let item = WidgetRef::new_from_ptr(cx, Some(user_list_item_ptr));

[31m-            item.label(ids!(user_info.username)).set_text(cx, &display_name);
[m[32m+            item.label(ids!(user_info.username))
[m[32m+                .set_text(cx, &display_name);
[m
             // Use the full user ID string
             let user_id_str = member.user_id().as_str();
Diff in /app/src/shared/mentionable_text_input.rs:697:
             let room_mention_text = room_mention_label.text();
             let room_user_id_text = selected.label(ids!(room_user_id)).text();

[31m-            let is_room_mention = { room_mention_text == "Notify the entire room" && room_user_id_text == "@room" };
[m[32m+            let is_room_mention =
[m[32m+                { room_mention_text == "Notify the entire room" && room_user_id_text == "@room" };
[m
             let mention_to_insert = if is_room_mention {
                 // Always set to true, don't reset previously selected @room mentions
Diff in /app/src/shared/mentionable_text_input.rs:711:
                     log!("Failed to parse user_id: {}", user_id_str);
                     return;
                 };
[31m-                self.possible_mentions.insert(user_id.clone(), username.clone());
[m[32m+                self.possible_mentions
[m[32m+                    .insert(user_id.clone(), username.clone());
[m
                 // Currently, we directly insert the markdown link for user mentions
                 // instead of the user's display name, because we don't yet have a way
Diff in /app/src/shared/mentionable_text_input.rs:718:
                 // to track mentioned display names and replace them later.
[31m-                format!(
[m[31m-                    "[{username}]({}) ",
[m[31m-                    user_id.matrix_to_uri(),
[m[31m-                )
[m[32m+                format!("[{username}]({}) ", user_id.matrix_to_uri(),)
[m             };

[31m-
[m             // Use utility function to safely replace text
             let new_text = utils::safe_replace_by_byte_indices(
                 &current_text,
Diff in /app/src/shared/mentionable_text_input.rs:734:
             self.cmd_text_input.set_text(cx, &new_text);
             // Calculate new cursor position
             let new_pos = start_idx + mention_to_insert.len();
[31m-            text_input_ref.set_cursor(cx, Cursor { index: new_pos, prefer_next_row: false }, false);
[m[31m-
[m[32m+            text_input_ref.set_cursor(
[m[32m+                cx,
[m[32m+                Cursor {
[m[32m+                    index: new_pos,
[m[32m+                    prefer_next_row: false,
[m[32m+                },
[m[32m+                false,
[m[32m+            );
[m         }

         self.is_searching = false;
Diff in /app/src/shared/mentionable_text_input.rs:756:
             return;
         }

[31m-        let cursor_pos = self.cmd_text_input.text_input_ref().borrow().map_or(0, |p| p.cursor().index);
[m[32m+        let cursor_pos = self
[m[32m+            .cmd_text_input
[m[32m+            .text_input_ref()
[m[32m+            .borrow()
[m[32m+            .map_or(0, |p| p.cursor().index);
[m
         // Check if we're currently searching and the @ symbol was deleted
         if self.is_searching {
Diff in /app/src/shared/mentionable_text_input.rs:763:
             if let Some(start_pos) = self.current_mention_start_index {
                 // Check if the @ symbol at the start position still exists
[31m-                if start_pos >= text.len() || text.get(start_pos..start_pos+1).is_some_and(|c| c != "@") {
[m[32m+                if start_pos >= text.len()
[m[32m+                    || text.get(start_pos..start_pos + 1).is_some_and(|c| c != "@")
[m[32m+                {
[m                     // The @ symbol was deleted, stop searching
                     self.close_mention_popup(cx);
                     return;
Diff in /app/src/shared/mentionable_text_input.rs:775:
             self.current_mention_start_index = Some(trigger_pos);
             self.is_searching = true;

[31m-            let search_text = utils::safe_substring_by_byte_indices(
[m[31m-                &text,
[m[31m-                trigger_pos + 1,
[m[31m-                cursor_pos
[m[31m-            ).to_lowercase();
[m[32m+            let search_text =
[m[32m+                utils::safe_substring_by_byte_indices(&text, trigger_pos + 1, cursor_pos)
[m[32m+                    .to_lowercase();
[m
             // Ensure header view is visible to prevent header disappearing during consecutive @mentions
             let popup = self.cmd_text_input.view(ids!(popup));
Diff in /app/src/shared/mentionable_text_input.rs:796:
     /// Updates the mention suggestion list based on search
     fn update_user_list(&mut self, cx: &mut Cx, search_text: &str, scope: &mut Scope) {
         // 1. Get Props from Scope
[31m-        let room_props = scope.props.get::<RoomScreenProps>()
[m[32m+        let room_props = scope
[m[32m+            .props
[m[32m+            .get::<RoomScreenProps>()
[m             .expect("RoomScreenProps should be available in scope for MentionableTextInput");

         // 2. Check if members are loading and handle loading state
Diff in /app/src/shared/mentionable_text_input.rs:819:
         let mut items_added = 0;

         // 4. Try to add @room mention item
[31m-        let has_room_item = self.try_search_messages_mention_item(cx, search_text, room_props, is_desktop);
[m[32m+        let has_room_item =
[m[32m+            self.try_search_messages_mention_item(cx, search_text, room_props, is_desktop);
[m         if has_room_item {
             items_added += 1;
         }
Diff in /app/src/shared/mentionable_text_input.rs:826:

         // 5. Find and sort matching members
[31m-        let max_matched_members = max_visible_items * 2;  // Buffer for better UX
[m[31m-        let matched_members = self.find_and_sort_matching_members(search_text, room_members, max_matched_members);
[m[32m+        let max_matched_members = max_visible_items * 2; // Buffer for better UX
[m[32m+        let matched_members =
[m[32m+            self.find_and_sort_matching_members(search_text, room_members, max_matched_members);
[m
         // 6. Add user mention items
         let user_items_limit = max_visible_items.saturating_sub(has_room_item as usize);
Diff in /app/src/shared/mentionable_text_input.rs:833:
[31m-        let user_items_added = self.add_user_mention_items(cx, matched_members, user_items_limit, is_desktop);
[m[32m+        let user_items_added =
[m[32m+            self.add_user_mention_items(cx, matched_members, user_items_limit, is_desktop);
[m         items_added += user_items_added;

         // 7. Update popup visibility based on whether we have items
Diff in /app/src/shared/mentionable_text_input.rs:853:
         // Simple logic: trigger when cursor is immediately after @ symbol
         // Only trigger if @ is preceded by whitespace or beginning of text
         if cursor_grapheme_idx > 0 && text_graphemes.get(cursor_grapheme_idx - 1) == Some(&"@") {
[31m-            let is_preceded_by_whitespace_or_start = cursor_grapheme_idx == 1 ||
[m[31m-                (cursor_grapheme_idx > 1 && text_graphemes.get(cursor_grapheme_idx - 2).is_some_and(|g| g.trim().is_empty()));
[m[32m+            let is_preceded_by_whitespace_or_start = cursor_grapheme_idx == 1
[m[32m+                || (cursor_grapheme_idx > 1
[m[32m+                    && text_graphemes
[m[32m+                        .get(cursor_grapheme_idx - 2)
[m[32m+                        .is_some_and(|g| g.trim().is_empty()));
[m             if is_preceded_by_whitespace_or_start {
                 if let Some(&byte_pos) = byte_positions.get(cursor_grapheme_idx - 1) {
                     return Some(byte_pos);
Diff in /app/src/shared/mentionable_text_input.rs:865:
         // Find the last @ symbol before the cursor for search continuation
         // Only continue if we're already in search mode
         if self.is_searching {
[31m-            let last_at_pos = text_graphemes.get(..cursor_grapheme_idx)
[m[31m-                .and_then(|slice| slice.iter()
[m[32m+            let last_at_pos = text_graphemes.get(..cursor_grapheme_idx).and_then(|slice| {
[m[32m+                slice
[m[32m+                    .iter()
[m                     .enumerate()
                     .filter(|(_, g)| **g == "@")
                     .map(|(i, _)| i)
Diff in /app/src/shared/mentionable_text_input.rs:873:
[31m-                    .next_back());
[m[32m+                    .next_back()
[m[32m+            });
[m
             if let Some(at_idx) = last_at_pos {
                 // Get the byte position of this @ symbol
Diff in /app/src/shared/mentionable_text_input.rs:877:
                 let &at_byte_pos = byte_positions.get(at_idx)?;

                 // Extract the text after the @ symbol up to the cursor position
[31m-                let mention_text = text_graphemes.get(at_idx + 1..cursor_grapheme_idx)
[m[32m+                let mention_text = text_graphemes
[m[32m+                    .get(at_idx + 1..cursor_grapheme_idx)
[m                     .unwrap_or(&[]);

                 // Only trigger if this looks like an ongoing mention (contains only alphanumeric and basic chars)
Diff in /app/src/shared/mentionable_text_input.rs:978:
         // Priority 6: Localpart contains search text at word boundary
         if let Some(pos) = localpart_lower.find(&search_text_lower) {
             // Check if it's at the start of a word (preceded by non-alphanumeric or at start)
[31m-            if pos == 0 || !localpart_lower.chars().nth(pos - 1).unwrap_or('a').is_alphanumeric() {
[m[32m+            if pos == 0
[m[32m+                || !localpart_lower
[m[32m+                    .chars()
[m[32m+                    .nth(pos - 1)
[m[32m+                    .unwrap_or('a')
[m[32m+                    .is_alphanumeric()
[m[32m+            {
[m                 return 6;
             }
         }
Diff in /app/src/shared/mentionable_text_input.rs:1003:
         self.cmd_text_input.clear_items();

         // Create loading indicator widget
[31m-        let Some(ptr) = self.loading_indicator else { return };
[m[32m+        let Some(ptr) = self.loading_indicator else {
[m[32m+            return;
[m[32m+        };
[m         let loading_item = WidgetRef::new_from_ptr(cx, Some(ptr));

         // Start the loading animation
Diff in /app/src/shared/mentionable_text_input.rs:1010:
[31m-        loading_item.bouncing_dots(ids!(loading_animation)).start_animation(cx);
[m[32m+        loading_item
[m[32m+            .bouncing_dots(ids!(loading_animation))
[m[32m+            .start_animation(cx);
[m
         // Add the loading indicator to the popup
         self.cmd_text_input.add_item(loading_item);
Diff in /app/src/shared/mentionable_text_input.rs:1035:
         self.cmd_text_input.clear_items();

         // Create no matches indicator widget
[31m-        let Some(ptr) = self.no_matches_indicator else { return };
[m[32m+        let Some(ptr) = self.no_matches_indicator else {
[m[32m+            return;
[m[32m+        };
[m         let no_matches_item = WidgetRef::new_from_ptr(cx, Some(ptr));

         // Add the no matches indicator to the popup
Diff in /app/src/shared/mentionable_text_input.rs:1098:
         self.redraw(cx);
     }

[31m-
[m[31m-
[m[31m-
[m     /// Sets whether the current user can notify the entire room (@room mention)
     pub fn set_can_notify_room(&mut self, can_notify: bool) {
         self.can_notify_room = can_notify;
Diff in /app/src/shared/mentionable_text_input.rs:1110:
     pub fn can_notify_room(&self) -> bool {
         self.can_notify_room
     }
[31m-
[m[31m-
[m }

 impl MentionableTextInputRef {
Diff in /app/src/shared/mentionable_text_input.rs:1132:
         }
     }

[31m-
[m     /// Sets whether the current user can notify the entire room (@room mention)
     pub fn set_can_notify_room(&self, can_notify: bool) {
         if let Some(mut inner) = self.borrow_mut() {
Diff in /app/src/shared/mentionable_text_input.rs:1145:
         self.borrow().is_some_and(|inner| inner.can_notify_room())
     }

[31m-
[m     /// Returns the mentions actually present in the given html message content.
     fn get_real_mentions_in_html_text(&self, html: &str) -> Mentions {
         let mut mentions = Mentions::new();
Diff in /app/src/shared/mentionable_text_input.rs:1211:
             message.add_mentions(self.get_real_mentions_in_markdown_text(entered_text))
         }
     }
[31m-
[m }

Diff in /app/src/shared/mod.rs:20:
 pub mod restore_status_view;
 pub mod image_viewer;

[31m-
[m pub fn live_design(cx: &mut Cx) {
     // Order matters here, as some widget definitions depend on others.
     styles::live_design(cx);
Diff in /app/src/shared/popup_list.rs:213:
         flow: Down,
         padding: { top: 3 }
         align: { x: 0.98 }
[31m-
[m[32m+
[m         <RoundedView> {
             width: Fit, height: Fit
             show_bg: true,
Diff in /app/src/shared/popup_list.rs:293:
                 main_content = <MainContent> {}
             }
             progress_bar = <ProgressBar> {}
[31m-            // Add a small gap between the progress bar and the end of the popup
[m[32m+            // Add a small gap between the progress bar and the end of the popup
[m             // to ensure the progress bar is within the popup.
             <View> {
                 height: 0.2
Diff in /app/src/shared/popup_list.rs:518:
             } else {
                 COLOR_WHITE // White text for all other kinds
             };
[31m-
[m[32m+
[m             view.apply_over(
                 cx,
                 live! {
Diff in /app/src/shared/restore_status_view.rs:46:
 /// A view that displays a spinner and a label to indicate that a restore operation is in progress for a room.
 #[derive(Live, LiveHook, Widget)]
 pub struct RestoreStatusView {
[31m-    #[deref] view: View,
[m[31m-    #[live(true)] visible: bool,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[live(true)]
[m[32m+    visible: bool,
[m }

 impl Widget for RestoreStatusView {
Diff in /app/src/shared/restore_status_view.rs:56:
             self.view.handle_event(cx, event, scope);
         }
     }
[31m-
[m[32m+
[m     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
         if self.visible {
             self.view.draw_walk(cx, scope, walk)
Diff in /app/src/shared/restore_status_view.rs:75:
         if let Some(mut inner) = self.borrow_mut() {
             inner.visible = visible;
             if !visible {
[31m-                inner.label(ids!(restore_status_label))
[m[31m-                    .set_text(cx, "");
[m[32m+                inner.label(ids!(restore_status_label)).set_text(cx, "");
[m             }
         }
     }
Diff in /app/src/shared/restore_status_view.rs:92:
     ///
     /// The `room_name` parameter is used to fill in the room name in the error message.
     /// Its `Display` implementation automatically handles Empty names by falling back to the room ID.
[31m-    pub fn set_content(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        all_rooms_loaded: bool,
[m[31m-        room_name: &RoomNameId,
[m[31m-    ) {
[m[32m+    pub fn set_content(&self, cx: &mut Cx, all_rooms_loaded: bool, room_name: &RoomNameId) {
[m         let Some(inner) = self.borrow() else { return };
         let restore_status_spinner = inner.view.view(ids!(restore_status_spinner));
         let restore_status_label = inner.view.label(ids!(restore_status_label));
Diff in /app/src/shared/restore_status_view.rs:112:
             );
         } else {
             restore_status_spinner.set_visible(cx, true);
[31m-            restore_status_label.set_text(
[m[31m-                cx,
[m[31m-                "Waiting for this room to be loaded from the homeserver",
[m[31m-            );
[m[32m+            restore_status_label
[m[32m+                .set_text(cx, "Waiting for this room to be loaded from the homeserver");
[m         }
     }
 }
Diff in /app/src/shared/room_filter_input_bar.rs:76:
 /// See the module-level docs for more detail.
 #[derive(Live, LiveHook, Widget)]
 pub struct RoomFilterInputBar {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m }

 /// Actions emitted by the `RoomFilterInputBar` based on user interaction with it.
Diff in /app/src/shared/room_filter_input_bar.rs:117:
             cx.widget_action(
                 self.widget_uid(),
                 &scope.path,
[31m-                RoomFilterAction::Changed(keywords)
[m[32m+                RoomFilterAction::Changed(keywords),
[m             );
         }

Diff in /app/src/shared/room_filter_input_bar.rs:128:
             cx.widget_action(
                 self.widget_uid(),
                 &scope.path,
[31m-                RoomFilterAction::Changed(String::new())
[m[32m+                RoomFilterAction::Changed(String::new()),
[m             );
         }
     }
Diff in /app/src/shared/styles.rs:297:
     }
 }

[31m-
[m pub const NAVIGATION_TAB_BAR_SIZE: f64 = 68.0;
 pub const REDACTED_MESSAGE_FONT_SIZE: f32 = 10.0;

Diff in /app/src/shared/styles.rs:304:
 /// #FFFFFF
[31m-pub const COLOR_PRIMARY:               Vec4 = vec4(1.0, 1.0, 1.0, 1.0);
[m[32m+pub const COLOR_PRIMARY: Vec4 = vec4(1.0, 1.0, 1.0, 1.0);
[m /// #0F88FE
[31m-pub const COLOR_ACTIVE_PRIMARY:        Vec4 = vec4(0.059, 0.533, 0.996, 1.0);
[m[32m+pub const COLOR_ACTIVE_PRIMARY: Vec4 = vec4(0.059, 0.533, 0.996, 1.0);
[m /// #106FCC
 pub const COLOR_ACTIVE_PRIMARY_DARKER: Vec4 = vec4(0.063, 0.435, 0.682, 1.0);
 /// #138808
Diff in /app/src/shared/styles.rs:311:
[31m-pub const COLOR_FG_ACCEPT_GREEN:       Vec4 = vec4(0.074, 0.533, 0.031, 1.0);
[m[32m+pub const COLOR_FG_ACCEPT_GREEN: Vec4 = vec4(0.074, 0.533, 0.031, 1.0);
[m /// #F0FFF0
[31m-pub const COLOR_BG_ACCEPT_GREEN:       Vec4 = vec4(0.941, 1.0, 0.941, 1.0);
[m[32m+pub const COLOR_BG_ACCEPT_GREEN: Vec4 = vec4(0.941, 1.0, 0.941, 1.0);
[m /// #B3B3B3
[31m-pub const COLOR_FG_DISABLED:           Vec4 = vec4(0.7, 0.7, 0.7, 1.0);
[m[32m+pub const COLOR_FG_DISABLED: Vec4 = vec4(0.7, 0.7, 0.7, 1.0);
[m /// #E0E0E0
[31m-pub const COLOR_BG_DISABLED:           Vec4 = vec4(0.878, 0.878, 0.878, 1.0);
[m[32m+pub const COLOR_BG_DISABLED: Vec4 = vec4(0.878, 0.878, 0.878, 1.0);
[m /// #DC0005
[31m-pub const COLOR_FG_DANGER_RED:         Vec4 = vec4(0.863, 0.0, 0.02, 1.0);
[m[32m+pub const COLOR_FG_DANGER_RED: Vec4 = vec4(0.863, 0.0, 0.02, 1.0);
[m /// #FFF0F0
[31m-pub const COLOR_BG_DANGER_RED:         Vec4 = vec4(1.0, 0.941, 0.941, 1.0);
[m[32m+pub const COLOR_BG_DANGER_RED: Vec4 = vec4(1.0, 0.941, 0.941, 1.0);
[m /// #572DCC
[31m-pub const COLOR_ROBRIX_PURPLE:         Vec4 = vec4(0.341, 0.176, 0.8, 1.0);
[m[32m+pub const COLOR_ROBRIX_PURPLE: Vec4 = vec4(0.341, 0.176, 0.8, 1.0);
[m /// #05CDC7
[31m-pub const COLOR_ROBRIX_CYAN:           Vec4 = vec4(0.031, 0.804, 0.78, 1.0);
[m[32m+pub const COLOR_ROBRIX_CYAN: Vec4 = vec4(0.031, 0.804, 0.78, 1.0);
[m /// #FF0000
 pub const COLOR_UNREAD_BADGE_MENTIONS: Vec4 = vec4(1.0, 0.0, 0.0, 1.0);
 /// #572DCC
Diff in /app/src/shared/styles.rs:329:
[31m-pub const COLOR_UNREAD_BADGE_MARKED:   Vec4 = COLOR_ROBRIX_CYAN;
[m[32m+pub const COLOR_UNREAD_BADGE_MARKED: Vec4 = COLOR_ROBRIX_CYAN;
[m /// #AAAAAA
 pub const COLOR_UNREAD_BADGE_MESSAGES: Vec4 = vec4(0.667, 0.667, 0.667, 1.0);
 /// #FF6e00
Diff in /app/src/shared/styles.rs:333:
[31m-pub const COLOR_UNKNOWN_ROOM_AVATAR:   Vec4 = vec4(1.0, 0.431, 0.0, 1.0);
[m[32m+pub const COLOR_UNKNOWN_ROOM_AVATAR: Vec4 = vec4(1.0, 0.431, 0.0, 1.0);
[m /// #fcdb03
[31m-pub const COLOR_WARNING_YELLOW:        Vec4 = vec4(0.988, 0.859, 0.01, 1.0);
[m[32m+pub const COLOR_WARNING_YELLOW: Vec4 = vec4(0.988, 0.859, 0.01, 1.0);
[m /// #0f88fe
[31m-pub const COLOR_INFO_BLUE:             Vec4 = vec4(0.05, 0.53, 0.996, 1.0);
[m[32m+pub const COLOR_INFO_BLUE: Vec4 = vec4(0.05, 0.53, 0.996, 1.0);
[m /// #FFFFFF
[31m-pub const COLOR_WHITE:                 Vec4 = vec4(1.0, 1.0, 1.0, 1.0);
[m[32m+pub const COLOR_WHITE: Vec4 = vec4(1.0, 1.0, 1.0, 1.0);
[m /// #888888
[31m-pub const COLOR_MESSAGE_NOTICE_TEXT:   Vec4 = vec4(0.5, 0.5, 0.5, 1.0);
[m[32m+pub const COLOR_MESSAGE_NOTICE_TEXT: Vec4 = vec4(0.5, 0.5, 0.5, 1.0);
[m /// #953800
[31m-pub const COLOR_WARNING_NOT_FOUND:     Vec4 = vec4(0.584, 0.219, 0.0, 1.0);
[m[32m+pub const COLOR_WARNING_NOT_FOUND: Vec4 = vec4(0.584, 0.219, 0.0, 1.0);
[m /// #F0F5FF
[31m-pub const COLOR_BG_PREVIEW:            Vec4 = vec4(0.941, 0.961, 1.0, 1.0);
[m[32m+pub const COLOR_BG_PREVIEW: Vec4 = vec4(0.941, 0.961, 1.0, 1.0);
[m /// #CDEDDF
[31m-pub const COLOR_BG_PREVIEW_HOVER:      Vec4 = vec4(0.804, 0.929, 0.875, 1.0);
[m[32m+pub const COLOR_BG_PREVIEW_HOVER: Vec4 = vec4(0.804, 0.929, 0.875, 1.0);
[m
Diff in /app/src/shared/text_or_image.rs:55:
     }
 }

[31m-
[m /// A view that holds an image or text content, and can switch between the two.
 ///
 /// This is useful for displaying alternate text when an image is not (yet) available
Diff in /app/src/shared/text_or_image.rs:63:
 /// is being fetched.
 #[derive(Live, Widget, LiveHook)]
 pub struct TextOrImage {
[31m-    #[deref] view: View,
[m[31m-    #[rust] status: TextOrImageStatus,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    status: TextOrImageStatus,
[m     // #[rust(TextOrImageStatus::Text)] status: TextOrImageStatus,
[31m-    #[rust] size_in_pixels: (usize, usize),
[m[32m+    #[rust]
[m[32m+    size_in_pixels: (usize, usize),
[m }

 impl Widget for TextOrImage {
Diff in /app/src/shared/text_or_image.rs:112:
         self.view(ids!(image_view)).set_visible(cx, false);
         self.view(ids!(default_image_view)).set_visible(cx, false);
         self.view(ids!(text_view)).set_visible(cx, true);
[31m-        self.view.label(ids!(text_view.label)).set_text(cx, text.as_ref());
[m[32m+        self.view
[m[32m+            .label(ids!(text_view.label))
[m[32m+            .set_text(cx, text.as_ref());
[m         self.status = TextOrImageStatus::Text;
     }

Diff in /app/src/shared/text_or_image.rs:125:
     ///   * If successful, the `image_set_function` should return the size of the image
     ///     in pixels as a tuple, `(width, height)`.
     ///   * If `image_set_function` returns an error, no change is made to this `TextOrImage`.
[31m-    pub fn show_image<F, E>(&mut self, cx: &mut Cx, source_url: Option<MediaSource>, image_set_function: F) -> Result<(), E>
[m[31m-        where F: FnOnce(&mut Cx, ImageRef) -> Result<(usize, usize), E>
[m[32m+    pub fn show_image<F, E>(
[m[32m+        &mut self,
[m[32m+        cx: &mut Cx,
[m[32m+        source_url: Option<MediaSource>,
[m[32m+        image_set_function: F,
[m[32m+    ) -> Result<(), E>
[m[32m+    where
[m[32m+        F: FnOnce(&mut Cx, ImageRef) -> Result<(usize, usize), E>,
[m     {
         let image_ref = self.view.image(ids!(image_view.image));
         match image_set_function(cx, image_ref) {
Diff in /app/src/shared/text_or_image.rs:167:
     }

     /// See [TextOrImage::show_image()].
[31m-    pub fn show_image<F, E>(&self, cx: &mut Cx, source_url: Option<MediaSource>, image_set_function: F) -> Result<(), E>
[m[31m-        where F: FnOnce(&mut Cx, ImageRef) -> Result<(usize, usize), E>
[m[32m+    pub fn show_image<F, E>(
[m[32m+        &self,
[m[32m+        cx: &mut Cx,
[m[32m+        source_url: Option<MediaSource>,
[m[32m+        image_set_function: F,
[m[32m+    ) -> Result<(), E>
[m[32m+    where
[m[32m+        F: FnOnce(&mut Cx, ImageRef) -> Result<(usize, usize), E>,
[m     {
         if let Some(mut inner) = self.borrow_mut() {
             inner.show_image(cx, source_url, image_set_function)
Diff in /app/src/shared/text_or_image.rs:214:
 pub enum TextOrImageStatus {
     #[default]
     Text,
[31m-    /// Image source URL stored in this variant to be used
[m[32m+    /// Image source URL stored in this variant to be used
[m     Image(Option<MediaSource>),
 }

Diff in /app/src/shared/text_or_image.rs:223:
 pub enum TextOrImageAction {
     /// The user has clicked the `TextOrImage`, with source URL stored in this variant.
     Clicked(Option<MediaSource>),
[31m-    None
[m[32m+    None,
[m }

Diff in /app/src/shared/timestamp.rs:36:
 /// See the module-level docs for more detail.
 #[derive(Live, LiveHook, Widget)]
 pub struct Timestamp {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
[31m-    #[rust] dt: DateTime<Local>,
[m[32m+    #[rust]
[m[32m+    dt: DateTime<Local>,
[m }

 impl Widget for Timestamp {
Diff in /app/src/shared/timestamp.rs:47:

         let area = self.view.area();
         let should_hover_in = match event.hits(cx, area) {
[31m-            Hit::FingerLongPress(_)
[m[31m-            | Hit::FingerHoverIn(..) => true,
[m[32m+            Hit::FingerLongPress(_) | Hit::FingerHoverIn(..) => true,
[m             Hit::FingerUp(fue) if fue.is_over && fue.is_primary_hit() => true,
             Hit::FingerHoverOut(_) => {
                 cx.widget_action(self.widget_uid(), &scope.path, TooltipAction::HoverOut);
Diff in /app/src/shared/timestamp.rs:58:
         };
         if should_hover_in {
             // TODO: use pure_rust_locales crate to format the time based on the chosen Locale.
[31m-            let locale_extended_fmt_en_us= "%a %b %-d, %Y, %r";
[m[32m+            let locale_extended_fmt_en_us = "%a %b %-d, %Y, %r";
[m             cx.widget_action(
                 self.widget_uid(),
                 &scope.path,
Diff in /app/src/shared/timestamp.rs:83:
     pub fn set_date_time(&mut self, cx: &mut Cx, dt: DateTime<Local>) {
         // TODO: use pure_rust_locales crate to format the time based on the chosen Locale.
         let locale_fmt_en_us = "%-I:%M %P";
[31m-        self.label(ids!(ts_label)).set_text(
[m[31m-            cx,
[m[31m-            &dt.format(locale_fmt_en_us).to_string()
[m[31m-        );
[m[32m+        self.label(ids!(ts_label))
[m[32m+            .set_text(cx, &dt.format(locale_fmt_en_us).to_string());
[m         self.dt = dt;
     }
 }
Diff in /app/src/shared/unread_badge.rs:23:
             draw_bg: {
                 instance badge_color: (COLOR_UNREAD_BADGE_MESSAGES),
                 instance border_radius: 4.0
[31m-                // Adjust this border_size to larger value to make oval smaller
[m[32m+                // Adjust this border_size to larger value to make oval smaller
[m                 instance border_size: 2.0
                 fn pixel(self) -> vec4 {
                     let sdf = Sdf2d::viewport(self.pos * self.rect_size)
Diff in /app/src/shared/unread_badge.rs:54:
     }
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct UnreadBadge {
[31m-    #[deref] view: View,
[m[31m-    #[live] is_marked_unread: bool,
[m[31m-    #[live] unread_mentions: u64,
[m[31m-    #[live] unread_messages: u64,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[live]
[m[32m+    is_marked_unread: bool,
[m[32m+    #[live]
[m[32m+    unread_mentions: u64,
[m[32m+    #[live]
[m[32m+    unread_messages: u64,
[m }

 impl Widget for UnreadBadge {
Diff in /app/src/shared/unread_badge.rs:69:
     }

     fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
[31m-
[m         /// Helper function to format the badge's rounded rectangle.
         ///
         /// The rounded rectangle needs to be wider for longer text.
Diff in /app/src/shared/unread_badge.rs:76:
[31m-        /// It also adds a plus sign at the end if the unread count is greater than 99.
[m[32m+        /// It also adds a plus sign at the end if the unread count is greater than 99.
[m         fn format_border_and_truncation(count: u64) -> (f64, &'static str) {
             let (border_size, plus_sign) = if count > 99 {
                 (0.0, "+")
Diff in /app/src/shared/unread_badge.rs:88:
         // If there are unread mentions, show red badge and the number of unread mentions
         if self.unread_mentions > 0 {
             let (border_size, plus_sign) = format_border_and_truncation(self.unread_mentions);
[31m-            self.label(ids!(label_count))
[m[31m-                .set_text(cx, &format!("{}{plus_sign}", std::cmp::min(self.unread_mentions, 99)));
[m[31m-            self.view(ids!(rounded_view)).apply_over(cx, live!{
[m[31m-                draw_bg: {
[m[31m-                    border_size: (border_size),
[m[31m-                    badge_color: (COLOR_UNREAD_BADGE_MENTIONS)
[m[31m-                }
[m[31m-            });
[m[32m+            self.label(ids!(label_count)).set_text(
[m[32m+                cx,
[m[32m+                &format!("{}{plus_sign}", std::cmp::min(self.unread_mentions, 99)),
[m[32m+            );
[m[32m+            self.view(ids!(rounded_view)).apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    draw_bg: {
[m[32m+                        border_size: (border_size),
[m[32m+                        badge_color: (COLOR_UNREAD_BADGE_MENTIONS)
[m[32m+                    }
[m[32m+                },
[m[32m+            );
[m             self.visible = true;
         }
         // If there are no unread mentions but this is marked as unread, show the badge as a dot.
Diff in /app/src/shared/unread_badge.rs:102:
         else if self.is_marked_unread {
             self.label(ids!(label_count)).set_text(cx, "");
[31m-            self.view(ids!(rounded_view)).apply_over(cx, live!{
[m[31m-                draw_bg: {
[m[31m-                    border_size: 6.0, // larger value = smaller dot
[m[31m-                    badge_color: (COLOR_UNREAD_BADGE_MARKED)
[m[31m-                }
[m[31m-            });
[m[32m+            self.view(ids!(rounded_view)).apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    draw_bg: {
[m[32m+                        border_size: 6.0, // larger value = smaller dot
[m[32m+                        badge_color: (COLOR_UNREAD_BADGE_MARKED)
[m[32m+                    }
[m[32m+                },
[m[32m+            );
[m             self.visible = true;
         }
         // If there are no unread mentions but there are unread messages, show gray badge and the number of unread messages
Diff in /app/src/shared/unread_badge.rs:113:
         else if self.unread_messages > 0 {
             let (border_size, plus_sign) = format_border_and_truncation(self.unread_messages);
[31m-            self.label(ids!(label_count))
[m[31m-                .set_text(cx, &format!("{}{plus_sign}", std::cmp::min(self.unread_messages, 99)));
[m[31m-            self.view(ids!(rounded_view)).apply_over(cx, live!{
[m[31m-                draw_bg: {
[m[31m-                    border_size: (border_size),
[m[31m-                    badge_color: (COLOR_UNREAD_BADGE_MESSAGES)
[m[31m-                }
[m[31m-            });
[m[32m+            self.label(ids!(label_count)).set_text(
[m[32m+                cx,
[m[32m+                &format!("{}{plus_sign}", std::cmp::min(self.unread_messages, 99)),
[m[32m+            );
[m[32m+            self.view(ids!(rounded_view)).apply_over(
[m[32m+                cx,
[m[32m+                live! {
[m[32m+                    draw_bg: {
[m[32m+                        border_size: (border_size),
[m[32m+                        badge_color: (COLOR_UNREAD_BADGE_MESSAGES)
[m[32m+                    }
[m[32m+                },
[m[32m+            );
[m             self.visible = true;
[31m-        }
[m[31m-        else {
[m[32m+        } else {
[m             // If there are no unreads of any kind, hide the badge
             self.visible = false;
         }
Diff in /app/src/shared/unread_badge.rs:133:

 impl UnreadBadgeRef {
     /// Sets the unread mentions and messages counts without explicitly redrawing the badge.
[31m-    pub fn update_counts(&self, is_marked_unread: bool, num_unread_mentions: u64, num_unread_messages: u64) {
[m[32m+    pub fn update_counts(
[m[32m+        &self,
[m[32m+        is_marked_unread: bool,
[m[32m+        num_unread_mentions: u64,
[m[32m+        num_unread_messages: u64,
[m[32m+    ) {
[m         if let Some(mut inner) = self.borrow_mut() {
             inner.is_marked_unread = is_marked_unread;
             inner.unread_mentions = num_unread_mentions;
Diff in /app/src/shared/verification_badge.rs:7:
     verification::VerificationStateAction,
 };

[31m-
[m // First, define the verification icons component layout
 live_design! {
     use link::theme::*;
Diff in /app/src/shared/verification_badge.rs:145:
                 please verify Robrix from another client.",
                 Some(COLOR_FG_DANGER_RED),
             ),
[31m-            _ => (
[m[31m-                "Verification state is unknown.",
[m[31m-                None,
[m[31m-            ),
[m[32m+            _ => ("Verification state is unknown.", None),
[m         }
     }
 }
Diff in /app/src/sliding_sync.rs:8:
 use makepad_widgets::{error, log, warning, Cx, SignalToUI};
 use matrix_sdk_base::crypto::{DecryptionSettings, TrustRequirement};
 use matrix_sdk::{
[31m-    config::RequestConfig, encryption::EncryptionSettings, event_handler::EventHandlerDropGuard, media::MediaRequestParameters, room::{edit::EditedContent, reply::Reply, RoomMember}, ruma::{
[m[31m-        api::client::{profile::{AvatarUrl, DisplayName}, receipt::create_receipt::v3::ReceiptType}, events::{
[m[31m-            room::{
[m[31m-                message::RoomMessageEventContent, power_levels::RoomPowerLevels, MediaSource
[m[31m-            }, MessageLikeEventType, StateEventType
[m[31m-        }, matrix_uri::MatrixId, MatrixToUri, MatrixUri, MilliSecondsSinceUnixEpoch, OwnedEventId, OwnedMxcUri, OwnedRoomAliasId, OwnedRoomId, OwnedUserId, RoomOrAliasId, UserId
[m[31m-    }, sliding_sync::VersionBuilder, Client, ClientBuildError, Error, OwnedServerName, Room, RoomDisplayName, RoomMemberships, RoomState, SuccessorRoom
[m[32m+    config::RequestConfig,
[m[32m+    encryption::EncryptionSettings,
[m[32m+    event_handler::EventHandlerDropGuard,
[m[32m+    media::MediaRequestParameters,
[m[32m+    room::{edit::EditedContent, reply::Reply, RoomMember},
[m[32m+    ruma::{
[m[32m+        api::client::{
[m[32m+            profile::{AvatarUrl, DisplayName},
[m[32m+            receipt::create_receipt::v3::ReceiptType,
[m[32m+        },
[m[32m+        events::{
[m[32m+            room::{message::RoomMessageEventContent, power_levels::RoomPowerLevels, MediaSource},
[m[32m+            MessageLikeEventType, StateEventType,
[m[32m+        },
[m[32m+        matrix_uri::MatrixId,
[m[32m+        MatrixToUri, MatrixUri, MilliSecondsSinceUnixEpoch, OwnedEventId, OwnedMxcUri,
[m[32m+        OwnedRoomAliasId, OwnedRoomId, OwnedUserId, RoomOrAliasId, UserId,
[m[32m+    },
[m[32m+    sliding_sync::VersionBuilder,
[m[32m+    Client, ClientBuildError, Error, OwnedServerName, Room, RoomDisplayName, RoomMemberships,
[m[32m+    RoomState, SuccessorRoom,
[m };
 use matrix_sdk_ui::{
[31m-    RoomListService, Timeline, room_list_service::{RoomListItem, RoomListLoadingState, SyncIndicator, filters}, sync_service::{self, SyncService}, timeline::{LatestEventValue, RoomExt, TimelineEventItemId, TimelineItem, TimelineReadReceiptTracking, TimelineDetails}
[m[32m+    RoomListService, Timeline,
[m[32m+    room_list_service::{RoomListItem, RoomListLoadingState, SyncIndicator, filters},
[m[32m+    sync_service::{self, SyncService},
[m[32m+    timeline::{
[m[32m+        LatestEventValue, RoomExt, TimelineEventItemId, TimelineItem, TimelineReadReceiptTracking,
[m[32m+        TimelineDetails,
[m[32m+    },
[m };
 use robius_open::Uri;
 use ruma::{OwnedRoomOrAliasId, events::tag::Tags};
Diff in /app/src/sliding_sync.rs:24:
 use tokio::{
     runtime::Handle,
[31m-    sync::{mpsc::{Sender, UnboundedReceiver, UnboundedSender}, watch, Notify}, task::JoinHandle, time::error::Elapsed,
[m[32m+    sync::{
[m[32m+        mpsc::{Sender, UnboundedReceiver, UnboundedSender},
[m[32m+        watch, Notify,
[m[32m+    },
[m[32m+    task::JoinHandle,
[m[32m+    time::error::Elapsed,
[m };
 use url::Url;
[31m-use std::{cmp::{max, min}, future::Future, hash::{BuildHasherDefault, DefaultHasher}, iter::Peekable, ops::{Deref, Not}, path:: Path, sync::{Arc, LazyLock, Mutex}, time::Duration};
[m[32m+use std::{
[m[32m+    cmp::{max, min},
[m[32m+    future::Future,
[m[32m+    hash::{BuildHasherDefault, DefaultHasher},
[m[32m+    iter::Peekable,
[m[32m+    ops::{Deref, Not},
[m[32m+    path::Path,
[m[32m+    sync::{Arc, LazyLock, Mutex},
[m[32m+    time::Duration,
[m[32m+};
[m use std::io;
 use hashbrown::{HashMap, HashSet};
 use crate::{
Diff in /app/src/sliding_sync.rs:33:
[31m-    app::AppStateAction, app_data_dir, avatar_cache::AvatarUpdate, event_preview::text_preview_of_timeline_item, home::{
[m[31m-        add_room::KnockResultAction, invite_screen::{JoinRoomResultAction, LeaveRoomResultAction}, link_preview::{LinkPreviewData, LinkPreviewDataNonNumeric, LinkPreviewRateLimitResponse}, room_screen::{InviteResultAction, TimelineUpdate}, rooms_list::{self, InvitedRoomInfo, InviterInfo, JoinedRoomInfo, RoomsListUpdate, enqueue_rooms_list_update}, rooms_list_header::RoomsListHeaderAction, tombstone_footer::SuccessorRoomDetails
[m[31m-    }, login::login_screen::LoginAction, logout::{logout_confirm_modal::LogoutAction, logout_state_machine::{LogoutConfig, is_logout_in_progress, logout_with_state_machine}}, media_cache::{MediaCacheEntry, MediaCacheEntryRef}, persistence::{self, ClientSessionPersisted, load_app_state}, profile::{
[m[32m+    app::AppStateAction,
[m[32m+    app_data_dir,
[m[32m+    avatar_cache::AvatarUpdate,
[m[32m+    event_preview::text_preview_of_timeline_item,
[m[32m+    home::{
[m[32m+        add_room::KnockResultAction,
[m[32m+        invite_screen::{JoinRoomResultAction, LeaveRoomResultAction},
[m[32m+        link_preview::{LinkPreviewData, LinkPreviewDataNonNumeric, LinkPreviewRateLimitResponse},
[m[32m+        room_screen::{InviteResultAction, TimelineUpdate},
[m[32m+        rooms_list::{
[m[32m+            self, InvitedRoomInfo, InviterInfo, JoinedRoomInfo, RoomsListUpdate,
[m[32m+            enqueue_rooms_list_update,
[m[32m+        },
[m[32m+        rooms_list_header::RoomsListHeaderAction,
[m[32m+        tombstone_footer::SuccessorRoomDetails,
[m[32m+    },
[m[32m+    login::login_screen::LoginAction,
[m[32m+    logout::{
[m[32m+        logout_confirm_modal::LogoutAction,
[m[32m+        logout_state_machine::{LogoutConfig, is_logout_in_progress, logout_with_state_machine},
[m[32m+    },
[m[32m+    media_cache::{MediaCacheEntry, MediaCacheEntryRef},
[m[32m+    persistence::{self, ClientSessionPersisted, load_app_state},
[m[32m+    profile::{
[m         user_profile::UserProfile,
         user_profile_cache::{UserProfileUpdate, enqueue_user_profile_update},
[31m-    }, room::{FetchedRoomAvatar, FetchedRoomPreview, RoomPreviewAction}, shared::{
[m[31m-        avatar::AvatarState, html_or_plaintext::MatrixLinkPillState, jump_to_bottom_button::UnreadMessageCount, popup_list::{PopupKind, enqueue_popup_notification}
[m[31m-    }, space_service_sync::space_service_loop, utils::{self, AVATAR_THUMBNAIL_FORMAT, RoomNameId, avatar_from_room_name, VecDiff}, verification::add_verification_event_handlers_and_sync_client
[m[32m+    },
[m[32m+    room::{FetchedRoomAvatar, FetchedRoomPreview, RoomPreviewAction},
[m[32m+    shared::{
[m[32m+        avatar::AvatarState,
[m[32m+        html_or_plaintext::MatrixLinkPillState,
[m[32m+        jump_to_bottom_button::UnreadMessageCount,
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    },
[m[32m+    space_service_sync::space_service_loop,
[m[32m+    utils::{self, AVATAR_THUMBNAIL_FORMAT, RoomNameId, avatar_from_room_name, VecDiff},
[m[32m+    verification::add_verification_event_handlers_and_sync_client,
[m };

 #[derive(Parser, Debug, Default)]
Diff in /app/src/sliding_sync.rs:79:
     }
 }

[31m-
[m /// Build a new client.
 async fn build_client(
     cli: &Cli,
Diff in /app/src/sliding_sync.rs:101:
             .collect()
     };

[31m-    let homeserver_url = cli.homeserver.as_deref()
[m[32m+    let homeserver_url = cli
[m[32m+        .homeserver
[m[32m+        .as_deref()
[m         .unwrap_or("https://matrix-client.matrix.org/");
[31m-        // .unwrap_or("https://matrix.org/");
[m[32m+    // .unwrap_or("https://matrix.org/");
[m
     let mut builder = Client::builder()
         .server_name_or_homeserver_url(homeserver_url)
Diff in /app/src/sliding_sync.rs:128:

     // Use a 60 second timeout for all requests to the homeserver.
     // Yes, this is a long timeout, but the standard matrix homeserver is often very slow.
[31m-    builder = builder.request_config(
[m[31m-        RequestConfig::new()
[m[31m-            .timeout(std::time::Duration::from_secs(60))
[m[31m-    );
[m[32m+    builder =
[m[32m+        builder.request_config(RequestConfig::new().timeout(std::time::Duration::from_secs(60)));
[m
     let client = builder.build().await?;
[31m-    let homeserver_url =  client.homeserver().to_string();
[m[32m+    let homeserver_url = client.homeserver().to_string();
[m     Ok((
         client,
         ClientSessionPersisted {
Diff in /app/src/sliding_sync.rs:150:
 /// This function is used by the login screen to log in to the Matrix server.
 ///
 /// Upon success, this function returns the logged-in client and an optional sync token.
[31m-async fn login(
[m[31m-    cli: &Cli,
[m[31m-    login_request: LoginRequest,
[m[31m-) -> Result<(Client, Option<String>)> {
[m[32m+async fn login(cli: &Cli, login_request: LoginRequest) -> Result<(Client, Option<String>)> {
[m     match login_request {
         LoginRequest::LoginByCli | LoginRequest::LoginByPassword(_) => {
             let cli = if let LoginRequest::LoginByPassword(login_by_password) = login_request {
Diff in /app/src/sliding_sync.rs:183:
             } else {
                 let err_msg = format!("Failed to login as {}: {:?}", cli.user_id, login_result);
                 enqueue_popup_notification(err_msg.clone(), PopupKind::Error, None);
[31m-                enqueue_rooms_list_update(RoomsListUpdate::Status { status: err_msg.clone() });
[m[32m+                enqueue_rooms_list_update(RoomsListUpdate::Status {
[m[32m+                    status: err_msg.clone(),
[m[32m+                });
[m                 bail!(err_msg);
             }
         }
Diff in /app/src/sliding_sync.rs:200:
     }
 }

[31m-
[m /// Which direction to paginate in.
 ///
 /// * `Forwards` will retrieve later events (towards the end of the timeline),
Diff in /app/src/sliding_sync.rs:269:
     Option<crossbeam_channel::Sender<TimelineUpdate>>,
 );

[31m-
[m /// Actions emitted in response to a [`MatrixRequest::GenerateMatrixLink`].
 #[derive(Clone, Debug)]
 pub enum MatrixLinkAction {
Diff in /app/src/sliding_sync.rs:300:
         room_name_id: RoomNameId,
     },
     /// A direct message room didn't exist, and we didn't attempt to create a new one.
[31m-    DidNotExist {
[m[31m-        user_profile: UserProfile,
[m[31m-    },
[m[32m+    DidNotExist { user_profile: UserProfile },
[m     /// A direct message room didn't exist, but we successfully created a new one.
     NewlyCreated {
         user_profile: UserProfile,
Diff in /app/src/sliding_sync.rs:321:
     /// Request from the login screen to log in with the given credentials.
     Login(LoginRequest),
     /// Request to logout.
[31m-    Logout{
[m[31m-        is_desktop: bool,
[m[31m-    },
[m[32m+    Logout { is_desktop: bool },
[m     /// Request to paginate the older (or newer) events of a room's timeline.
     PaginateRoomTimeline {
         room_id: OwnedRoomId,
Diff in /app/src/sliding_sync.rs:344:
     },
     /// Request to fetch profile information for all members of a room.
     /// This can be *very* slow depending on the number of members in the room.
[31m-    SyncRoomMemberList {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    SyncRoomMemberList { room_id: OwnedRoomId },
[m     /// Request to knock on (request an invite to) the given room.
     Knock {
         room_or_alias_id: OwnedRoomOrAliasId,
Diff in /app/src/sliding_sync.rs:360:
         user_id: OwnedUserId,
     },
     /// Request to join the given room.
[31m-    JoinRoom {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    JoinRoom { room_id: OwnedRoomId },
[m     /// Request to leave the given room.
[31m-    LeaveRoom {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    LeaveRoom { room_id: OwnedRoomId },
[m     /// Request to get the actual list of members in a room.
     /// This returns the list of members that can be displayed in the UI.
     GetRoomMembers {
Diff in /app/src/sliding_sync.rs:385:
         via: Vec<OwnedServerName>,
     },
     /// Request to fetch the full details (the room preview) of a tombstoned room.
[31m-    GetSuccessorRoomDetails {
[m[31m-        tombstoned_room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetSuccessorRoomDetails { tombstoned_room_id: OwnedRoomId },
[m     /// Request to create or open a direct message room with the given user.
     ///
     /// If there is no existing DM room with the given user, this will create a new DM room
Diff in /app/src/sliding_sync.rs:412:
         local_only: bool,
     },
     /// Request to fetch the number of unread messages in the given room.
[31m-    GetNumberUnreadMessages {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetNumberUnreadMessages { room_id: OwnedRoomId },
[m     /// Request to set the unread flag for the given room.
     SetUnreadFlag {
         room_id: OwnedRoomId,
Diff in /app/src/sliding_sync.rs:499:
     /// This request does not return a response or notify the UI thread, and
     /// furthermore, there is no need to send a follow-up request to stop typing
     /// (though you certainly can do so).
[31m-    SendTypingNotice {
[m[31m-        room_id: OwnedRoomId,
[m[31m-        typing: bool,
[m[31m-    },
[m[32m+    SendTypingNotice { room_id: OwnedRoomId, typing: bool },
[m     /// Spawn an async task to login to the given Matrix homeserver using the given SSO identity provider ID.
     ///
     /// While an SSO request is in flight, the login screen will temporarily prevent the user
Diff in /app/src/sliding_sync.rs:509:
     /// from submitting another redundant request, until this request has succeeded or failed.
[31m-    SpawnSSOServer{
[m[32m+    SpawnSSOServer {
[m         brand: String,
         homeserver_url: String,
         identity_provider_id: String,
Diff in /app/src/sliding_sync.rs:547:
     /// Sends a request to obtain the power levels for this room.
     ///
     /// The response is delivered back to the main UI thread via [`TimelineUpdate::UserPowerLevels`].
[31m-    GetRoomPowerLevels {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetRoomPowerLevels { room_id: OwnedRoomId },
[m     /// Toggles the given reaction to the given event in the given room.
     ToggleReaction {
         room_id: OwnedRoomId,
Diff in /app/src/sliding_sync.rs:575:
     /// The MatrixLinkPillInfo::Loaded variant is sent back to the main UI thread via.
     GetMatrixRoomLinkPillInfo {
         matrix_id: MatrixId,
[31m-        via: Vec<OwnedServerName>
[m[32m+        via: Vec<OwnedServerName>,
[m     },
     /// Request to fetch URL preview from the Matrix homeserver.
     GetUrlPreview {
Diff in /app/src/sliding_sync.rs:589:
 /// Submits a request to the worker thread to be executed asynchronously.
 pub fn submit_async_request(req: MatrixRequest) {
     if let Some(sender) = REQUEST_SENDER.lock().unwrap().as_ref() {
[31m-        sender.send(req)
[m[32m+        sender
[m[32m+            .send(req)
[m             .expect("BUG: matrix worker task receiver has died!");
     }
 }
Diff in /app/src/sliding_sync.rs:596:

 /// Details of a login request that get submitted within [`MatrixRequest::Login`].
[31m-pub enum LoginRequest{
[m[32m+pub enum LoginRequest {
[m     LoginByPassword(LoginByPassword),
     LoginBySSOSuccess(Client, ClientSessionPersisted),
     LoginByCli,
Diff in /app/src/sliding_sync.rs:602:
     HomeserverLoginTypesQuery(String),
[31m-
[m }
 /// Information needed to log in to a Matrix homeserver.
 pub struct LoginByPassword {
Diff in /app/src/sliding_sync.rs:609:
     pub homeserver: Option<String>,
 }

[31m-
[m /// The entry point for the worker task that runs Matrix-related operations.
 ///
 /// All this task does is wait for [`MatrixRequests`] from the main UI thread
Diff in /app/src/sliding_sync.rs:619:
     login_sender: Sender<LoginRequest>,
 ) -> Result<()> {
     log!("Started matrix_worker_task.");
[31m-    let mut subscribers_own_user_read_receipts: HashMap<OwnedRoomId, JoinHandle<()>> = HashMap::new();
[m[32m+    let mut subscribers_own_user_read_receipts: HashMap<OwnedRoomId, JoinHandle<()>> =
[m[32m+        HashMap::new();
[m     let mut subscribers_pinned_events: HashMap<OwnedRoomId, JoinHandle<()>> = HashMap::new();

     while let Some(request) = request_receiver.recv().await {
Diff in /app/src/sliding_sync.rs:628:
                 if let Err(e) = login_sender.send(login_request).await {
                     error!("Error sending login request to login_sender: {e:?}");
                     Cx::post_action(LoginAction::LoginFailure(String::from(
[31m-                        "BUG: failed to send login request to login worker task."
[m[32m+                        "BUG: failed to send login request to login worker task.",
[m                     )));
                 }
             }
Diff in /app/src/sliding_sync.rs:641:
                     match logout_with_state_machine(is_desktop).await {
                         Ok(()) => {
                             log!("Logout completed successfully via state machine");
[31m-                        },
[m[32m+                        }
[m                         Err(e) => {
                             error!("Logout failed: {e:?}");
                         }
Diff in /app/src/sliding_sync.rs:649:
                 });
             }

[31m-            MatrixRequest::PaginateRoomTimeline { room_id, num_events, direction } => {
[m[32m+            MatrixRequest::PaginateRoomTimeline {
[m[32m+                room_id,
[m[32m+                num_events,
[m[32m+                direction,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:698:
                 });
             }

[31m-            MatrixRequest::EditMessage { room_id, timeline_event_item_id: timeline_event_id, edited_content } => {
[m[32m+            MatrixRequest::EditMessage {
[m[32m+                room_id,
[m[32m+                timeline_event_item_id: timeline_event_id,
[m[32m+                edited_content,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:705:
                         error!("BUG: room info not found for edit request, room {room_id}");
                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 // Spawn a new async task that will make the actual edit request.
Diff in /app/src/sliding_sync.rs:712:
                 let _edit_task = Handle::current().spawn(async move {
[31m-                    log!("Sending request to edit message {timeline_event_id:?} in room {room_id}...");
[m[32m+                    log!(
[m[32m+                        "Sending request to edit message {timeline_event_id:?} in room {room_id}..."
[m[32m+                    );
[m                     let result = timeline.edit(&timeline_event_id, edited_content).await;
                     match result {
[31m-                        Ok(_) => log!("Successfully edited message {timeline_event_id:?} in room {room_id}."),
[m[31m-                        Err(ref e) => error!("Error editing message {timeline_event_id:?} in room {room_id}: {e:?}"),
[m[32m+                        Ok(_) => log!(
[m[32m+                            "Successfully edited message {timeline_event_id:?} in room {room_id}."
[m[32m+                        ),
[m[32m+                        Err(ref e) => error!(
[m[32m+                            "Error editing message {timeline_event_id:?} in room {room_id}: {e:?}"
[m[32m+                        ),
[m                     }
[31m-                    sender.send(TimelineUpdate::MessageEdited {
[m[31m-                        timeline_event_id,
[m[31m-                        result,
[m[31m-                    }).unwrap();
[m[32m+                    sender
[m[32m+                        .send(TimelineUpdate::MessageEdited {
[m[32m+                            timeline_event_id,
[m[32m+                            result,
[m[32m+                        })
[m[32m+                        .unwrap();
[m                     SignalToUI::set_ui_signal();
                 });
             }
Diff in /app/src/sliding_sync.rs:728:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        error!("BUG: room info not found for fetch details for event request {room_id}");
[m[32m+                        error!(
[m[32m+                            "BUG: room info not found for fetch details for event request {room_id}"
[m[32m+                        );
[m                         continue;
                     };

Diff in /app/src/sliding_sync.rs:735:
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 // Spawn a new async task that will make the actual fetch request.
Diff in /app/src/sliding_sync.rs:747:
                             // error!("Error fetching details for event {event_id} in room {room_id}: {_e:?}");
                         }
                     }
[31m-                    sender.send(TimelineUpdate::EventDetailsFetched {
[m[31m-                        event_id,
[m[31m-                        result,
[m[31m-                    }).unwrap();
[m[32m+                    sender
[m[32m+                        .send(TimelineUpdate::EventDetailsFetched { event_id, result })
[m[32m+                        .unwrap();
[m                     SignalToUI::set_ui_signal();
                 });
             }
Diff in /app/src/sliding_sync.rs:763:
                         continue;
                     };

[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 // Spawn a new async task that will make the actual fetch request.
Diff in /app/src/sliding_sync.rs:776:
                 });
             }

[31m-            MatrixRequest::Knock { room_or_alias_id, reason, server_names } => {
[m[32m+            MatrixRequest::Knock {
[m[32m+                room_or_alias_id,
[m[32m+                reason,
[m[32m+                server_names,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _knock_room_task = Handle::current().spawn(async move {
                     log!("Sending request to knock on room {room_or_alias_id}...");
Diff in /app/src/sliding_sync.rs:783:
[31m-                    match client.knock(room_or_alias_id.clone(), reason, server_names).await {
[m[32m+                    match client
[m[32m+                        .knock(room_or_alias_id.clone(), reason, server_names)
[m[32m+                        .await
[m[32m+                    {
[m                         Ok(room) => {
                             let _ = room.display_name().await; // populate this room's display name cache
                             Cx::post_action(KnockResultAction::Knocked {
Diff in /app/src/sliding_sync.rs:804:
                     if let Some(room) = client.get_room(&room_id) {
                         log!("Sending request to invite user {user_id} to room {room_id}...");
                         match room.invite_user_by_id(&user_id).await {
[31m-                            Ok(_) => Cx::post_action(InviteResultAction::Sent {
[m[31m-                                room_id,
[m[31m-                                user_id,
[m[31m-                            }),
[m[32m+                            Ok(_) => Cx::post_action(InviteResultAction::Sent { room_id, user_id }),
[m                             Err(error) => Cx::post_action(InviteResultAction::Failed {
                                 room_id,
                                 user_id,
Diff in /app/src/sliding_sync.rs:814:
                                 error,
                             }),
                         }
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         error!("Room/Space not found for invite user request {room_id}, {user_id}");
                         Cx::post_action(InviteResultAction::Failed {
                             room_id,
Diff in /app/src/sliding_sync.rs:822:
                             user_id,
[31m-                            error: matrix_sdk::Error::UnknownError("Room/Space not found in client's known list.".into()),
[m[32m+                            error: matrix_sdk::Error::UnknownError(
[m[32m+                                "Room/Space not found in client's known list.".into(),
[m[32m+                            ),
[m                         })
                     }
                 });
Diff in /app/src/sliding_sync.rs:841:
                                 JoinRoomResultAction::Failed { room_id, error: e }
                             }
                         }
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         match client.join_room_by_id(&room_id).await {
                             Ok(_room) => {
                                 log!("Successfully joined new unknown room {room_id}.");
Diff in /app/src/sliding_sync.rs:877:
                         error!("BUG: client could not get room with ID {room_id}");
                         LeaveRoomResultAction::Failed {
                             room_id,
[31m-                            error: matrix_sdk::Error::UnknownError("Client couldn't locate room to leave it.".into()),
[m[32m+                            error: matrix_sdk::Error::UnknownError(
[m[32m+                                "Client couldn't locate room to leave it.".into(),
[m[32m+                            ),
[m                         }
                     };
                     Cx::post_action(result_action);
Diff in /app/src/sliding_sync.rs:884:
                 });
             }

[31m-            MatrixRequest::GetRoomMembers { room_id, memberships, local_only } => {
[m[32m+            MatrixRequest::GetRoomMembers {
[m[32m+                room_id,
[m[32m+                memberships,
[m[32m+                local_only,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:891:
                         log!("BUG: room info not found for get room members request {room_id}");
                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 let _get_members_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:899:

                     let send_update = |members: Vec<matrix_sdk::room::RoomMember>, source: &str| {
                         log!("{} {} members for room {}", source, members.len(), room_id);
[31m-                        sender.send(TimelineUpdate::RoomMembersListFetched {
[m[31m-                            members
[m[31m-                        }).unwrap();
[m[32m+                        sender
[m[32m+                            .send(TimelineUpdate::RoomMembersListFetched { members })
[m[32m+                            .unwrap();
[m                         SignalToUI::set_ui_signal();
                     };

Diff in /app/src/sliding_sync.rs:917:
                 });
             }

[31m-            MatrixRequest::GetRoomPreview { room_or_alias_id, via } => {
[m[32m+            MatrixRequest::GetRoomPreview {
[m[32m+                room_or_alias_id,
[m[32m+                via,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _fetch_task = Handle::current().spawn(async move {
                     let res = fetch_room_preview_with_avatar(&client, &room_or_alias_id, via).await;
Diff in /app/src/sliding_sync.rs:930:
                 let (sender, successor_room) = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&tombstoned_room_id) else {
[31m-                        error!("BUG: tombstoned room {tombstoned_room_id} info not found for get successor room details request");
[m[32m+                        error!(
[m[32m+                            "BUG: tombstoned room {tombstoned_room_id} info not found for get successor room details request"
[m[32m+                        );
[m                         continue;
                     };
[31m-                    (room_info.timeline_update_sender.clone(), room_info.timeline.room().successor_room())
[m[32m+                    (
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                        room_info.timeline.room().successor_room(),
[m[32m+                    )
[m                 };
                 spawn_fetch_successor_room_preview(
                     client,
Diff in /app/src/sliding_sync.rs:943:
                 );
             }

[31m-            MatrixRequest::OpenOrCreateDirectMessage { user_profile, allow_create } => {
[m[32m+            MatrixRequest::OpenOrCreateDirectMessage {
[m[32m+                user_profile,
[m[32m+                allow_create,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _create_dm_task = Handle::current().spawn(async move {
                     if let Some(room) = client.get_dm_room(&user_profile.user_id) {
Diff in /app/src/sliding_sync.rs:966:
                                 user_profile,
                                 room_name_id: RoomNameId::from_room(&room).await,
                             });
[31m-                        },
[m[32m+                        }
[m                         Err(error) => {
                             error!("Failed to create DM with {user_profile:?}: {error}");
                             Cx::post_action(DirectMessageRoomAction::FailedToCreate {
Diff in /app/src/sliding_sync.rs:978:
                 });
             }

[31m-            MatrixRequest::GetUserProfile { user_id, room_id, local_only } => {
[m[32m+            MatrixRequest::GetUserProfile {
[m[32m+                user_id,
[m[32m+                room_id,
[m[32m+                local_only,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _fetch_task = Handle::current().spawn(async move {
                     // log!("Sending get user profile request: user: {user_id}, \
Diff in /app/src/sliding_sync.rs:1051:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("Skipping get number of unread messages request for not-yet-known room {room_id}");
[m[32m+                        log!(
[m[32m+                            "Skipping get number of unread messages request for not-yet-known room {room_id}"
[m[32m+                        );
[m                         continue;
                     };

Diff in /app/src/sliding_sync.rs:1058:
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };
                 let _get_unreads_task = Handle::current().spawn(async move {
                     match sender.send(TimelineUpdate::NewUnreadMessagesCount(
Diff in /app/src/sliding_sync.rs:1072:
                     });
                 });
             }
[31m-            MatrixRequest::SetUnreadFlag { room_id, mark_as_unread } => {
[m[32m+            MatrixRequest::SetUnreadFlag {
[m[32m+                room_id,
[m[32m+                mark_as_unread,
[m[32m+            } => {
[m                 let timeline = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:1085:
                     let result = timeline.room().set_unread_flag(mark_as_unread).await;
                     match result {
                         Ok(_) => log!("Set unread flag to {} for room {}", mark_as_unread, room_id),
[31m-                        Err(e) => error!("Failed to set unread flag to {} for room {}: {:?}", mark_as_unread, room_id, e),
[m[32m+                        Err(e) => error!(
[m[32m+                            "Failed to set unread flag to {} for room {}: {:?}",
[m[32m+                            mark_as_unread, room_id, e
[m[32m+                        ),
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1092:
[31m-            MatrixRequest::SetIsFavorite { room_id, is_favorite } => {
[m[32m+            MatrixRequest::SetIsFavorite {
[m[32m+                room_id,
[m[32m+                is_favorite,
[m[32m+            } => {
[m                 let timeline = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:1102:
                     let result = timeline.room().set_is_favourite(is_favorite, None).await;
                     match result {
                         Ok(_) => log!("Set favorite to {} for room {}", is_favorite, room_id),
[31m-                        Err(e) => error!("Failed to set favorite to {} for room {}: {:?}", is_favorite, room_id, e),
[m[32m+                        Err(e) => error!(
[m[32m+                            "Failed to set favorite to {} for room {}: {:?}",
[m[32m+                            is_favorite, room_id, e
[m[32m+                        ),
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1109:
[31m-            MatrixRequest::SetIsLowPriority { room_id, is_low_priority } => {
[m[32m+            MatrixRequest::SetIsLowPriority {
[m[32m+                room_id,
[m[32m+                is_low_priority,
[m[32m+            } => {
[m                 let timeline = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:1116:
                     room_info.timeline.clone()
                 };
                 let _set_lp_task = Handle::current().spawn(async move {
[31m-                    let result = timeline.room().set_is_low_priority(is_low_priority, None).await;
[m[32m+                    let result = timeline
[m[32m+                        .room()
[m[32m+                        .set_is_low_priority(is_low_priority, None)
[m[32m+                        .await;
[m                     match result {
[31m-                        Ok(_) => log!("Set low priority to {} for room {}", is_low_priority, room_id),
[m[31m-                        Err(e) => error!("Failed to set low priority to {} for room {}: {:?}", is_low_priority, room_id, e),
[m[32m+                        Ok(_) => log!(
[m[32m+                            "Set low priority to {} for room {}",
[m[32m+                            is_low_priority,
[m[32m+                            room_id
[m[32m+                        ),
[m[32m+                        Err(e) => error!(
[m[32m+                            "Failed to set low priority to {} for room {}: {:?}",
[m[32m+                            is_low_priority, room_id, e
[m[32m+                        ),
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1127:
                 let Some(client) = get_client() else { continue };
                 let _set_avatar_task = Handle::current().spawn(async move {
                     let is_removing = avatar_url.is_none();
[31m-                    log!("Sending request to {} avatar...", if is_removing { "remove" } else { "set" });
[m[32m+                    log!(
[m[32m+                        "Sending request to {} avatar...",
[m[32m+                        if is_removing { "remove" } else { "set" }
[m[32m+                    );
[m                     let result = client.account().set_avatar_url(avatar_url.as_deref()).await;
                     match result {
                         Ok(_) => {
Diff in /app/src/sliding_sync.rs:1134:
[31m-                            log!("Successfully {} avatar.", if is_removing { "removed" } else { "set" });
[m[32m+                            log!(
[m[32m+                                "Successfully {} avatar.",
[m[32m+                                if is_removing { "removed" } else { "set" }
[m[32m+                            );
[m                             Cx::post_action(AccountDataAction::AvatarChanged(avatar_url));
                         }
                         Err(e) => {
Diff in /app/src/sliding_sync.rs:1138:
[31m-                            let err_msg = format!("Failed to {} avatar: {e}", if is_removing { "remove" } else { "set" });
[m[32m+                            let err_msg = format!(
[m[32m+                                "Failed to {} avatar: {e}",
[m[32m+                                if is_removing { "remove" } else { "set" }
[m[32m+                            );
[m                             Cx::post_action(AccountDataAction::AvatarChangeFailed(err_msg));
                         }
                     }
Diff in /app/src/sliding_sync.rs:1145:
                 let Some(client) = get_client() else { continue };
                 let _set_display_name_task = Handle::current().spawn(async move {
                     let is_removing = new_display_name.is_none();
[31m-                    log!("Sending request to {} display name{}...",
[m[32m+                    log!(
[m[32m+                        "Sending request to {} display name{}...",
[m                         if is_removing { "remove" } else { "set" },
[31m-                        new_display_name.as_ref().map(|n| format!(" to '{n}'")).unwrap_or_default()
[m[32m+                        new_display_name
[m[32m+                            .as_ref()
[m[32m+                            .map(|n| format!(" to '{n}'"))
[m[32m+                            .unwrap_or_default()
[m                     );
[31m-                    let result = client.account().set_display_name(new_display_name.as_deref()).await;
[m[32m+                    let result = client
[m[32m+                        .account()
[m[32m+                        .set_display_name(new_display_name.as_deref())
[m[32m+                        .await;
[m                     match result {
                         Ok(_) => {
[31m-                            log!("Successfully {} display name.", if is_removing { "removed" } else { "set" });
[m[31m-                            Cx::post_action(AccountDataAction::DisplayNameChanged(new_display_name));
[m[32m+                            log!(
[m[32m+                                "Successfully {} display name.",
[m[32m+                                if is_removing { "removed" } else { "set" }
[m[32m+                            );
[m[32m+                            Cx::post_action(AccountDataAction::DisplayNameChanged(
[m[32m+                                new_display_name,
[m[32m+                            ));
[m                         }
                         Err(e) => {
[31m-                            let err_msg = format!("Failed to {} display name: {e}", if is_removing { "remove" } else { "set" });
[m[32m+                            let err_msg = format!(
[m[32m+                                "Failed to {} display name: {e}",
[m[32m+                                if is_removing { "remove" } else { "set" }
[m[32m+                            );
[m                             Cx::post_action(AccountDataAction::DisplayNameChangeFailed(err_msg));
                         }
                     }
Diff in /app/src/sliding_sync.rs:1163:
                 });
             }
[31m-            MatrixRequest::GenerateMatrixLink { room_id, event_id, use_matrix_scheme, join_on_click } => {
[m[32m+            MatrixRequest::GenerateMatrixLink {
[m[32m+                room_id,
[m[32m+                event_id,
[m[32m+                use_matrix_scheme,
[m[32m+                join_on_click,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _gen_link_task = Handle::current().spawn(async move {
                     if let Some(room) = client.get_room(&room_id) {
Diff in /app/src/sliding_sync.rs:1169:
                         let result = if use_matrix_scheme {
                             if let Some(event_id) = event_id {
[31m-                                room.matrix_event_permalink(event_id).await
[m[32m+                                room.matrix_event_permalink(event_id)
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixUri)
                             } else {
[31m-                                room.matrix_permalink(join_on_click).await
[m[32m+                                room.matrix_permalink(join_on_click)
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixUri)
                             }
                         } else {
Diff in /app/src/sliding_sync.rs:1178:
                             if let Some(event_id) = event_id {
[31m-                                room.matrix_to_event_permalink(event_id).await
[m[32m+                                room.matrix_to_event_permalink(event_id)
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixToUri)
                             } else {
[31m-                                room.matrix_to_permalink().await
[m[32m+                                room.matrix_to_permalink()
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixToUri)
                             }
                         };
Diff in /app/src/sliding_sync.rs:1186:
[31m-
[m[32m+
[m                         match result {
                             Ok(action) => Cx::post_action(action),
                             Err(e) => Cx::post_action(MatrixLinkAction::Error(e.to_string())),
Diff in /app/src/sliding_sync.rs:1190:
                         }
                     } else {
[31m-                         Cx::post_action(MatrixLinkAction::Error(format!("Room {room_id} not found")));
[m[32m+                        Cx::post_action(MatrixLinkAction::Error(format!(
[m[32m+                            "Room {room_id} not found"
[m[32m+                        )));
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1196:
[31m-            MatrixRequest::IgnoreUser { ignore, room_member, room_id } => {
[m[32m+            MatrixRequest::IgnoreUser {
[m[32m+                ignore,
[m[32m+                room_member,
[m[32m+                room_id,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _ignore_task = Handle::current().spawn(async move {
                     let user_id = room_member.user_id();
Diff in /app/src/sliding_sync.rs:1262:
                 let (room, timeline_update_sender, mut typing_notice_receiver) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("BUG: room info not found for subscribe to typing notices request, room {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for subscribe to typing notices request, room {room_id}"
[m[32m+                        );
[m                         continue;
                     };
                     let (room, recv) = if subscribe {
Diff in /app/src/sliding_sync.rs:1269:
                         if room_info.typing_notice_subscriber.is_some() {
[31m-                            warning!("Note: room {room_id} is already subscribed to typing notices.");
[m[32m+                            warning!(
[m[32m+                                "Note: room {room_id} is already subscribed to typing notices."
[m[32m+                            );
[m                             continue;
                         } else {
                             let Some(room) = get_client().and_then(|c| c.get_room(&room_id)) else {
Diff in /app/src/sliding_sync.rs:1274:
[31m-                                error!("BUG: client/room not found when subscribing to typing notices request, room: {room_id}");
[m[32m+                                error!(
[m[32m+                                    "BUG: client/room not found when subscribing to typing notices request, room: {room_id}"
[m[32m+                                );
[m                                 continue;
                             };
                             let (drop_guard, recv) = room.subscribe_to_typing_notifications();
Diff in /app/src/sliding_sync.rs:1310:
             }
             MatrixRequest::SubscribeToOwnUserReadReceiptsChanged { room_id, subscribe } => {
                 if !subscribe {
[31m-                    if let Some(task_handler) = subscribers_own_user_read_receipts.remove(&room_id) {
[m[32m+                    if let Some(task_handler) = subscribers_own_user_read_receipts.remove(&room_id)
[m[32m+                    {
[m                         task_handler.abort();
                     }
                     continue;
Diff in /app/src/sliding_sync.rs:1318:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("BUG: room info not found for subscribe to own user read receipts changed request, room {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for subscribe to own user read receipts changed request, room {room_id}"
[m[32m+                        );
[m                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };
                 let room_id_clone = room_id.clone();
                 let subscribe_own_read_receipt_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:1372:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("BUG: room info not found for subscribe to pinned events request, room {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for subscribe to pinned events request, room {room_id}"
[m[32m+                        );
[m                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };
                 let subscribe_pinned_events_task = Handle::current().spawn(async move {
                     // Send an initial update, as the stream may not update immediately.
Diff in /app/src/sliding_sync.rs:1395:
                 });
                 subscribers_pinned_events.insert(room_id, subscribe_pinned_events_task);
             }
[31m-            MatrixRequest::SpawnSSOServer { brand, homeserver_url, identity_provider_id} => {
[m[31m-                spawn_sso_server(brand, homeserver_url, identity_provider_id, login_sender.clone()).await;
[m[32m+            MatrixRequest::SpawnSSOServer {
[m[32m+                brand,
[m[32m+                homeserver_url,
[m[32m+                identity_provider_id,
[m[32m+            } => {
[m[32m+                spawn_sso_server(
[m[32m+                    brand,
[m[32m+                    homeserver_url,
[m[32m+                    identity_provider_id,
[m[32m+                    login_sender.clone(),
[m[32m+                )
[m[32m+                .await;
[m             }
             MatrixRequest::ResolveRoomAlias(room_alias) => {
                 let Some(client) = get_client() else { continue };
Diff in /app/src/sliding_sync.rs:1407:
                     todo!("Send the resolved room alias back to the UI thread somehow.");
                 });
             }
[31m-            MatrixRequest::FetchAvatar { mxc_uri, on_fetched } => {
[m[32m+            MatrixRequest::FetchAvatar {
[m[32m+                mxc_uri,
[m[32m+                on_fetched,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 Handle::current().spawn(async move {
                     // log!("Sending fetch avatar request for {mxc_uri:?}...");
Diff in /app/src/sliding_sync.rs:1417:
                     };
                     let res = client.media().get_media_content(&media_request, true).await;
                     // log!("Fetched avatar for {mxc_uri:?}, succeeded? {}", res.is_ok());
[31m-                    on_fetched(AvatarUpdate { mxc_uri, avatar_data: res.map(|v| v.into()) });
[m[32m+                    on_fetched(AvatarUpdate {
[m[32m+                        mxc_uri,
[m[32m+                        avatar_data: res.map(|v| v.into()),
[m[32m+                    });
[m                 });
             }

Diff in /app/src/sliding_sync.rs:1424:
[31m-            MatrixRequest::FetchMedia { media_request, on_fetched, destination, update_sender } => {
[m[32m+            MatrixRequest::FetchMedia {
[m[32m+                media_request,
[m[32m+                on_fetched,
[m[32m+                destination,
[m[32m+                update_sender,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let media = client.media();

Diff in /app/src/sliding_sync.rs:1520:
                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
[31m-                        log!("BUG: room info not found when sending read receipt, room {room_id}, {event_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found when sending read receipt, room {room_id}, {event_id}"
[m[32m+                        );
[m                         continue;
                     };
                     room_info.timeline.clone()
Diff in /app/src/sliding_sync.rs:1538:
                         unread_mentions: timeline.room().num_unread_mentions()
                     });
                 });
[31m-            },
[m[32m+            }
[m
[31m-            MatrixRequest::FullyReadReceipt { room_id, event_id, .. } => {
[m[32m+            MatrixRequest::FullyReadReceipt {
[m[32m+                room_id, event_id, ..
[m[32m+            } => {
[m                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1547:
[31m-                        log!("BUG: room info not found when sending fully read receipt, room {room_id}, {event_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found when sending fully read receipt, room {room_id}, {event_id}"
[m[32m+                        );
[m                         continue;
                     };
                     room_info.timeline.clone()
Diff in /app/src/sliding_sync.rs:1564:
                         unread_mentions: timeline.room().num_unread_mentions()
                     });
                 });
[31m-            },
[m[32m+            }
[m
             MatrixRequest::GetRoomPowerLevels { room_id } => {
                 let (timeline, sender) = {
Diff in /app/src/sliding_sync.rs:1571:
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
[31m-                        log!("BUG: room info not found for get room power levels request {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for get room power levels request {room_id}"
[m[32m+                        );
[m                         continue;
                     };

Diff in /app/src/sliding_sync.rs:1577:
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

[31m-                let Some(user_id) = current_user_id() else { continue };
[m[32m+                let Some(user_id) = current_user_id() else {
[m[32m+                    continue;
[m[32m+                };
[m
                 let _power_levels_task = Handle::current().spawn(async move {
                     match timeline.room().power_levels().await {
Diff in /app/src/sliding_sync.rs:1595:
                         }
                     }
                 });
[31m-            },
[m[31m-            MatrixRequest::ToggleReaction { room_id, timeline_event_id, reaction } => {
[m[32m+            }
[m[32m+            MatrixRequest::ToggleReaction {
[m[32m+                room_id,
[m[32m+                timeline_event_id,
[m[32m+                reaction,
[m[32m+            } => {
[m                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1616:
                         Err(_e) => error!("Failed to send toggle reaction to room {room_id} {reaction}; error: {_e:?}"),
                     }
                 });
[31m-
[m[31m-            },
[m[31m-            MatrixRequest::RedactMessage { room_id, timeline_event_id, reason } => {
[m[32m+            }
[m[32m+            MatrixRequest::RedactMessage {
[m[32m+                room_id,
[m[32m+                timeline_event_id,
[m[32m+                reason,
[m[32m+            } => {
[m                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1641:
                         }
                     }
                 });
[31m-            },
[m[31m-            MatrixRequest::PinEvent { room_id, event_id, pin } => {
[m[32m+            }
[m[32m+            MatrixRequest::PinEvent {
[m[32m+                room_id,
[m[32m+                event_id,
[m[32m+                pin,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1649:
                         log!("BUG: room info not found for pin message {room_id}");
                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 let _pin_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:1658:
                     } else {
                         timeline.unpin_event(&event_id).await
                     };
[31m-                    match sender.send(TimelineUpdate::PinResult { event_id, pin, result }) {
[m[32m+                    match sender.send(TimelineUpdate::PinResult {
[m[32m+                        event_id,
[m[32m+                        pin,
[m[32m+                        result,
[m[32m+                    }) {
[m                         Ok(_) => SignalToUI::set_ui_signal(),
                         Err(e) => log!("Failed to send timeline update for pin event: {e:?}"),
                     }
Diff in /app/src/sliding_sync.rs:1690:
                     }
                 });
             }
[31m-            MatrixRequest::GetUrlPreview { url, on_fetched, destination, update_sender,} => {
[m[32m+            MatrixRequest::GetUrlPreview {
[m[32m+                url,
[m[32m+                on_fetched,
[m[32m+                destination,
[m[32m+                update_sender,
[m[32m+            } => {
[m                 // const MAX_LOG_RESPONSE_BODY_LENGTH: usize = 1000;
                 // log!("Starting URL preview fetch for: {}", url);
                 let _fetch_url_preview_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:1700:
                             // error!("Matrix client not available for URL preview: {}", url);
                             UrlPreviewError::ClientNotAvailable
                         })?;
[31m-
[m[32m+
[m                         let token = client.access_token().ok_or_else(|| {
                             // error!("Access token not available for URL preview: {}", url);
                             UrlPreviewError::AccessTokenNotAvailable
Diff in /app/src/sliding_sync.rs:1707:
                         })?;
                         // Official Doc: https://spec.matrix.org/v1.11/client-server-api/#get_matrixclientv1mediapreview_url
                         // Element desktop is using /_matrix/media/v3/preview_url
[31m-                        let endpoint_url = client.homeserver().join("/_matrix/client/v1/media/preview_url")
[m[32m+                        let endpoint_url = client
[m[32m+                            .homeserver()
[m[32m+                            .join("/_matrix/client/v1/media/preview_url")
[m                             .map_err(UrlPreviewError::UrlParse)?;
                         // log!("Fetching URL preview from endpoint: {} for URL: {}", endpoint_url, url);
[31m-
[m[32m+
[m                         let response = client
                             .http_client()
                             .get(endpoint_url.clone())
Diff in /app/src/sliding_sync.rs:1723:
                                 // error!("HTTP request failed for URL preview {}: {}", url, e);
                                 UrlPreviewError::Request(e)
                             })?;
[31m-
[m[32m+
[m                         let status = response.status();
                         // log!("URL preview response status for {}: {}", url, status);
[31m-
[m[32m+
[m                         if !status.is_success() && status.as_u16() != 429 {
                             // error!("URL preview request failed with status {} for URL: {}", status, url);
                             return Err(UrlPreviewError::HttpStatus(status.as_u16()));
Diff in /app/src/sliding_sync.rs:1733:
                         }
[31m-
[m[32m+
[m                         let text = response.text().await.map_err(|e| {
                             // error!("Failed to read response text for URL preview {}: {}", url, e);
                             UrlPreviewError::Request(e)
Diff in /app/src/sliding_sync.rs:1738:
                         })?;
[31m-
[m[32m+
[m                         // log!("URL preview response body length for {}: {} bytes", url, text.len());
                         // if text.len() > MAX_LOG_RESPONSE_BODY_LENGTH {
                         //     log!("URL preview response body preview for {}: {}...", url, &text[..MAX_LOG_RESPONSE_BODY_LENGTH]);
Diff in /app/src/sliding_sync.rs:1745:
                         // }
                         // This request is rate limited, retry after a duration we get from the server.
                         if status.as_u16() == 429 {
[31m-                            let link_preview_429_res = serde_json::from_str::<LinkPreviewRateLimitResponse>(&text)
[m[31m-                                .map_err(|e| {
[m[31m-                                    // error!("Failed to parse as LinkPreviewRateLimitResponse for URL preview {}: {}", url, e);
[m[31m-                                    UrlPreviewError::Json(e)
[m[31m-                            });
[m[32m+                            let link_preview_429_res =
[m[32m+                                serde_json::from_str::<LinkPreviewRateLimitResponse>(&text)
[m[32m+                                    .map_err(|e| {
[m[32m+                                        // error!("Failed to parse as LinkPreviewRateLimitResponse for URL preview {}: {}", url, e);
[m[32m+                                        UrlPreviewError::Json(e)
[m[32m+                                    });
[m                             match link_preview_429_res {
                                 Ok(link_preview_429_res) => {
                                     if let Some(retry_after) = link_preview_429_res.retry_after_ms {
Diff in /app/src/sliding_sync.rs:1756:
[31m-                                        tokio::time::sleep(Duration::from_millis(retry_after.into())).await;
[m[31m-                                        submit_async_request(MatrixRequest::GetUrlPreview{
[m[32m+                                        tokio::time::sleep(Duration::from_millis(
[m[32m+                                            retry_after.into(),
[m[32m+                                        ))
[m[32m+                                        .await;
[m[32m+                                        submit_async_request(MatrixRequest::GetUrlPreview {
[m                                             url: url.clone(),
                                             on_fetched,
                                             destination: destination.clone(),
Diff in /app/src/sliding_sync.rs:1761:
                                             update_sender: update_sender.clone(),
                                         });
[31m-
[m                                     }
                                 }
                                 Err(_e) => {
Diff in /app/src/sliding_sync.rs:1780:
                                 // error!("Response body that failed to parse: {}", text);
                                 UrlPreviewError::Json(e)
                             })
[31m-                    }.await;
[m[32m+                    }
[m[32m+                    .await;
[m
                     // match &result {
                     //     Ok(preview_data) => {
Diff in /app/src/sliding_sync.rs:1787:
[31m-                    //         log!("Successfully fetched URL preview for {}: title={:?}, site_name={:?}",
[m[32m+                    //         log!("Successfully fetched URL preview for {}: title={:?}, site_name={:?}",
[m                     //              url, preview_data.title, preview_data.site_name);
                     //     }
                     //     Err(e) => {
Diff in /app/src/sliding_sync.rs:1803:
     bail!("matrix_worker_task task ended unexpectedly")
 }

[31m-
[m /// The single global Tokio runtime that is used by all async tasks.
 static TOKIO_RUNTIME: Mutex<Option<tokio::runtime::Runtime>> = Mutex::new(None);

Diff in /app/src/sliding_sync.rs:1816:
 static DEFAULT_SSO_CLIENT: Mutex<Option<(Client, ClientSessionPersisted)>> = Mutex::new(None);

 /// Used to notify the SSO login task that the async creation of the `DEFAULT_SSO_CLIENT` has finished.
[31m-static DEFAULT_SSO_CLIENT_NOTIFIER: LazyLock<Arc<Notify>> = LazyLock::new(|| Arc::new(Notify::new()));
[m[32m+static DEFAULT_SSO_CLIENT_NOTIFIER: LazyLock<Arc<Notify>> =
[m[32m+    LazyLock::new(|| Arc::new(Notify::new()));
[m
 /// Blocks the current thread until the given future completes.
 ///
Diff in /app/src/sliding_sync.rs:1827:
     timeout: Option<Duration>,
     async_future: impl Future<Output = T>,
 ) -> Result<T, Elapsed> {
[31m-    let rt = TOKIO_RUNTIME.lock().unwrap().get_or_insert_with(||
[m[31m-        tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[31m-    ).handle().clone();
[m[32m+    let rt = TOKIO_RUNTIME
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .get_or_insert_with(|| {
[m[32m+            tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[32m+        })
[m[32m+        .handle()
[m[32m+        .clone();
[m
     if let Some(timeout) = timeout {
[31m-        rt.block_on(async {
[m[31m-            tokio::time::timeout(timeout, async_future).await
[m[31m-        })
[m[32m+        rt.block_on(async { tokio::time::timeout(timeout, async_future).await })
[m     } else {
         Ok(rt.block_on(async_future))
     }
Diff in /app/src/sliding_sync.rs:1841:
 }

[31m-
[m /// The primary initialization routine for starting the Matrix client sync
 /// and the async tokio runtime.
 ///
Diff in /app/src/sliding_sync.rs:1847:
 /// Returns a handle to the Tokio runtime that is used to run async background tasks.
 pub fn start_matrix_tokio() -> Result<tokio::runtime::Handle> {
     // Create a Tokio runtime, and save it in a static variable to ensure it isn't dropped.
[31m-    let rt_handle = TOKIO_RUNTIME.lock().unwrap().get_or_insert_with(|| {
[m[31m-        tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[31m-    }).handle().clone();
[m[32m+    let rt_handle = TOKIO_RUNTIME
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .get_or_insert_with(|| {
[m[32m+            tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[32m+        })
[m[32m+        .handle()
[m[32m+        .clone();
[m
     // Proactively build a Matrix Client in the background so that the SSO Server
     // can have a quicker start if needed (as it's rather slow to build this client).
Diff in /app/src/sliding_sync.rs:1856:
     rt_handle.spawn(async move {
         match build_client(&Cli::default(), app_data_dir()).await {
             Ok(client_and_session) => {
[31m-                DEFAULT_SSO_CLIENT.lock().unwrap()
[m[32m+                DEFAULT_SSO_CLIENT
[m[32m+                    .lock()
[m[32m+                    .unwrap()
[m                     .get_or_insert(client_and_session);
             }
             Err(e) => error!("Error: could not create DEFAULT_SSO_CLIENT object: {e}"),
Diff in /app/src/sliding_sync.rs:1873:
     Ok(rt_handle)
 }

[31m-
[m /// A tokio::watch channel sender for sending requests from the RoomScreen UI widget
 /// to the corresponding background async task for that room (its `timeline_subscriber_handler`).
 pub type TimelineRequestSender = watch::Sender<Vec<BackwardsPaginateUntilEventRequest>>;
Diff in /app/src/sliding_sync.rs:1928:
     }
 }

[31m-
[m /// A const-compatible hasher, used for `static` items containing `HashMap`s or `HashSet`s.
 type ConstHasher = BuildHasherDefault<DefaultHasher>;

Diff in /app/src/sliding_sync.rs:1937:
 ///
 /// We use `LazyLock` here to initialize the `HashMap` with its default hasher (AHash),
 /// which is significantly faster than the default `std` hasher (SipHash) required for const initialization.
[31m-static ALL_JOINED_ROOMS: LazyLock<Mutex<HashMap<OwnedRoomId, JoinedRoomDetails>>> = LazyLock::new(|| Mutex::new(HashMap::new()));
[m[32m+static ALL_JOINED_ROOMS: LazyLock<Mutex<HashMap<OwnedRoomId, JoinedRoomDetails>>> =
[m[32m+    LazyLock::new(|| Mutex::new(HashMap::new()));
[m
 /// The logged-in Matrix client, which can be freely and cheaply cloned.
 static CLIENT: Mutex<Option<Client>> = Mutex::new(None);
Diff in /app/src/sliding_sync.rs:1948:

 /// Returns the user ID of the currently logged-in user, if any.
 pub fn current_user_id() -> Option<OwnedUserId> {
[31m-    CLIENT.lock().unwrap().as_ref().and_then(|c|
[m[31m-        c.session_meta().map(|m| m.user_id.clone())
[m[31m-    )
[m[32m+    CLIENT
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .as_ref()
[m[32m+        .and_then(|c| c.session_meta().map(|m| m.user_id.clone()))
[m }

 /// The singleton sync service.
Diff in /app/src/sliding_sync.rs:1957:
 static SYNC_SERVICE: Mutex<Option<Arc<SyncService>>> = Mutex::new(None);

[31m-
[m /// Get a reference to the current sync service, if available.
 pub fn get_sync_service() -> Option<Arc<SyncService>> {
     SYNC_SERVICE.lock().ok()?.as_ref().cloned()
Diff in /app/src/sliding_sync.rs:1965:
 /// The list of users that the current user has chosen to ignore.
 /// Ideally we shouldn't have to maintain this list ourselves,
 /// but the Matrix SDK doesn't currently properly maintain the list of ignored users.
[31m-static IGNORED_USERS: Mutex<HashSet<OwnedUserId, ConstHasher>> = Mutex::new(HashSet::with_hasher(BuildHasherDefault::new()));
[m[32m+static IGNORED_USERS: Mutex<HashSet<OwnedUserId, ConstHasher>> =
[m[32m+    Mutex::new(HashSet::with_hasher(BuildHasherDefault::new()));
[m
 /// Returns a deep clone of the current list of ignored users.
 pub fn get_ignored_users() -> HashSet<OwnedUserId, ConstHasher> {
Diff in /app/src/sliding_sync.rs:1977:
     IGNORED_USERS.lock().unwrap().contains(user_id)
 }

[31m-
[m /// Returns three channel endpoints related to the timeline for the given joined room.
 ///
 /// 1. A timeline update sender.
Diff in /app/src/sliding_sync.rs:1985:
 /// 3. A `tokio::watch` sender that can be used to send requests to the timeline subscriber handler.
 ///
 /// This will only succeed once per room, as only a single channel receiver can exist.
[31m-pub fn take_timeline_endpoints(
[m[31m-    room_id: &OwnedRoomId,
[m[31m-) -> Option<TimelineEndpoints> {
[m[32m+pub fn take_timeline_endpoints(room_id: &OwnedRoomId) -> Option<TimelineEndpoints> {
[m     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
     all_joined_rooms
         .get_mut(room_id)
Diff in /app/src/sliding_sync.rs:1994:
[31m-        .and_then(|jrd| jrd.timeline_singleton_endpoints.take()
[m[31m-            .map(|(update_receiver, request_sender)| (
[m[31m-                jrd.timeline_update_sender.clone(),
[m[31m-                update_receiver,
[m[31m-                request_sender,
[m[31m-                jrd.timeline.room().successor_room(),
[m[31m-            ))
[m[31m-        )
[m[31m-        .map(|(update_sender, update_receiver, request_sender, successor_room)| {
[m[31m-            TimelineEndpoints {
[m[32m+        .and_then(|jrd| {
[m[32m+            jrd.timeline_singleton_endpoints
[m[32m+                .take()
[m[32m+                .map(|(update_receiver, request_sender)| {
[m[32m+                    (
[m[32m+                        jrd.timeline_update_sender.clone(),
[m[32m+                        update_receiver,
[m[32m+                        request_sender,
[m[32m+                        jrd.timeline.room().successor_room(),
[m[32m+                    )
[m[32m+                })
[m[32m+        })
[m[32m+        .map(
[m[32m+            |(update_sender, update_receiver, request_sender, successor_room)| TimelineEndpoints {
[m                 update_sender,
                 update_receiver,
                 request_sender,
Diff in /app/src/sliding_sync.rs:2007:
                 successor_room,
[31m-            }
[m[31m-        })
[m[32m+            },
[m[32m+        )
[m }

 const DEFAULT_HOMESERVER: &str = "matrix.org";
Diff in /app/src/sliding_sync.rs:2013:

[31m-fn username_to_full_user_id(
[m[31m-    username: &str,
[m[31m-    homeserver: Option<&str>,
[m[31m-) -> Option<OwnedUserId> {
[m[31m-    username
[m[31m-        .try_into()
[m[31m-        .ok()
[m[31m-        .or_else(|| {
[m[31m-            let homeserver_url = homeserver.unwrap_or(DEFAULT_HOMESERVER);
[m[31m-            let user_id_str = if username.starts_with("@") {
[m[31m-                format!("{}:{}", username, homeserver_url)
[m[31m-            } else {
[m[31m-                format!("@{}:{}", username, homeserver_url)
[m[31m-            };
[m[31m-            user_id_str.as_str().try_into().ok()
[m[31m-        })
[m[32m+fn username_to_full_user_id(username: &str, homeserver: Option<&str>) -> Option<OwnedUserId> {
[m[32m+    username.try_into().ok().or_else(|| {
[m[32m+        let homeserver_url = homeserver.unwrap_or(DEFAULT_HOMESERVER);
[m[32m+        let user_id_str = if username.starts_with("@") {
[m[32m+            format!("{}:{}", username, homeserver_url)
[m[32m+        } else {
[m[32m+            format!("@{}:{}", username, homeserver_url)
[m[32m+        };
[m[32m+        user_id_str.as_str().try_into().ok()
[m[32m+    })
[m }

[31m-
[m /// Info we store about a room received by the room list service.
 ///
 /// This struct is necessary in order for us to track the previous state
Diff in /app/src/sliding_sync.rs:2057:
 impl RoomListServiceRoomInfo {
     async fn from_room(room: matrix_sdk::Room, current_user_id: &Option<OwnedUserId>) -> Self {
         // Parallelize fetching of independent room data.
[31m-        let (is_direct, tags, display_name, user_power_levels) = tokio::join!(
[m[31m-            room.is_direct(),
[m[31m-            room.tags(),
[m[31m-            room.display_name(),
[m[31m-            async {
[m[32m+        let (is_direct, tags, display_name, user_power_levels) =
[m[32m+            tokio::join!(room.is_direct(), room.tags(), room.display_name(), async {
[m                 if let Some(user_id) = current_user_id {
                     UserPowerLevels::from_room(&room, user_id.deref()).await
                 } else {
Diff in /app/src/sliding_sync.rs:2068:
                     None
                 }
[31m-            }
[m[31m-        );
[m[32m+            });
[m
         Self {
             room_id: room.room_id().to_owned(),
Diff in /app/src/sliding_sync.rs:2110:
     let most_recent_user_id = persistence::most_recent_user_id().await;
     log!("Most recent user ID: {most_recent_user_id:?}");
     let cli_parse_result = Cli::try_parse();
[31m-    let cli_has_valid_username_password = cli_parse_result.as_ref()
[m[32m+    let cli_has_valid_username_password = cli_parse_result
[m[32m+        .as_ref()
[m         .is_ok_and(|cli| !cli.user_id.is_empty() && !cli.password.is_empty());
[31m-    log!("CLI parsing succeeded? {}. CLI has valid UN+PW? {}",
[m[32m+    log!(
[m[32m+        "CLI parsing succeeded? {}. CLI has valid UN+PW? {}",
[m         cli_parse_result.as_ref().is_ok(),
         cli_has_valid_username_password,
     );
Diff in /app/src/sliding_sync.rs:2119:
[31m-    let wait_for_login = !cli_has_valid_username_password && (
[m[31m-        most_recent_user_id.is_none()
[m[31m-            || std::env::args().any(|arg| arg == "--login-screen" || arg == "--force-login")
[m[31m-    );
[m[32m+    let wait_for_login = !cli_has_valid_username_password
[m[32m+        && (most_recent_user_id.is_none()
[m[32m+            || std::env::args().any(|arg| arg == "--login-screen" || arg == "--force-login"));
[m     log!("Waiting for login? {}", wait_for_login);

     let new_login_opt = if !wait_for_login {
Diff in /app/src/sliding_sync.rs:2126:
[31m-        let specified_username = cli_parse_result.as_ref().ok().and_then(|cli|
[m[31m-            username_to_full_user_id(
[m[31m-                &cli.user_id,
[m[31m-                cli.homeserver.as_deref(),
[m[31m-            )
[m[31m-        );
[m[31m-        log!("Trying to restore session for user: {:?}",
[m[32m+        let specified_username = cli_parse_result
[m[32m+            .as_ref()
[m[32m+            .ok()
[m[32m+            .and_then(|cli| username_to_full_user_id(&cli.user_id, cli.homeserver.as_deref()));
[m[32m+        log!(
[m[32m+            "Trying to restore session for user: {:?}",
[m             specified_username.as_ref().or(most_recent_user_id.as_ref())
         );
         match persistence::restore_session(specified_username).await {
Diff in /app/src/sliding_sync.rs:2140:
                 Cx::post_action(LoginAction::LoginFailure(status_err.to_string()));

                 if let Ok(cli) = &cli_parse_result {
[31m-                    log!("Attempting auto-login from CLI arguments as user '{}'...", cli.user_id);
[m[32m+                    log!(
[m[32m+                        "Attempting auto-login from CLI arguments as user '{}'...",
[m[32m+                        cli.user_id
[m[32m+                    );
[m                     Cx::post_action(LoginAction::CliAutoLogin {
                         user_id: cli.user_id.clone(),
                         homeserver: cli.homeserver.clone(),
Diff in /app/src/sliding_sync.rs:2149:
                         Ok(new_login) => Some(new_login),
                         Err(e) => {
                             error!("CLI-based login failed: {e:?}");
[31m-                            Cx::post_action(LoginAction::LoginFailure(
[m[31m-                                format!("Could not login with CLI-provided arguments.\n\nPlease login manually.\n\nError: {e}")
[m[31m-                            ));
[m[32m+                            Cx::post_action(LoginAction::LoginFailure(format!(
[m[32m+                                "Could not login with CLI-provided arguments.\n\nPlease login manually.\n\nError: {e}"
[m[32m+                            )));
[m                             enqueue_rooms_list_update(RoomsListUpdate::Status {
                                 status: format!("Login failed: {e:?}"),
                             });
Diff in /app/src/sliding_sync.rs:2169:
     let cli: Cli = cli_parse_result.unwrap_or(Cli::default());
     let (client, _sync_token) = match new_login_opt {
         Some(new_login) => new_login,
[31m-        None => {
[m[31m-            loop {
[m[31m-                log!("Waiting for login request...");
[m[31m-                match login_receiver.recv().await {
[m[31m-                    Some(login_request) => {
[m[31m-                        match login(&cli, login_request).await {
[m[31m-                            Ok((client, sync_token)) => {
[m[31m-                                break (client, sync_token);
[m[31m-                            }
[m[31m-                            Err(e) => {
[m[31m-                                error!("Login failed: {e:?}");
[m[31m-                                Cx::post_action(LoginAction::LoginFailure(format!("{e}")));
[m[31m-                                enqueue_rooms_list_update(RoomsListUpdate::Status {
[m[31m-                                    status: format!("Login failed: {e}"),
[m[31m-                                });
[m[31m-                            }
[m[31m-                        }
[m[31m-                    },
[m[31m-                    None => {
[m[31m-                        error!("BUG: login_receiver hung up unexpectedly");
[m[31m-                        let err = String::from("Please restart Robrix.\n\nUnable to listen for login requests.");
[m[31m-                        Cx::post_action(LoginAction::LoginFailure(err.clone()));
[m[32m+        None => loop {
[m[32m+            log!("Waiting for login request...");
[m[32m+            match login_receiver.recv().await {
[m[32m+                Some(login_request) => match login(&cli, login_request).await {
[m[32m+                    Ok((client, sync_token)) => {
[m[32m+                        break (client, sync_token);
[m[32m+                    }
[m[32m+                    Err(e) => {
[m[32m+                        error!("Login failed: {e:?}");
[m[32m+                        Cx::post_action(LoginAction::LoginFailure(format!("{e}")));
[m                         enqueue_rooms_list_update(RoomsListUpdate::Status {
[31m-                            status: err,
[m[32m+                            status: format!("Login failed: {e}"),
[m                         });
[31m-                        return;
[m                     }
[32m+                },
[m[32m+                None => {
[m[32m+                    error!("BUG: login_receiver hung up unexpectedly");
[m[32m+                    let err = String::from(
[m[32m+                        "Please restart Robrix.\n\nUnable to listen for login requests.",
[m[32m+                    );
[m[32m+                    Cx::post_action(LoginAction::LoginFailure(err.clone()));
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::Status { status: err });
[m[32m+                    return;
[m                 }
             }
[31m-        }
[m[32m+        },
[m     };

     Cx::post_action(LoginAction::LoginSuccess);
Diff in /app/src/sliding_sync.rs:2208:
         let _ = client_opt.take();
     }

[31m-    let logged_in_user_id = client.user_id()
[m[32m+    let logged_in_user_id = client
[m[32m+        .user_id()
[m         .expect("BUG: client.user_id() returned None after successful login!");
     let status = format!("Logged in as {}.\n → Loading rooms...", logged_in_user_id);
     enqueue_rooms_list_update(RoomsListUpdate::Status { status });
Diff in /app/src/sliding_sync.rs:2215:

     // Store this active client in our global Client state so that other tasks can access it.
     if let Some(_existing) = CLIENT.lock().unwrap().replace(client.clone()) {
[31m-        error!("BUG: unexpectedly replaced an existing client when initializing the matrix client.");
[m[32m+        error!(
[m[32m+            "BUG: unexpectedly replaced an existing client when initializing the matrix client."
[m[32m+        );
[m     }

     // Listen for changes to our verification status and incoming verification requests.
Diff in /app/src/sliding_sync.rs:2232:
         Ok(ss) => ss,
         Err(e) => {
             error!("BUG: failed to create SyncService: {e:?}");
[31m-            let err = format!("Please restart Robrix.\n\nFailed to create Matrix sync service: {e}.");
[m[31m-            enqueue_popup_notification(
[m[31m-                err.clone(),
[m[31m-                PopupKind::Error,
[m[31m-                None,
[m[31m-            );
[m[32m+            let err =
[m[32m+                format!("Please restart Robrix.\n\nFailed to create Matrix sync service: {e}.");
[m[32m+            enqueue_popup_notification(err.clone(), PopupKind::Error, None);
[m             enqueue_rooms_list_update(RoomsListUpdate::Status { status: err });
             return;
         }
Diff in /app/src/sliding_sync.rs:2251:
     let room_list_service = sync_service.room_list_service();

     if let Some(_existing) = SYNC_SERVICE.lock().unwrap().replace(Arc::new(sync_service)) {
[31m-        error!("BUG: unexpectedly replaced an existing sync service when initializing the matrix client.");
[m[32m+        error!(
[m[32m+            "BUG: unexpectedly replaced an existing sync service when initializing the matrix client."
[m[32m+        );
[m     }

     let mut room_list_service_task = rt.spawn(room_list_service_loop(room_list_service));
Diff in /app/src/sliding_sync.rs:2342:
     }
 }

[31m-
[m /// The main async task that listens for changes to all rooms.
 async fn room_list_service_loop(room_list_service: Arc<RoomListService>) -> Result<()> {
     let all_rooms_list = room_list_service.all_rooms().await?;
Diff in /app/src/sliding_sync.rs:2356:
     // 1. not spaces (those are handled by the SpaceService),
     // 2. not left (clients don't typically show rooms that the user has already left),
     // 3. not outdated (don't show tombstoned rooms whose successor is already joined).
[31m-    room_list_dynamic_entries_controller.set_filter(Box::new(
[m[31m-        filters::new_filter_all(vec![
[m[31m-            Box::new(filters::new_filter_not(Box::new(filters::new_filter_space()))),
[m[31m-            Box::new(filters::new_filter_non_left()),
[m[31m-            Box::new(filters::new_filter_deduplicate_versions()),
[m[31m-        ])
[m[31m-    ));
[m[32m+    room_list_dynamic_entries_controller.set_filter(Box::new(filters::new_filter_all(vec![
[m[32m+        Box::new(filters::new_filter_not(Box::new(
[m[32m+            filters::new_filter_space(),
[m[32m+        ))),
[m[32m+        Box::new(filters::new_filter_non_left()),
[m[32m+        Box::new(filters::new_filter_deduplicate_versions()),
[m[32m+    ])));
[m
     let mut all_known_rooms: Vector<RoomListServiceRoomInfo> = Vector::new();
     let current_user_id = current_user_id();
Diff in /app/src/sliding_sync.rs:2378:
                     // Append and Reset are identical, except for Reset first clears all rooms.
                     let _num_new_rooms = new_rooms.len();
                     if is_reset {
[31m-                        if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Reset, old length {}, new length {}", all_known_rooms.len(), new_rooms.len()); }
[m[32m+                        if LOG_ROOM_LIST_DIFFS {
[m[32m+                            log!(
[m[32m+                                "room_list: diff Reset, old length {}, new length {}",
[m[32m+                                all_known_rooms.len(),
[m[32m+                                new_rooms.len()
[m[32m+                            );
[m[32m+                        }
[m                         // Iterate manually so we can know which rooms are being removed.
                         while let Some(room) = all_known_rooms.pop_back() {
                             remove_room(&room);
Diff in /app/src/sliding_sync.rs:2389:
                         enqueue_rooms_list_update(RoomsListUpdate::ClearRooms);
                         enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Clear));
                     } else {
[31m-                        if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Append, old length {}, adding {} new items", all_known_rooms.len(), _num_new_rooms); }
[m[32m+                        if LOG_ROOM_LIST_DIFFS {
[m[32m+                            log!(
[m[32m+                                "room_list: diff Append, old length {}, adding {} new items",
[m[32m+                                all_known_rooms.len(),
[m[32m+                                _num_new_rooms
[m[32m+                            );
[m[32m+                        }
[m                     }

                     // Parallelize creating each room's RoomListServiceRoomInfo and adding that new room.
Diff in /app/src/sliding_sync.rs:2396:
                     // We combine `from_room` and `add_new_room` into a single async task per room.
[31m-                    let new_room_infos: Vec<RoomListServiceRoomInfo> = join_all(
[m[31m-                        new_rooms.into_iter().map(|room| async {
[m[31m-                            let room_info = RoomListServiceRoomInfo::from_room(room.into_inner(), &current_user_id).await;
[m[31m-                            if let Err(e) = add_new_room(&room_info, &room_list_service, false).await {
[m[31m-                                error!("Failed to add new room: {:?} ({}); error: {:?}", room_info.display_name, room_info.room_id, e);
[m[32m+                    let new_room_infos: Vec<RoomListServiceRoomInfo> =
[m[32m+                        join_all(new_rooms.into_iter().map(|room| async {
[m[32m+                            let room_info = RoomListServiceRoomInfo::from_room(
[m[32m+                                room.into_inner(),
[m[32m+                                &current_user_id,
[m[32m+                            )
[m[32m+                            .await;
[m[32m+                            if let Err(e) =
[m[32m+                                add_new_room(&room_info, &room_list_service, false).await
[m[32m+                            {
[m[32m+                                error!(
[m[32m+                                    "Failed to add new room: {:?} ({}); error: {:?}",
[m[32m+                                    room_info.display_name, room_info.room_id, e
[m[32m+                                );
[m                             }
                             room_info
[31m-                        })
[m[31m-                    ).await;
[m[32m+                        }))
[m[32m+                        .await;
[m
                     // Send room order update with the new room IDs
                     let (room_id_refs, room_ids) = {
Diff in /app/src/sliding_sync.rs:2416:
                     };
                     if !room_ids.is_empty() {
                         enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[31m-                            VecDiff::Append { values: room_ids }
[m[32m+                            VecDiff::Append { values: room_ids },
[m                         ));
                         room_list_service.subscribe_to_rooms(&room_id_refs).await;
                         all_known_rooms.extend(new_room_infos);
Diff in /app/src/sliding_sync.rs:2423:
                     }
                 }
                 VectorDiff::Clear => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Clear"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Clear");
[m[32m+                    }
[m                     all_known_rooms.clear();
                     ALL_JOINED_ROOMS.lock().unwrap().clear();
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Clear));
Diff in /app/src/sliding_sync.rs:2430:
                     enqueue_rooms_list_update(RoomsListUpdate::ClearRooms);
                 }
                 VectorDiff::PushFront { value: new_room } => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PushFront"); }
[m[31m-                    let new_room = RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id).await;
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PushFront");
[m[32m+                    }
[m[32m+                    let new_room =
[m[32m+                        RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id)
[m[32m+                            .await;
[m                     let room_id = new_room.room_id.clone();
                     add_new_room(&new_room, &room_list_service, true).await?;
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
Diff in /app/src/sliding_sync.rs:2438:
[31m-                        VecDiff::PushFront { value: room_id }
[m[32m+                        VecDiff::PushFront { value: room_id },
[m                     ));
                     all_known_rooms.push_front(new_room);
                 }
Diff in /app/src/sliding_sync.rs:2442:
                 VectorDiff::PushBack { value: new_room } => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PushBack"); }
[m[31m-                    let new_room = RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id).await;
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PushBack");
[m[32m+                    }
[m[32m+                    let new_room =
[m[32m+                        RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id)
[m[32m+                            .await;
[m                     let room_id = new_room.room_id.clone();
                     add_new_room(&new_room, &room_list_service, true).await?;
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
Diff in /app/src/sliding_sync.rs:2448:
[31m-                        VecDiff::PushBack { value: room_id }
[m[32m+                        VecDiff::PushBack { value: room_id },
[m                     ));
                     all_known_rooms.push_back(new_room);
                 }
Diff in /app/src/sliding_sync.rs:2452:
                 remove_diff @ VectorDiff::PopFront => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PopFront"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PopFront");
[m[32m+                    }
[m                     if let Some(room) = all_known_rooms.pop_front() {
[31m-                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PopFront));
[m[32m+                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[32m+                            VecDiff::PopFront,
[m[32m+                        ));
[m                         optimize_remove_then_add_into_update(
                             remove_diff,
                             &room,
Diff in /app/src/sliding_sync.rs:2460:
                             &mut all_known_rooms,
                             &room_list_service,
                             &current_user_id,
[31m-                        ).await?;
[m[32m+                        )
[m[32m+                        .await?;
[m                     }
                 }
                 remove_diff @ VectorDiff::PopBack => {
Diff in /app/src/sliding_sync.rs:2467:
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PopBack"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PopBack");
[m[32m+                    }
[m                     if let Some(room) = all_known_rooms.pop_back() {
[31m-                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PopBack));
[m[32m+                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[32m+                            VecDiff::PopBack,
[m[32m+                        ));
[m                         optimize_remove_then_add_into_update(
                             remove_diff,
                             &room,
Diff in /app/src/sliding_sync.rs:2474:
                             &mut all_known_rooms,
                             &room_list_service,
                             &current_user_id,
[31m-                        ).await?;
[m[32m+                        )
[m[32m+                        .await?;
[m                     }
                 }
[31m-                VectorDiff::Insert { index, value: new_room } => {
[m[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Insert at {index}"); }
[m[31m-                    let new_room = RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id).await;
[m[32m+                VectorDiff::Insert {
[m[32m+                    index,
[m[32m+                    value: new_room,
[m[32m+                } => {
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Insert at {index}");
[m[32m+                    }
[m[32m+                    let new_room =
[m[32m+                        RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id)
[m[32m+                            .await;
[m                     let room_id = new_room.room_id.clone();
                     add_new_room(&new_room, &room_list_service, true).await?;
[31m-                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                        VecDiff::Insert { index, value: room_id }
[m[31m-                    ));
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Insert {
[m[32m+                        index,
[m[32m+                        value: room_id,
[m[32m+                    }));
[m                     all_known_rooms.insert(index, new_room);
                 }
[31m-                VectorDiff::Set { index, value: changed_room } => {
[m[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Set at {index}"); }
[m[31m-                    let changed_room = RoomListServiceRoomInfo::from_room(changed_room.into_inner(), &current_user_id).await;
[m[32m+                VectorDiff::Set {
[m[32m+                    index,
[m[32m+                    value: changed_room,
[m[32m+                } => {
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Set at {index}");
[m[32m+                    }
[m[32m+                    let changed_room = RoomListServiceRoomInfo::from_room(
[m[32m+                        changed_room.into_inner(),
[m[32m+                        &current_user_id,
[m[32m+                    )
[m[32m+                    .await;
[m                     if let Some(old_room) = all_known_rooms.get(index) {
                         update_room(old_room, &changed_room, &room_list_service).await?;
                     } else {
Diff in /app/src/sliding_sync.rs:2496:
                         error!("BUG: room list diff: Set index {index} was out of bounds.");
                     }
                     // Send order update (room ID at this index may have changed)
[31m-                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                        VecDiff::Set { index, value: changed_room.room_id.clone() }
[m[31m-                    ));
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Set {
[m[32m+                        index,
[m[32m+                        value: changed_room.room_id.clone(),
[m[32m+                    }));
[m                     all_known_rooms.set(index, changed_room);
                 }
                 remove_diff @ VectorDiff::Remove { index } => {
Diff in /app/src/sliding_sync.rs:2505:
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Remove at {index}"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Remove at {index}");
[m[32m+                    }
[m                     if index < all_known_rooms.len() {
                         let room = all_known_rooms.remove(index);
[31m-                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Remove { index }));
[m[32m+                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[32m+                            VecDiff::Remove { index },
[m[32m+                        ));
[m                         optimize_remove_then_add_into_update(
                             remove_diff,
                             &room,
Diff in /app/src/sliding_sync.rs:2513:
                             &mut all_known_rooms,
                             &room_list_service,
                             &current_user_id,
[31m-                        ).await?;
[m[32m+                        )
[m[32m+                        .await?;
[m                     } else {
[31m-                        error!("BUG: room_list: diff Remove index {index} out of bounds, len {}", all_known_rooms.len());
[m[32m+                        error!(
[m[32m+                            "BUG: room_list: diff Remove index {index} out of bounds, len {}",
[m[32m+                            all_known_rooms.len()
[m[32m+                        );
[m                     }
                 }
                 VectorDiff::Truncate { length } => {
Diff in /app/src/sliding_sync.rs:2522:
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Truncate to {length}"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Truncate to {length}");
[m[32m+                    }
[m                     // Iterate manually so we can know which rooms are being removed.
                     while all_known_rooms.len() > length {
                         if let Some(room) = all_known_rooms.pop_back() {
Diff in /app/src/sliding_sync.rs:2528:
                     }
                     all_known_rooms.truncate(length); // sanity check
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[31m-                        VecDiff::Truncate { length }
[m[32m+                        VecDiff::Truncate { length },
[m                     ));
                 }
             }
Diff in /app/src/sliding_sync.rs:2538:
     bail!("room list service sync loop ended unexpectedly")
 }

[31m-
[m /// Attempts to optimize a common RoomListService operation of remove + add.
 ///
 /// If a `Remove` diff (or `PopBack` or `PopFront`) is immediately followed by
Diff in /app/src/sliding_sync.rs:2558:
 ) -> Result<()> {
     let next_diff_was_handled: bool;
     match peekable_diffs.peek() {
[31m-        Some(VectorDiff::Insert { index: insert_index, value: new_room })
[m[31m-            if room.room_id == new_room.room_id() =>
[m[31m-        {
[m[32m+        Some(VectorDiff::Insert {
[m[32m+            index: insert_index,
[m[32m+            value: new_room,
[m[32m+        }) if room.room_id == new_room.room_id() => {
[m             if LOG_ROOM_LIST_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + Insert({insert_index}) into Update for room {}", room.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + Insert({insert_index}) into Update for room {}",
[m[32m+                    room.room_id
[m[32m+                );
[m             }
[31m-            let new_room = RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m[32m+            let new_room =
[m[32m+                RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m             update_room(room, &new_room, room_list_service).await?;
             // Send order update for the insert
[31m-            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                VecDiff::Insert { index: *insert_index, value: new_room.room_id.clone() }
[m[31m-            ));
[m[32m+            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Insert {
[m[32m+                index: *insert_index,
[m[32m+                value: new_room.room_id.clone(),
[m[32m+            }));
[m             all_known_rooms.insert(*insert_index, new_room);
             next_diff_was_handled = true;
         }
Diff in /app/src/sliding_sync.rs:2576:
[31m-        Some(VectorDiff::PushFront { value: new_room })
[m[31m-            if room.room_id == new_room.room_id() =>
[m[31m-        {
[m[32m+        Some(VectorDiff::PushFront { value: new_room }) if room.room_id == new_room.room_id() => {
[m             if LOG_ROOM_LIST_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + PushFront into Update for room {}", room.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + PushFront into Update for room {}",
[m[32m+                    room.room_id
[m[32m+                );
[m             }
[31m-            let new_room = RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m[32m+            let new_room =
[m[32m+                RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m             update_room(room, &new_room, room_list_service).await?;
             // Send order update for the push front
[31m-            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                VecDiff::PushFront { value: new_room.room_id.clone() }
[m[31m-            ));
[m[32m+            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PushFront {
[m[32m+                value: new_room.room_id.clone(),
[m[32m+            }));
[m             all_known_rooms.push_front(new_room);
             next_diff_was_handled = true;
         }
Diff in /app/src/sliding_sync.rs:2591:
[31m-        Some(VectorDiff::PushBack { value: new_room })
[m[31m-            if room.room_id == new_room.room_id() =>
[m[31m-        {
[m[32m+        Some(VectorDiff::PushBack { value: new_room }) if room.room_id == new_room.room_id() => {
[m             if LOG_ROOM_LIST_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + PushBack into Update for room {}", room.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + PushBack into Update for room {}",
[m[32m+                    room.room_id
[m[32m+                );
[m             }
[31m-            let new_room = RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m[32m+            let new_room =
[m[32m+                RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m             update_room(room, &new_room, room_list_service).await?;
             // Send order update for the push back
[31m-            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                VecDiff::PushBack { value: new_room.room_id.clone() }
[m[31m-            ));
[m[32m+            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PushBack {
[m[32m+                value: new_room.room_id.clone(),
[m[32m+            }));
[m             all_known_rooms.push_back(new_room);
             next_diff_was_handled = true;
         }
Diff in /app/src/sliding_sync.rs:2613:
     Ok(())
 }

[31m-
[m /// Invoked when the room list service has received an update that changes an existing room.
 async fn update_room(
     old_room: &RoomListServiceRoomInfo,
Diff in /app/src/sliding_sync.rs:2624:
     if old_room.room_id == new_room_id {
         // Handle state transitions for a room.
         if LOG_ROOM_LIST_DIFFS {
[31m-            log!("Room {:?} ({new_room_id}) state went from {:?} --> {:?}", new_room.display_name, old_room.state, new_room.state);
[m[32m+            log!(
[m[32m+                "Room {:?} ({new_room_id}) state went from {:?} --> {:?}",
[m[32m+                new_room.display_name,
[m[32m+                old_room.state,
[m[32m+                new_room.state
[m[32m+            );
[m         }
         if old_room.state != new_room.state {
             match new_room.state {
Diff in /app/src/sliding_sync.rs:2631:
                 RoomState::Banned => {
                     // TODO: handle rooms that this user has been banned from.
[31m-                    log!("Removing Banned room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "Removing Banned room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     remove_room(new_room);
                     return Ok(());
                 }
Diff in /app/src/sliding_sync.rs:2637:
                 RoomState::Left => {
[31m-                    log!("Removing Left room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "Removing Left room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     // TODO: instead of removing this, we could optionally add it to
                     //       a separate list of left rooms, which would be collapsed by default.
                     //       Upon clicking a left room, we could show a splash page
Diff in /app/src/sliding_sync.rs:2645:
                     return Ok(());
                 }
                 RoomState::Joined => {
[31m-                    log!("update_room(): adding new Joined room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "update_room(): adding new Joined room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     return add_new_room(new_room, room_list_service, true).await;
                 }
                 RoomState::Invited => {
Diff in /app/src/sliding_sync.rs:2652:
[31m-                    log!("update_room(): adding new Invited room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "update_room(): adding new Invited room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     return add_new_room(new_room, room_list_service, true).await;
                 }
                 RoomState::Knocked => {
Diff in /app/src/sliding_sync.rs:2667:
             spawn_fetch_room_avatar(new_room);
         }
         if old_room.display_name != new_room.display_name {
[31m-            log!("Updating room {} name: {:?} --> {:?}", new_room_id, old_room.display_name, new_room.display_name);
[m[32m+            log!(
[m[32m+                "Updating room {} name: {:?} --> {:?}",
[m[32m+                new_room_id,
[m[32m+                old_room.display_name,
[m[32m+                new_room.display_name
[m[32m+            );
[m
             enqueue_rooms_list_update(RoomsListUpdate::UpdateRoomName {
                 new_room_name: (new_room.display_name.clone(), new_room_id.clone()).into(),
Diff in /app/src/sliding_sync.rs:2677:
         // Then, we check for changes to room data that is only relevant to joined rooms:
         // including the latest event, tags, unread counts, is_direct, tombstoned state, power levels, etc.
         // Invited or left rooms don't care about these details.
[31m-        if matches!(new_room.state, RoomState::Joined) {
[m[32m+        if matches!(new_room.state, RoomState::Joined) {
[m             // For some reason, the latest event API does not reliably catch *all* changes
             // to the latest event in a given room, such as redactions.
             // Thus, we have to re-obtain the latest event on *every* update, regardless of timestamp.
Diff in /app/src/sliding_sync.rs:2684:
             //
[31m-            let update_latest = match (old_room.latest_event_timestamp, new_room.room.latest_event_timestamp()) {
[m[32m+            let update_latest = match (
[m[32m+                old_room.latest_event_timestamp,
[m[32m+                new_room.room.latest_event_timestamp(),
[m[32m+            ) {
[m                 (Some(old_ts), Some(new_ts)) => new_ts >= old_ts,
                 (None, Some(_)) => true,
                 _ => false,
Diff in /app/src/sliding_sync.rs:2691:
                 update_latest_event(&new_room.room).await;
             }

[31m-
[m             if old_room.tags != new_room.tags {
[31m-                log!("Updating room {} tags from {:?} to {:?}", new_room_id, old_room.tags, new_room.tags);
[m[32m+                log!(
[m[32m+                    "Updating room {} tags from {:?} to {:?}",
[m[32m+                    new_room_id,
[m[32m+                    old_room.tags,
[m[32m+                    new_room.tags
[m[32m+                );
[m                 enqueue_rooms_list_update(RoomsListUpdate::Tags {
                     room_id: new_room_id.clone(),
                     new_tags: new_room.tags.clone().unwrap_or_default(),
Diff in /app/src/sliding_sync.rs:2704:
                 || old_room.num_unread_messages != new_room.num_unread_messages
                 || old_room.num_unread_mentions != new_room.num_unread_mentions
             {
[31m-                log!("Updating room {}, marked unread {} --> {}, unread messages {} --> {}, unread mentions {} --> {}",
[m[32m+                log!(
[m[32m+                    "Updating room {}, marked unread {} --> {}, unread messages {} --> {}, unread mentions {} --> {}",
[m                     new_room_id,
[31m-                    old_room.is_marked_unread, new_room.is_marked_unread,
[m[31m-                    old_room.num_unread_messages, new_room.num_unread_messages,
[m[31m-                    old_room.num_unread_mentions, new_room.num_unread_mentions,
[m[32m+                    old_room.is_marked_unread,
[m[32m+                    new_room.is_marked_unread,
[m[32m+                    old_room.num_unread_messages,
[m[32m+                    new_room.num_unread_messages,
[m[32m+                    old_room.num_unread_mentions,
[m[32m+                    new_room.num_unread_mentions,
[m                 );
                 enqueue_rooms_list_update(RoomsListUpdate::UpdateNumUnreadMessages {
                     room_id: new_room_id.clone(),
Diff in /app/src/sliding_sync.rs:2719:
             }

             if old_room.is_direct != new_room.is_direct {
[31m-                log!("Updating room {} is_direct from {} to {}",
[m[32m+                log!(
[m[32m+                    "Updating room {} is_direct from {} to {}",
[m                     new_room_id,
                     old_room.is_direct,
                     new_room.is_direct,
Diff in /app/src/sliding_sync.rs:2743:
             if !old_room.is_tombstoned && new_room.is_tombstoned {
                 let successor_room = new_room.room.successor_room();
                 log!("Updating room {new_room_id} to be tombstoned, {successor_room:?}");
[31m-                enqueue_rooms_list_update(RoomsListUpdate::TombstonedRoom { room_id: new_room_id.clone() });
[m[32m+                enqueue_rooms_list_update(RoomsListUpdate::TombstonedRoom {
[m[32m+                    room_id: new_room_id.clone(),
[m[32m+                });
[m                 if let Some(timeline_update_sender) = get_timeline_update_sender(&new_room_id) {
                     spawn_fetch_successor_room_preview(
                         room_list_service.client().clone(),
Diff in /app/src/sliding_sync.rs:2752:
                         timeline_update_sender,
                     );
                 } else {
[31m-                    error!("BUG: could not find JoinedRoomDetails for newly-tombstoned room {new_room_id}");
[m[32m+                    error!(
[m[32m+                        "BUG: could not find JoinedRoomDetails for newly-tombstoned room {new_room_id}"
[m[32m+                    );
[m                 }
             }

Diff in /app/src/sliding_sync.rs:2763:
                     log!("Updating room {new_room_id} user power levels.");
                     match timeline_update_sender.send(TimelineUpdate::UserPowerLevels(nupl)) {
                         Ok(_) => SignalToUI::set_ui_signal(),
[31m-                        Err(_) => error!("Failed to send the UserPowerLevels update to room {new_room_id}"),
[m[32m+                        Err(_) => error!(
[m[32m+                            "Failed to send the UserPowerLevels update to room {new_room_id}"
[m[32m+                        ),
[m                     }
                 } else {
[31m-                    error!("BUG: could not find JoinedRoomDetails for room {new_room_id} where power levels changed.");
[m[32m+                    error!(
[m[32m+                        "BUG: could not find JoinedRoomDetails for room {new_room_id} where power levels changed."
[m[32m+                    );
[m                 }
             }
         }
Diff in /app/src/sliding_sync.rs:2773:
         Ok(())
[31m-    }
[m[31m-    else {
[m[31m-        warning!("UNTESTED SCENARIO: update_room(): removing old room {}, replacing with new room {}",
[m[31m-            old_room.room_id, new_room_id,
[m[32m+    } else {
[m[32m+        warning!(
[m[32m+            "UNTESTED SCENARIO: update_room(): removing old room {}, replacing with new room {}",
[m[32m+            old_room.room_id,
[m[32m+            new_room_id,
[m         );
         remove_room(old_room);
         add_new_room(new_room, room_list_service, true).await
Diff in /app/src/sliding_sync.rs:2781:
     }
 }

[31m-
[m /// Invoked when the room list service has received an update to remove an existing room.
 fn remove_room(room: &RoomListServiceRoomInfo) {
     ALL_JOINED_ROOMS.lock().unwrap().remove(&room.room_id);
Diff in /app/src/sliding_sync.rs:2788:
[31m-    enqueue_rooms_list_update(
[m[31m-        RoomsListUpdate::RemoveRoom {
[m[31m-            room_id: room.room_id.clone(),
[m[31m-            new_state: room.state,
[m[31m-        }
[m[31m-    );
[m[32m+    enqueue_rooms_list_update(RoomsListUpdate::RemoveRoom {
[m[32m+        room_id: room.room_id.clone(),
[m[32m+        new_state: room.state,
[m[32m+    });
[m }

[31m-
[m /// Invoked when the room list service has received an update with a brand new room.
 async fn add_new_room(
     new_room: &RoomListServiceRoomInfo,
Diff in /app/src/sliding_sync.rs:2802:
 ) -> Result<()> {
     match new_room.state {
         RoomState::Knocked => {
[31m-            log!("Got new Knocked room: {:?} ({})", new_room.display_name, new_room.room_id);
[m[32m+            log!(
[m[32m+                "Got new Knocked room: {:?} ({})",
[m[32m+                new_room.display_name,
[m[32m+                new_room.room_id
[m[32m+            );
[m             // Note: here we could optionally display Knocked rooms as a separate type of room
             //       in the rooms list, but it's not really necessary at this point.
             return Ok(());
Diff in /app/src/sliding_sync.rs:2809:
         }
         RoomState::Banned => {
[31m-            log!("Got new Banned room: {:?} ({})", new_room.display_name, new_room.room_id);
[m[32m+            log!(
[m[32m+                "Got new Banned room: {:?} ({})",
[m[32m+                new_room.display_name,
[m[32m+                new_room.room_id
[m[32m+            );
[m             // Note: here we could optionally display Banned rooms as a separate type of room
             //       in the rooms list, but it's not really necessary at this point.
             return Ok(());
Diff in /app/src/sliding_sync.rs:2815:
         }
         RoomState::Left => {
[31m-            log!("Got new Left room: {:?} ({:?})", new_room.display_name, new_room.room_id);
[m[32m+            log!(
[m[32m+                "Got new Left room: {:?} ({:?})",
[m[32m+                new_room.display_name,
[m[32m+                new_room.room_id
[m[32m+            );
[m             // Note: here we could optionally display Left rooms as a separate type of room
             //       in the rooms list, but it's not really necessary at this point.
             return Ok(());
Diff in /app/src/sliding_sync.rs:2821:
         }
         RoomState::Invited => {
             let invite_details = new_room.room.invite_details().await.ok();
[31m-            let room_name_id = RoomNameId::from((new_room.display_name.clone(), new_room.room_id.clone()));
[m[32m+            let room_name_id =
[m[32m+                RoomNameId::from((new_room.display_name.clone(), new_room.room_id.clone()));
[m             let room_avatar = room_avatar(&new_room.room, &room_name_id).await;
             let inviter_info = if let Some(inviter) = invite_details.and_then(|d| d.inviter) {
                 Some(InviterInfo {
Diff in /app/src/sliding_sync.rs:2837:
             } else {
                 None
             };
[31m-            rooms_list::enqueue_rooms_list_update(RoomsListUpdate::AddInvitedRoom(InvitedRoomInfo {
[m[31m-                room_name_id: room_name_id.clone(),
[m[31m-                inviter_info,
[m[31m-                room_avatar,
[m[31m-                canonical_alias: new_room.room.canonical_alias(),
[m[31m-                alt_aliases: new_room.room.alt_aliases(),
[m[31m-                // we don't actually display the latest event for Invited rooms, so don't bother.
[m[31m-                latest: None,
[m[31m-                invite_state: Default::default(),
[m[31m-                is_selected: false,
[m[31m-                is_direct: new_room.is_direct,
[m[31m-            }));
[m[32m+            rooms_list::enqueue_rooms_list_update(RoomsListUpdate::AddInvitedRoom(
[m[32m+                InvitedRoomInfo {
[m[32m+                    room_name_id: room_name_id.clone(),
[m[32m+                    inviter_info,
[m[32m+                    room_avatar,
[m[32m+                    canonical_alias: new_room.room.canonical_alias(),
[m[32m+                    alt_aliases: new_room.room.alt_aliases(),
[m[32m+                    // we don't actually display the latest event for Invited rooms, so don't bother.
[m[32m+                    latest: None,
[m[32m+                    invite_state: Default::default(),
[m[32m+                    is_selected: false,
[m[32m+                    is_direct: new_room.is_direct,
[m[32m+                },
[m[32m+            ));
[m             Cx::post_action(AppStateAction::RoomLoadedSuccessfully {
                 room_name_id,
                 is_invite: true,
Diff in /app/src/sliding_sync.rs:2855:
             });
             return Ok(());
         }
[31m-        RoomState::Joined => { } // Fall through to adding the joined room below.
[m[32m+        RoomState::Joined => {} // Fall through to adding the joined room below.
[m     }

     // If we didn't already subscribe to this room, do so now.
Diff in /app/src/sliding_sync.rs:2862:
     // This ensures we will properly receive all of its states and latest event.
     if subscribe {
[31m-        room_list_service.subscribe_to_rooms(&[&new_room.room_id]).await;
[m[32m+        room_list_service
[m[32m+            .subscribe_to_rooms(&[&new_room.room_id])
[m[32m+            .await;
[m     }

     let timeline = Arc::new(
Diff in /app/src/sliding_sync.rs:2868:
[31m-        new_room.room.timeline_builder()
[m[32m+        new_room
[m[32m+            .room
[m[32m+            .timeline_builder()
[m             .track_read_marker_and_receipts(TimelineReadReceiptTracking::AllEvents)
             .build()
             .await
Diff in /app/src/sliding_sync.rs:2872:
[31m-            .map_err(|e| anyhow::anyhow!("BUG: Failed to build timeline for room {}: {e}", new_room.room_id))?,
[m[32m+            .map_err(|e| {
[m[32m+                anyhow::anyhow!(
[m[32m+                    "BUG: Failed to build timeline for room {}: {e}",
[m[32m+                    new_room.room_id
[m[32m+                )
[m[32m+            })?,
[m     );
     let (timeline_update_sender, timeline_update_receiver) = crossbeam_channel::unbounded();

Diff in /app/src/sliding_sync.rs:2884:
     // We need to add the room to the `ALL_JOINED_ROOMS` list before we can send
     // an `AddJoinedRoom` update to the RoomsList widget, because that widget might
     // immediately issue a `MatrixRequest` that relies on that room being in `ALL_JOINED_ROOMS`.
[31m-    log!("Adding new joined room {}, name: {:?}", new_room.room_id, new_room.display_name);
[m[32m+    log!(
[m[32m+        "Adding new joined room {}, name: {:?}",
[m[32m+        new_room.room_id,
[m[32m+        new_room.display_name
[m[32m+    );
[m     ALL_JOINED_ROOMS.lock().unwrap().insert(
         new_room.room_id.clone(),
         JoinedRoomDetails {
Diff in /app/src/sliding_sync.rs:2901:
     let latest = get_latest_event_details(
         &new_room.room.latest_event().await,
         room_list_service.client(),
[31m-    ).await;
[m[32m+    )
[m[32m+    .await;
[m     let room_name_id = RoomNameId::from((new_room.display_name.clone(), new_room.room_id.clone()));
     // Start with a basic text avatar; the avatar image will be fetched asynchronously below.
     let room_avatar = avatar_from_room_name(room_name_id.name_for_avatar().as_deref());
Diff in /app/src/sliding_sync.rs:2932:
 #[allow(unused)]
 async fn current_ignore_user_list(client: &Client) -> Option<HashSet<OwnedUserId>> {
     use matrix_sdk::ruma::events::ignored_user_list::IgnoredUserListEventContent;
[31m-    let ignored_users = client.account()
[m[32m+    let ignored_users = client
[m[32m+        .account()
[m         .account_data::<IgnoredUserListEventContent>()
         .await
         .ok()??
Diff in /app/src/sliding_sync.rs:2994:
                     && !app_state.saved_dock_state_home.dock_items.is_empty()
                 {
                     log!("Loaded room panel state from app data directory. Restoring now...");
[31m-                    Cx::post_action(AppStateAction::RestoreAppStateFromPersistentState(app_state));
[m[32m+                    Cx::post_action(AppStateAction::RestoreAppStateFromPersistentState(
[m[32m+                        app_state,
[m[32m+                    ));
[m                 }
             }
             Err(_e) => {
Diff in /app/src/sliding_sync.rs:3038:
     const SYNC_INDICATOR_DELAY: Duration = Duration::from_millis(100);
     /// Duration for sync indicator delay before hiding
     const SYNC_INDICATOR_HIDE_DELAY: Duration = Duration::from_millis(200);
[31m-    let sync_indicator_stream = sync_service.room_list_service()
[m[31m-        .sync_indicator(
[m[31m-            SYNC_INDICATOR_DELAY,
[m[31m-            SYNC_INDICATOR_HIDE_DELAY
[m[31m-        );
[m[31m-
[m[32m+    let sync_indicator_stream = sync_service
[m[32m+        .room_list_service()
[m[32m+        .sync_indicator(SYNC_INDICATOR_DELAY, SYNC_INDICATOR_HIDE_DELAY);
[m[32m+
[m     Handle::current().spawn(async move {
[31m-       let mut sync_indicator_stream = std::pin::pin!(sync_indicator_stream);
[m[32m+        let mut sync_indicator_stream = std::pin::pin!(sync_indicator_stream);
[m
         while let Some(indicator) = sync_indicator_stream.next().await {
             let is_syncing = match indicator {
Diff in /app/src/sliding_sync.rs:3058:
 }

 fn handle_room_list_service_loading_state(mut loading_state: Subscriber<RoomListLoadingState>) {
[31m-    log!("Initial room list loading state is {:?}", loading_state.get());
[m[32m+    log!(
[m[32m+        "Initial room list loading state is {:?}",
[m[32m+        loading_state.get()
[m[32m+    );
[m     Handle::current().spawn(async move {
         while let Some(state) = loading_state.next().await {
             log!("Received a room list loading state update: {state:?}");
Diff in /app/src/sliding_sync.rs:3066:
                 RoomListLoadingState::NotLoaded => {
                     enqueue_rooms_list_update(RoomsListUpdate::NotLoaded);
                 }
[31m-                RoomListLoadingState::Loaded { maximum_number_of_rooms } => {
[m[31m-                    enqueue_rooms_list_update(RoomsListUpdate::LoadedRooms { max_rooms: maximum_number_of_rooms });
[m[32m+                RoomListLoadingState::Loaded {
[m[32m+                    maximum_number_of_rooms,
[m[32m+                } => {
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::LoadedRooms {
[m[32m+                        max_rooms: maximum_number_of_rooms,
[m[32m+                    });
[m                     // The SDK docs state that we cannot move from the `Loaded` state
                     // back to the `NotLoaded` state, so we can safely exit this task here.
                     return;
Diff in /app/src/sliding_sync.rs:3090:
     Handle::current().spawn(async move {
         log!("Updating room {tombstoned_room_id} to be tombstoned, {successor_room:?}");
         let srd = if let Some(SuccessorRoom { room_id, reason }) = successor_room {
[31m-            match fetch_room_preview_with_avatar(
[m[31m-                &client,
[m[31m-                room_id.deref().into(),
[m[31m-                Vec::new(),
[m[31m-            ).await {
[m[31m-                Ok(room_preview) => SuccessorRoomDetails::Full { room_preview, reason },
[m[32m+            match fetch_room_preview_with_avatar(&client, room_id.deref().into(), Vec::new()).await
[m[32m+            {
[m[32m+                Ok(room_preview) => SuccessorRoomDetails::Full {
[m[32m+                    room_preview,
[m[32m+                    reason,
[m[32m+                },
[m                 Err(e) => {
                     log!("Failed to fetch preview of successor room {room_id}, error: {e:?}");
                     SuccessorRoomDetails::Basic(SuccessorRoom { room_id, reason })
Diff in /app/src/sliding_sync.rs:3129:
         };
         match client.media().get_media_content(&media_request, true).await {
             Ok(avatar_content) => {
[31m-                log!("Fetched avatar for room preview {:?} ({})", room_preview.name, room_preview.room_id);
[m[32m+                log!(
[m[32m+                    "Fetched avatar for room preview {:?} ({})",
[m[32m+                    room_preview.name,
[m[32m+                    room_preview.room_id
[m[32m+                );
[m                 FetchedRoomAvatar::Image(avatar_content.into())
             }
             Err(e) => {
Diff in /app/src/sliding_sync.rs:3136:
[31m-                log!("Failed to fetch avatar for room preview {:?} ({}), error: {e:?}",
[m[31m-                    room_preview.name, room_preview.room_id
[m[32m+                log!(
[m[32m+                    "Failed to fetch avatar for room preview {:?} ({}), error: {e:?}",
[m[32m+                    room_preview.name,
[m[32m+                    room_preview.room_id
[m                 );
                 avatar_from_room_name(room_preview.name.as_deref())
             }
Diff in /app/src/sliding_sync.rs:3146:
     Ok(FetchedRoomPreview::from(room_preview, room_avatar))
 }

[31m-
[m /// Returns the timestamp and an HTML-formatted text preview of the given `latest_event`.
 ///
 /// If the sender profile of the event is not yet available, this function will
Diff in /app/src/sliding_sync.rs:3170:

     match latest_event_value {
         LatestEventValue::None => None,
[31m-        LatestEventValue::Remote { timestamp, sender, is_own, profile, content } => {
[m[32m+        LatestEventValue::Remote {
[m[32m+            timestamp,
[m[32m+            sender,
[m[32m+            is_own,
[m[32m+            profile,
[m[32m+            content,
[m[32m+        } => {
[m             let sender_username = get_sender_username!(profile, sender, *is_own);
[31m-            let latest_message_text = text_preview_of_timeline_item(
[m[31m-                content,
[m[31m-                sender,
[m[31m-                &sender_username,
[m[31m-            ).format_with(&sender_username, true);
[m[32m+            let latest_message_text =
[m[32m+                text_preview_of_timeline_item(content, sender, &sender_username)
[m[32m+                    .format_with(&sender_username, true);
[m             Some((*timestamp, latest_message_text))
         }
[31m-        LatestEventValue::Local { timestamp, sender, profile, content, state: _ } => {
[m[32m+        LatestEventValue::Local {
[m[32m+            timestamp,
[m[32m+            sender,
[m[32m+            profile,
[m[32m+            content,
[m[32m+            state: _,
[m[32m+        } => {
[m             // TODO: use the `state` enum to augment the preview text with more details.
             //       Example: "<span color="blue">Sending... {msg}</span>" or
             //                "<span color="red">Failed to send {msg}</span>"
Diff in /app/src/sliding_sync.rs:3186:
             let is_own = current_user_id().is_some_and(|id| &id == sender);
             let sender_username = get_sender_username!(profile, sender, is_own);
[31m-            let latest_message_text = text_preview_of_timeline_item(
[m[31m-                content,
[m[31m-                sender,
[m[31m-                &sender_username,
[m[31m-            ).format_with(&sender_username, true);
[m[32m+            let latest_message_text =
[m[32m+                text_preview_of_timeline_item(content, sender, &sender_username)
[m[32m+                    .format_with(&sender_username, true);
[m             Some((*timestamp, latest_message_text))
         }
[31m-    }
[m[32m+    }
[m }

 /// Handles the given updated latest event for the given room.
Diff in /app/src/sliding_sync.rs:3200:
 /// This function sends a `RoomsListUpdate::UpdateLatestEvent`
 /// to update the latest event in the RoomsListEntry for the given room.
 async fn update_latest_event(room: &Room) {
[31m-    if let Some((timestamp, latest_message_text)) = get_latest_event_details(
[m[31m-        &room.latest_event().await,
[m[31m-        &room.client(),
[m[31m-    ).await {
[m[32m+    if let Some((timestamp, latest_message_text)) =
[m[32m+        get_latest_event_details(&room.latest_event().await, &room.client()).await
[m[32m+    {
[m         enqueue_rooms_list_update(RoomsListUpdate::UpdateLatestEvent {
             room_id: room.room_id().to_owned(),
             timestamp,
Diff in /app/src/sliding_sync.rs:3238:
     timeline_update_sender: crossbeam_channel::Sender<TimelineUpdate>,
     mut request_receiver: watch::Receiver<Vec<BackwardsPaginateUntilEventRequest>>,
 ) {
[31m-
[m     /// An inner function that searches the given new timeline items for a target event.
     ///
     /// If the target event is found, it is removed from the `target_event_id_opt` and returned,
Diff in /app/src/sliding_sync.rs:3247:
         target_event_id_opt: &mut Option<OwnedEventId>,
         mut new_items_iter: impl Iterator<Item = &'a Arc<TimelineItem>>,
     ) -> Option<(usize, OwnedEventId)> {
[31m-        let found_index = target_event_id_opt
[m[31m-            .as_ref()
[m[31m-            .and_then(|target_event_id| new_items_iter
[m[31m-                .position(|new_item| new_item
[m[32m+        let found_index = target_event_id_opt.as_ref().and_then(|target_event_id| {
[m[32m+            new_items_iter.position(|new_item| {
[m[32m+                new_item
[m                     .as_event()
                     .is_some_and(|new_ev| new_ev.event_id() == Some(target_event_id))
[31m-                )
[m[31m-            );
[m[32m+            })
[m[32m+        });
[m
         if let Some(index) = found_index {
             target_event_id_opt.take().map(|ev| (index, ev))
Diff in /app/src/sliding_sync.rs:3263:
         }
     }

[31m-
[m     let room_id = room.room_id().to_owned();
     log!("Starting timeline subscriber for room {room_id}...");
     let (mut timeline_items, mut subscriber) = timeline.subscribe().await;
Diff in /app/src/sliding_sync.rs:3270:
[31m-    log!("Received initial timeline update of {} items for room {room_id}.", timeline_items.len());
[m[32m+    log!(
[m[32m+        "Received initial timeline update of {} items for room {room_id}.",
[m[32m+        timeline_items.len()
[m[32m+    );
[m
     timeline_update_sender.send(TimelineUpdate::FirstUpdate {
         initial_items: timeline_items.clone(),
Diff in /app/src/sliding_sync.rs:3280:
     // the timeline index and event ID of the target event, if it has been found.
     let mut found_target_event_id: Option<(usize, OwnedEventId)> = None;

[31m-    loop { tokio::select! {
[m[31m-        // we should check for new requests before handling new timeline updates,
[m[31m-        // because the request might influence how we handle a timeline update.
[m[31m-        biased;
[m[32m+    loop {
[m[32m+        tokio::select! {
[m[32m+            // we should check for new requests before handling new timeline updates,
[m[32m+            // because the request might influence how we handle a timeline update.
[m[32m+            biased;
[m
[31m-        // Handle updates to the current backwards pagination requests.
[m[31m-        Ok(()) = request_receiver.changed() => {
[m[31m-            let prev_target_event_id = target_event_id.clone();
[m[31m-            let new_request_details = request_receiver
[m[31m-                .borrow_and_update()
[m[31m-                .iter()
[m[31m-                .find_map(|req| req.room_id
[m[31m-                    .eq(&room_id)
[m[31m-                    .then(|| (req.target_event_id.clone(), req.starting_index, req.current_tl_len))
[m[31m-                );
[m[32m+            // Handle updates to the current backwards pagination requests.
[m[32m+            Ok(()) = request_receiver.changed() => {
[m[32m+                let prev_target_event_id = target_event_id.clone();
[m[32m+                let new_request_details = request_receiver
[m[32m+                    .borrow_and_update()
[m[32m+                    .iter()
[m[32m+                    .find_map(|req| req.room_id
[m[32m+                        .eq(&room_id)
[m[32m+                        .then(|| (req.target_event_id.clone(), req.starting_index, req.current_tl_len))
[m[32m+                    );
[m
[31m-            target_event_id = new_request_details.as_ref().map(|(ev, ..)| ev.clone());
[m[32m+                target_event_id = new_request_details.as_ref().map(|(ev, ..)| ev.clone());
[m
[31m-            // If we received a new request, start searching backwards for the target event.
[m[31m-            if let Some((new_target_event_id, starting_index, current_tl_len)) = new_request_details {
[m[31m-                if prev_target_event_id.as_ref() != Some(&new_target_event_id) {
[m[31m-                    let starting_index = if current_tl_len == timeline_items.len() {
[m[31m-                        starting_index
[m[31m-                    } else {
[m[31m-                        // The timeline has changed since the request was made, so we can't rely on the `starting_index`.
[m[31m-                        // Instead, we have no choice but to start from the end of the timeline.
[m[31m-                        timeline_items.len()
[m[31m-                    };
[m[31m-                    // log!("Received new request to search for event {new_target_event_id} in room {room_id} starting from index {starting_index} (tl len {}).", timeline_items.len());
[m[31m-                    // Search backwards for the target event in the timeline, starting from the given index.
[m[31m-                    if let Some(target_event_tl_index) = timeline_items
[m[31m-                        .focus()
[m[31m-                        .narrow(..starting_index)
[m[31m-                        .into_iter()
[m[31m-                        .rev()
[m[31m-                        .position(|i| i.as_event()
[m[31m-                            .and_then(|e| e.event_id())
[m[31m-                            .is_some_and(|ev_id| ev_id == new_target_event_id)
[m[31m-                        )
[m[31m-                        .map(|i| starting_index.saturating_sub(i).saturating_sub(1))
[m[31m-                    {
[m[31m-                        // log!("Found existing target event {new_target_event_id} in room {room_id} at index {target_event_tl_index}.");
[m[32m+                // If we received a new request, start searching backwards for the target event.
[m[32m+                if let Some((new_target_event_id, starting_index, current_tl_len)) = new_request_details {
[m[32m+                    if prev_target_event_id.as_ref() != Some(&new_target_event_id) {
[m[32m+                        let starting_index = if current_tl_len == timeline_items.len() {
[m[32m+                            starting_index
[m[32m+                        } else {
[m[32m+                            // The timeline has changed since the request was made, so we can't rely on the `starting_index`.
[m[32m+                            // Instead, we have no choice but to start from the end of the timeline.
[m[32m+                            timeline_items.len()
[m[32m+                        };
[m[32m+                        // log!("Received new request to search for event {new_target_event_id} in room {room_id} starting from index {starting_index} (tl len {}).", timeline_items.len());
[m[32m+                        // Search backwards for the target event in the timeline, starting from the given index.
[m[32m+                        if let Some(target_event_tl_index) = timeline_items
[m[32m+                            .focus()
[m[32m+                            .narrow(..starting_index)
[m[32m+                            .into_iter()
[m[32m+                            .rev()
[m[32m+                            .position(|i| i.as_event()
[m[32m+                                .and_then(|e| e.event_id())
[m[32m+                                .is_some_and(|ev_id| ev_id == new_target_event_id)
[m[32m+                            )
[m[32m+                            .map(|i| starting_index.saturating_sub(i).saturating_sub(1))
[m[32m+                        {
[m[32m+                            // log!("Found existing target event {new_target_event_id} in room {room_id} at index {target_event_tl_index}.");
[m
[31m-                        // Nice! We found the target event in the current timeline items,
[m[31m-                        // so there's no need to actually proceed with backwards pagination;
[m[31m-                        // thus, we can clear the locally-tracked target event ID.
[m[31m-                        target_event_id = None;
[m[31m-                        found_target_event_id = None;
[m[31m-                        timeline_update_sender.send(
[m[31m-                            TimelineUpdate::TargetEventFound {
[m[31m-                                target_event_id: new_target_event_id.clone(),
[m[31m-                                index: target_event_tl_index,
[m[31m-                            }
[m[31m-                        ).unwrap_or_else(
[m[31m-                            |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({new_target_event_id}, {target_event_tl_index}) to room {room_id}!")
[m[31m-                        );
[m[31m-                        // Send a Makepad-level signal to update this room's timeline UI view.
[m[31m-                        SignalToUI::set_ui_signal();
[m[32m+                            // Nice! We found the target event in the current timeline items,
[m[32m+                            // so there's no need to actually proceed with backwards pagination;
[m[32m+                            // thus, we can clear the locally-tracked target event ID.
[m[32m+                            target_event_id = None;
[m[32m+                            found_target_event_id = None;
[m[32m+                            timeline_update_sender.send(
[m[32m+                                TimelineUpdate::TargetEventFound {
[m[32m+                                    target_event_id: new_target_event_id.clone(),
[m[32m+                                    index: target_event_tl_index,
[m[32m+                                }
[m[32m+                            ).unwrap_or_else(
[m[32m+                                |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({new_target_event_id}, {target_event_tl_index}) to room {room_id}!")
[m[32m+                            );
[m[32m+                            // Send a Makepad-level signal to update this room's timeline UI view.
[m[32m+                            SignalToUI::set_ui_signal();
[m[32m+                        }
[m[32m+                        else {
[m[32m+                            log!("Target event not in timeline. Starting backwards pagination \
[m[32m+                                in room {room_id} to find target event {new_target_event_id} \
[m[32m+                                starting from index {starting_index}.",
[m[32m+                            );
[m[32m+                            // If we didn't find the target event in the current timeline items,
[m[32m+                            // we need to start loading previous items into the timeline.
[m[32m+                            submit_async_request(MatrixRequest::PaginateRoomTimeline {
[m[32m+                                room_id: room_id.clone(),
[m[32m+                                num_events: 50,
[m[32m+                                direction: PaginationDirection::Backwards,
[m[32m+                            });
[m[32m+                        }
[m                     }
[31m-                    else {
[m[31m-                        log!("Target event not in timeline. Starting backwards pagination \
[m[31m-                            in room {room_id} to find target event {new_target_event_id} \
[m[31m-                            starting from index {starting_index}.",
[m[31m-                        );
[m[31m-                        // If we didn't find the target event in the current timeline items,
[m[31m-                        // we need to start loading previous items into the timeline.
[m[31m-                        submit_async_request(MatrixRequest::PaginateRoomTimeline {
[m[31m-                            room_id: room_id.clone(),
[m[31m-                            num_events: 50,
[m[31m-                            direction: PaginationDirection::Backwards,
[m[31m-                        });
[m[31m-                    }
[m                 }
             }
[31m-        }
[m
[31m-        // Handle updates to the actual timeline content.
[m[31m-        batch_opt = subscriber.next() => {
[m[31m-            let Some(batch) = batch_opt else { break };
[m[31m-            let mut num_updates = 0;
[m[31m-            let mut index_of_first_change = usize::MAX;
[m[31m-            let mut index_of_last_change = usize::MIN;
[m[31m-            // whether to clear the entire cache of drawn items
[m[31m-            let mut clear_cache = false;
[m[31m-            // whether the changes include items being appended to the end of the timeline
[m[31m-            let mut is_append = false;
[m[31m-            for diff in batch {
[m[31m-                num_updates += 1;
[m[31m-                match diff {
[m[31m-                    VectorDiff::Append { values } => {
[m[31m-                        let _values_len = values.len();
[m[31m-                        index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[31m-                        timeline_items.extend(values);
[m[31m-                        index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Append {_values_len}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                        is_append = true;
[m[31m-                    }
[m[31m-                    VectorDiff::Clear => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Clear"); }
[m[31m-                        clear_cache = true;
[m[31m-                        timeline_items.clear();
[m[31m-                    }
[m[31m-                    VectorDiff::PushFront { value } => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushFront"); }
[m[31m-                        if let Some((index, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            *index += 1; // account for this new `value` being prepended.
[m[31m-                        } else {
[m[31m-                            found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value));
[m[32m+            // Handle updates to the actual timeline content.
[m[32m+            batch_opt = subscriber.next() => {
[m[32m+                let Some(batch) = batch_opt else { break };
[m[32m+                let mut num_updates = 0;
[m[32m+                let mut index_of_first_change = usize::MAX;
[m[32m+                let mut index_of_last_change = usize::MIN;
[m[32m+                // whether to clear the entire cache of drawn items
[m[32m+                let mut clear_cache = false;
[m[32m+                // whether the changes include items being appended to the end of the timeline
[m[32m+                let mut is_append = false;
[m[32m+                for diff in batch {
[m[32m+                    num_updates += 1;
[m[32m+                    match diff {
[m[32m+                        VectorDiff::Append { values } => {
[m[32m+                            let _values_len = values.len();
[m[32m+                            index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[32m+                            timeline_items.extend(values);
[m[32m+                            index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Append {_values_len}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                            is_append = true;
[m                         }
[31m-
[m[31m-                        clear_cache = true;
[m[31m-                        timeline_items.push_front(value);
[m[31m-                    }
[m[31m-                    VectorDiff::PushBack { value } => {
[m[31m-                        index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[31m-                        timeline_items.push_back(value);
[m[31m-                        index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                        is_append = true;
[m[31m-                    }
[m[31m-                    VectorDiff::PopFront => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopFront"); }
[m[31m-                        clear_cache = true;
[m[31m-                        timeline_items.pop_front();
[m[31m-                        if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            *i = i.saturating_sub(1); // account for the first item being removed.
[m[32m+                        VectorDiff::Clear => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Clear"); }
[m[32m+                            clear_cache = true;
[m[32m+                            timeline_items.clear();
[m                         }
[31m-                        // This doesn't affect whether we should reobtain the latest event.
[m[31m-                    }
[m[31m-                    VectorDiff::PopBack => {
[m[31m-                        timeline_items.pop_back();
[m[31m-                        index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[31m-                        index_of_last_change = usize::MAX;
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Insert { index, value } => {
[m[31m-                        if index == 0 {
[m[32m+                        VectorDiff::PushFront { value } => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushFront"); }
[m[32m+                            if let Some((index, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                *index += 1; // account for this new `value` being prepended.
[m[32m+                            } else {
[m[32m+                                found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value));
[m[32m+                            }
[m[32m+
[m                             clear_cache = true;
[31m-                        } else {
[m[31m-                            index_of_first_change = min(index_of_first_change, index);
[m[31m-                            index_of_last_change = usize::MAX;
[m[32m+                            timeline_items.push_front(value);
[m                         }
[31m-                        if index >= timeline_items.len() {
[m[32m+                        VectorDiff::PushBack { value } => {
[m[32m+                            index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[32m+                            timeline_items.push_back(value);
[m[32m+                            index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                             is_append = true;
                         }
[31m-
[m[31m-                        if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            // account for this new `value` being inserted before the previously-found target event's index.
[m[31m-                            if index <= *i {
[m[31m-                                *i += 1;
[m[32m+                        VectorDiff::PopFront => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopFront"); }
[m[32m+                            clear_cache = true;
[m[32m+                            timeline_items.pop_front();
[m[32m+                            if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                *i = i.saturating_sub(1); // account for the first item being removed.
[m                             }
[31m-                        } else {
[m[31m-                            found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value))
[m[31m-                                .map(|(i, ev)| (i + index, ev));
[m[32m+                            // This doesn't affect whether we should reobtain the latest event.
[m                         }
[31m-
[m[31m-                        timeline_items.insert(index, value);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Insert at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Set { index, value } => {
[m[31m-                        index_of_first_change = min(index_of_first_change, index);
[m[31m-                        index_of_last_change  = max(index_of_last_change, index.saturating_add(1));
[m[31m-                        timeline_items.set(index, value);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Set at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Remove { index } => {
[m[31m-                        if index == 0 {
[m[31m-                            clear_cache = true;
[m[31m-                        } else {
[m[31m-                            index_of_first_change = min(index_of_first_change, index.saturating_sub(1));
[m[32m+                        VectorDiff::PopBack => {
[m[32m+                            timeline_items.pop_back();
[m[32m+                            index_of_first_change = min(index_of_first_change, timeline_items.len());
[m                             index_of_last_change = usize::MAX;
[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                         }
[31m-                        if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            // account for an item being removed before the previously-found target event's index.
[m[31m-                            if index <= *i {
[m[31m-                                *i = i.saturating_sub(1);
[m[32m+                        VectorDiff::Insert { index, value } => {
[m[32m+                            if index == 0 {
[m[32m+                                clear_cache = true;
[m[32m+                            } else {
[m[32m+                                index_of_first_change = min(index_of_first_change, index);
[m[32m+                                index_of_last_change = usize::MAX;
[m                             }
[32m+                            if index >= timeline_items.len() {
[m[32m+                                is_append = true;
[m[32m+                            }
[m[32m+
[m[32m+                            if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                // account for this new `value` being inserted before the previously-found target event's index.
[m[32m+                                if index <= *i {
[m[32m+                                    *i += 1;
[m[32m+                                }
[m[32m+                            } else {
[m[32m+                                found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value))
[m[32m+                                    .map(|(i, ev)| (i + index, ev));
[m[32m+                            }
[m[32m+
[m[32m+                            timeline_items.insert(index, value);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Insert at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                         }
[31m-                        timeline_items.remove(index);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Remove at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Truncate { length } => {
[m[31m-                        if length == 0 {
[m[31m-                            clear_cache = true;
[m[31m-                        } else {
[m[31m-                            index_of_first_change = min(index_of_first_change, length.saturating_sub(1));
[m[31m-                            index_of_last_change = usize::MAX;
[m[32m+                        VectorDiff::Set { index, value } => {
[m[32m+                            index_of_first_change = min(index_of_first_change, index);
[m[32m+                            index_of_last_change  = max(index_of_last_change, index.saturating_add(1));
[m[32m+                            timeline_items.set(index, value);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Set at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                         }
[31m-                        timeline_items.truncate(length);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Truncate to length {length}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                        VectorDiff::Remove { index } => {
[m[32m+                            if index == 0 {
[m[32m+                                clear_cache = true;
[m[32m+                            } else {
[m[32m+                                index_of_first_change = min(index_of_first_change, index.saturating_sub(1));
[m[32m+                                index_of_last_change = usize::MAX;
[m[32m+                            }
[m[32m+                            if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                // account for an item being removed before the previously-found target event's index.
[m[32m+                                if index <= *i {
[m[32m+                                    *i = i.saturating_sub(1);
[m[32m+                                }
[m[32m+                            }
[m[32m+                            timeline_items.remove(index);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Remove at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                        }
[m[32m+                        VectorDiff::Truncate { length } => {
[m[32m+                            if length == 0 {
[m[32m+                                clear_cache = true;
[m[32m+                            } else {
[m[32m+                                index_of_first_change = min(index_of_first_change, length.saturating_sub(1));
[m[32m+                                index_of_last_change = usize::MAX;
[m[32m+                            }
[m[32m+                            timeline_items.truncate(length);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Truncate to length {length}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                        }
[m[32m+                        VectorDiff::Reset { values } => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Reset, new length {}", values.len()); }
[m[32m+                            clear_cache = true; // we must assume all items have changed.
[m[32m+                            timeline_items = values;
[m[32m+                        }
[m                     }
[31m-                    VectorDiff::Reset { values } => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Reset, new length {}", values.len()); }
[m[31m-                        clear_cache = true; // we must assume all items have changed.
[m[31m-                        timeline_items = values;
[m[31m-                    }
[m                 }
[31m-            }
[m

[31m-            if num_updates > 0 {
[m[31m-                // Handle the case where back pagination inserts items at the beginning of the timeline
[m[31m-                // (meaning the entire timeline needs to be re-drawn),
[m[31m-                // but there is a virtual event at index 0 (e.g., a day divider).
[m[31m-                // When that happens, we want the RoomScreen to treat this as if *all* events changed.
[m[31m-                if index_of_first_change == 1 && timeline_items.front().and_then(|item| item.as_virtual()).is_some() {
[m[31m-                    index_of_first_change = 0;
[m[31m-                    clear_cache = true;
[m[31m-                }
[m[32m+                if num_updates > 0 {
[m[32m+                    // Handle the case where back pagination inserts items at the beginning of the timeline
[m[32m+                    // (meaning the entire timeline needs to be re-drawn),
[m[32m+                    // but there is a virtual event at index 0 (e.g., a day divider).
[m[32m+                    // When that happens, we want the RoomScreen to treat this as if *all* events changed.
[m[32m+                    if index_of_first_change == 1 && timeline_items.front().and_then(|item| item.as_virtual()).is_some() {
[m[32m+                        index_of_first_change = 0;
[m[32m+                        clear_cache = true;
[m[32m+                    }
[m
[31m-                let changed_indices = index_of_first_change..index_of_last_change;
[m[32m+                    let changed_indices = index_of_first_change..index_of_last_change;
[m
[31m-                if LOG_TIMELINE_DIFFS {
[m[31m-                    log!("timeline_subscriber: applied {num_updates} updates for room {room_id}, timeline now has {} items. is_append? {is_append}, clear_cache? {clear_cache}. Changes: {changed_indices:?}.", timeline_items.len());
[m[31m-                }
[m[31m-                timeline_update_sender.send(TimelineUpdate::NewItems {
[m[31m-                    new_items: timeline_items.clone(),
[m[31m-                    changed_indices,
[m[31m-                    clear_cache,
[m[31m-                    is_append,
[m[31m-                }).expect("Error: timeline update sender couldn't send update with new items!");
[m[32m+                    if LOG_TIMELINE_DIFFS {
[m[32m+                        log!("timeline_subscriber: applied {num_updates} updates for room {room_id}, timeline now has {} items. is_append? {is_append}, clear_cache? {clear_cache}. Changes: {changed_indices:?}.", timeline_items.len());
[m[32m+                    }
[m[32m+                    timeline_update_sender.send(TimelineUpdate::NewItems {
[m[32m+                        new_items: timeline_items.clone(),
[m[32m+                        changed_indices,
[m[32m+                        clear_cache,
[m[32m+                        is_append,
[m[32m+                    }).expect("Error: timeline update sender couldn't send update with new items!");
[m
[31m-                // We must send this update *after* the actual NewItems update,
[m[31m-                // otherwise the UI thread (RoomScreen) won't be able to correctly locate the target event.
[m[31m-                if let Some((index, found_event_id)) = found_target_event_id.take() {
[m[31m-                    target_event_id = None;
[m[31m-                    timeline_update_sender.send(
[m[31m-                        TimelineUpdate::TargetEventFound {
[m[31m-                            target_event_id: found_event_id.clone(),
[m[31m-                            index,
[m[31m-                        }
[m[31m-                    ).unwrap_or_else(
[m[31m-                        |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({found_event_id}, {index}) to room {room_id}!")
[m[31m-                    );
[m[32m+                    // We must send this update *after* the actual NewItems update,
[m[32m+                    // otherwise the UI thread (RoomScreen) won't be able to correctly locate the target event.
[m[32m+                    if let Some((index, found_event_id)) = found_target_event_id.take() {
[m[32m+                        target_event_id = None;
[m[32m+                        timeline_update_sender.send(
[m[32m+                            TimelineUpdate::TargetEventFound {
[m[32m+                                target_event_id: found_event_id.clone(),
[m[32m+                                index,
[m[32m+                            }
[m[32m+                        ).unwrap_or_else(
[m[32m+                            |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({found_event_id}, {index}) to room {room_id}!")
[m[32m+                        );
[m[32m+                    }
[m[32m+
[m[32m+                    // Send a Makepad-level signal to update this room's timeline UI view.
[m[32m+                    SignalToUI::set_ui_signal();
[m                 }
[32m+            }
[m
[31m-                // Send a Makepad-level signal to update this room's timeline UI view.
[m[31m-                SignalToUI::set_ui_signal();
[m[32m+            else => {
[m[32m+                break;
[m             }
         }
[32m+    }
[m
[31m-        else => {
[m[31m-            break;
[m[31m-        }
[m[31m-    } }
[m[31m-
[m     error!("Error: unexpectedly ended timeline subscriber for room {room_id}.");
 }

Diff in /app/src/sliding_sync.rs:3551:
         _ => {
             if let Ok(room_members) = room.members(RoomMemberships::ACTIVE).await {
                 if room_members.len() == 2 {
[31m-                    if let Some(non_account_member) = room_members.iter().find(|m| !m.is_account_user()) {
[m[31m-                        if let Ok(Some(avatar)) = non_account_member.avatar(AVATAR_THUMBNAIL_FORMAT.into()).await {
[m[32m+                    if let Some(non_account_member) =
[m[32m+                        room_members.iter().find(|m| !m.is_account_user())
[m[32m+                    {
[m[32m+                        if let Ok(Some(avatar)) = non_account_member
[m[32m+                            .avatar(AVATAR_THUMBNAIL_FORMAT.into())
[m[32m+                            .await
[m[32m+                        {
[m                             return FetchedRoomAvatar::Image(avatar.into());
                         }
                     }
Diff in /app/src/sliding_sync.rs:3581:
     // Post a status update to inform the user that we're waiting for the client to be built.
     Cx::post_action(LoginAction::Status {
         title: "Initializing client...".into(),
[31m-        status: "Please wait while Matrix builds and configures the client object for login.".into(),
[m[32m+        status: "Please wait while Matrix builds and configures the client object for login."
[m[32m+            .into(),
[m     });

     // Wait for the notification that the client has been built
Diff in /app/src/sliding_sync.rs:3602:
         // or if the homeserver_url is *not* empty and isn't the default,
         // we cannot use the DEFAULT_SSO_CLIENT, so we must build a new one.
         let mut build_client_error = None;
[31m-        if client_and_session.is_none() || (
[m[31m-            !homeserver_url.is_empty()
[m[32m+        if client_and_session.is_none()
[m[32m+            || (!homeserver_url.is_empty()
[m                 && homeserver_url != "matrix.org"
                 && Url::parse(&homeserver_url) != Url::parse("https://matrix-client.matrix.org/")
[31m-                && Url::parse(&homeserver_url) != Url::parse("https://matrix.org/")
[m[31m-        ) {
[m[32m+                && Url::parse(&homeserver_url) != Url::parse("https://matrix.org/"))
[m[32m+        {
[m             match build_client(
                 &Cli {
                     homeserver: homeserver_url.is_empty().not().then_some(homeserver_url),
Diff in /app/src/sliding_sync.rs:3614:
                     ..Default::default()
                 },
                 app_data_dir(),
[31m-            ).await {
[m[32m+            )
[m[32m+            .await
[m[32m+            {
[m                 Ok(success) => client_and_session = Some(success),
                 Err(e) => build_client_error = Some(e),
             }
Diff in /app/src/sliding_sync.rs:3623:
         let Some((client, client_session)) = client_and_session else {
             Cx::post_action(LoginAction::LoginFailure(
                 if let Some(err) = build_client_error {
[31m-                    format!("Could not create client object. Please try to login again.\n\nError: {err}")
[m[32m+                    format!(
[m[32m+                        "Could not create client object. Please try to login again.\n\nError: {err}"
[m[32m+                    )
[m                 } else {
                     String::from("Could not create client object. Please try to login again.")
[31m-                }
[m[32m+                },
[m             ));
             // This ensures that the called to `DEFAULT_SSO_CLIENT_NOTIFIER.notified()`
             // at the top of this function will not block upon the next login attempt.
Diff in /app/src/sliding_sync.rs:3638:
         let mut is_logged_in = false;
         Cx::post_action(LoginAction::Status {
             title: "Opening your browser...".into(),
[31m-            status: "Please finish logging in using your browser, and then come back to Robrix.".into(),
[m[32m+            status: "Please finish logging in using your browser, and then come back to Robrix."
[m[32m+                .into(),
[m         });
         match client
             .matrix_auth()
Diff in /app/src/sliding_sync.rs:3648:
                     if key == "redirectUrl" {
                         let redirect_url = Url::parse(&value)?;
                         Cx::post_action(LoginAction::SsoSetRedirectUrl(redirect_url));
[31m-                        break
[m[32m+                        break;
[m                     }
                 }
[31m-                Uri::new(&sso_url).open().map_err(|err|
[m[31m-                    Error::Io(io::Error::other(format!("Unable to open SSO login url. Error: {:?}", err)))
[m[31m-                )
[m[32m+                Uri::new(&sso_url).open().map_err(|err| {
[m[32m+                    Error::Io(io::Error::other(format!(
[m[32m+                        "Unable to open SSO login url. Error: {:?}",
[m[32m+                        err
[m[32m+                    )))
[m[32m+                })
[m             })
             .identity_provider_id(&identity_provider_id)
             .initial_device_display_name(&format!("robrix-sso-{brand}"))
Diff in /app/src/sliding_sync.rs:3668:
             }) {
             Ok(identity_provider_res) => {
                 if !is_logged_in {
[31m-                    if let Err(e) = login_sender.send(LoginRequest::LoginBySSOSuccess(client, client_session)).await {
[m[32m+                    if let Err(e) = login_sender
[m[32m+                        .send(LoginRequest::LoginBySSOSuccess(client, client_session))
[m[32m+                        .await
[m[32m+                    {
[m                         error!("Error sending login request to login_sender: {e:?}");
                         Cx::post_action(LoginAction::LoginFailure(String::from(
[31m-                            "BUG: failed to send login request to matrix worker thread."
[m[32m+                            "BUG: failed to send login request to matrix worker thread.",
[m                         )));
                     }
                     enqueue_rooms_list_update(RoomsListUpdate::Status {
Diff in /app/src/sliding_sync.rs:3697:
     });
 }

[31m-
[m bitflags! {
     /// The powers that a user has in a given room.
     #[derive(Copy, Clone, PartialEq, Eq)]
Diff in /app/src/sliding_sync.rs:3775:
         retval.set(UserPowerLevels::Invite, user_power >= power_levels.invite);
         retval.set(UserPowerLevels::Kick, user_power >= power_levels.kick);
         retval.set(UserPowerLevels::Redact, user_power >= power_levels.redact);
[31m-        retval.set(UserPowerLevels::NotifyRoom, user_power >= power_levels.notifications.room);
[m[31m-        retval.set(UserPowerLevels::Location, user_power >= power_levels.for_message(MessageLikeEventType::Location));
[m[31m-        retval.set(UserPowerLevels::Message, user_power >= power_levels.for_message(MessageLikeEventType::Message));
[m[31m-        retval.set(UserPowerLevels::Reaction, user_power >= power_levels.for_message(MessageLikeEventType::Reaction));
[m[31m-        retval.set(UserPowerLevels::RoomMessage, user_power >= power_levels.for_message(MessageLikeEventType::RoomMessage));
[m[31m-        retval.set(UserPowerLevels::RoomRedaction, user_power >= power_levels.for_message(MessageLikeEventType::RoomRedaction));
[m[31m-        retval.set(UserPowerLevels::Sticker, user_power >= power_levels.for_message(MessageLikeEventType::Sticker));
[m[31m-        retval.set(UserPowerLevels::RoomPinnedEvents, user_power >= power_levels.for_state(StateEventType::RoomPinnedEvents));
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::NotifyRoom,
[m[32m+            user_power >= power_levels.notifications.room,
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Location,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Location),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Message,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Message),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Reaction,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Reaction),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::RoomMessage,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::RoomMessage),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::RoomRedaction,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::RoomRedaction),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Sticker,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Sticker),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::RoomPinnedEvents,
[m[32m+            user_power >= power_levels.for_state(StateEventType::RoomPinnedEvents),
[m[32m+        );
[m         retval
     }

Diff in /app/src/sliding_sync.rs:3828:
     }

     pub fn can_send_message(self) -> bool {
[31m-        self.contains(UserPowerLevels::RoomMessage)
[m[31m-        || self.contains(UserPowerLevels::Message)
[m[32m+        self.contains(UserPowerLevels::RoomMessage) || self.contains(UserPowerLevels::Message)
[m     }

     pub fn can_send_reaction(self) -> bool {
Diff in /app/src/sliding_sync.rs:3846:
     }
 }

[31m-
[m /// Shuts down the current Tokio runtime completely and takes ownership to ensure proper cleanup.
 pub fn shutdown_background_tasks() {
     if let Some(runtime) = TOKIO_RUNTIME.lock().unwrap().take() {
Diff in /app/src/sliding_sync.rs:3864:
     ALL_JOINED_ROOMS.lock().unwrap().clear();

     let on_clear_appstate = Arc::new(Notify::new());
[31m-    Cx::post_action(LogoutAction::ClearAppState { on_clear_appstate: on_clear_appstate.clone() });
[m[31m-
[m[31m-    match tokio::time::timeout(config.app_state_cleanup_timeout, on_clear_appstate.notified()).await {
[m[32m+    Cx::post_action(LogoutAction::ClearAppState {
[m[32m+        on_clear_appstate: on_clear_appstate.clone(),
[m[32m+    });
[m[32m+
[m[32m+    match tokio::time::timeout(
[m[32m+        config.app_state_cleanup_timeout,
[m[32m+        on_clear_appstate.notified(),
[m[32m+    )
[m[32m+    .await
[m[32m+    {
[m         Ok(_) => {
             log!("Received signal that UI-side app state was cleaned successfully");
             Ok(())
Diff in /app/src/space_service_sync.rs:1:
 //! Background tasks that subscribe to the Matrix SpaceService in order to
 //! track changes to the user's joined spaces and send updates the UI.

[31m-use std::{collections::{HashMap, HashSet, hash_map::Entry}, iter::Peekable, sync::Arc};
[m[32m+use std::{
[m[32m+    collections::{HashMap, HashSet, hash_map::Entry},
[m[32m+    iter::Peekable,
[m[32m+    sync::Arc,
[m[32m+};
[m use eyeball_im::VectorDiff;
 use futures_util::StreamExt;
 use imbl::Vector;
Diff in /app/src/space_service_sync.rs:8:
 use makepad_widgets::*;
 use matrix_sdk::{Client, RoomState, media::MediaRequestParameters};
[31m-use matrix_sdk_ui::spaces::{SpaceRoom, SpaceRoomList, SpaceService, room_list::SpaceRoomListPaginationState};
[m[32m+use matrix_sdk_ui::spaces::{
[m[32m+    SpaceRoom, SpaceRoomList, SpaceService, room_list::SpaceRoomListPaginationState,
[m[32m+};
[m use ruma::{OwnedMxcUri, OwnedRoomId, events::room::MediaSource, room::RoomType};
[31m-use tokio::{runtime::Handle, sync::mpsc::{UnboundedReceiver, UnboundedSender}, task::JoinHandle};
[m[31m-use crate::{home::{rooms_list::{RoomsListUpdate, enqueue_rooms_list_update}, spaces_bar::{JoinedSpaceInfo, SpacesListUpdate, enqueue_spaces_list_update}}, room::FetchedRoomAvatar, utils::{self, RoomNameId}};
[m[32m+use tokio::{
[m[32m+    runtime::Handle,
[m[32m+    sync::mpsc::{UnboundedReceiver, UnboundedSender},
[m[32m+    task::JoinHandle,
[m[32m+};
[m[32m+use crate::{
[m[32m+    home::{
[m[32m+        rooms_list::{RoomsListUpdate, enqueue_rooms_list_update},
[m[32m+        spaces_bar::{JoinedSpaceInfo, SpacesListUpdate, enqueue_spaces_list_update},
[m[32m+    },
[m[32m+    room::FetchedRoomAvatar,
[m[32m+    utils::{self, RoomNameId},
[m[32m+};
[m
 /// Whether to enable verbose logging of all spaces service diff updates.
 const LOG_SPACE_SERVICE_DIFFS: bool = cfg!(feature = "log_space_service_diffs");
Diff in /app/src/space_service_sync.rs:21:
 /// while the last element is the direct parent.
 pub type ParentChain = SmallVec<[OwnedRoomId; 2]>;

[31m-
[m /// Requests related to obtaining info about Spaces, via the background space service.
 pub enum SpaceRequest {
     /// Start obtaining the list of rooms in the given space from the homeserver,
Diff in /app/src/space_service_sync.rs:34:
     ///
     /// Note: the Matrix SDK offers no way to unsubscribe from a space room list,
     /// so this just stops the async background task that runs the subscriber loop.
[31m-    UnsubscribeFromSpaceRoomList {
[m[31m-        space_id: OwnedRoomId,
[m[31m-    },
[m[32m+    UnsubscribeFromSpaceRoomList { space_id: OwnedRoomId },
[m     /// Leave the given space and all joined rooms within it.
     ///
     /// Will emit a [`SpaceRoomListAction::LeaveSpaceResult`] action.
Diff in /app/src/space_service_sync.rs:43:
[31m-    LeaveSpace {
[m[31m-        space_name_id: RoomNameId,
[m[31m-    },
[m[32m+    LeaveSpace { space_name_id: RoomNameId },
[m     /// Paginate the given space's room list, i.e., fetch the next batch of rooms in the list.
     ///
     /// This will result in a [`SpaceRoomListAction::PaginationState`] action being emitted,
Diff in /app/src/space_service_sync.rs:70:
     /// Get full details about a top-level space.
     ///
     /// This will result in a [`SpaceRoomListAction::TopLevelSpaceDetails`] action being emitted.
[31m-    GetTopLevelSpaceDetails {
[m[31m-        space_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetTopLevelSpaceDetails { space_id: OwnedRoomId },
[m }

 /// Internal requests sent from the [`space_service_loop`] to a specific space's [`space_room_list_loop`].
Diff in /app/src/space_service_sync.rs:88:
     Shutdown,
 }

[31m-
[m /// The main async loop task that listens for changes to all top-level joined spaces.
 pub async fn space_service_loop(client: Client) -> anyhow::Result<()> {
     // Create a channel for sending space-related requests to this background worker.
Diff in /app/src/space_service_sync.rs:95:
[31m-    let (space_request_sender, mut receiver) = tokio::sync::mpsc::unbounded_channel::<SpaceRequest>();
[m[32m+    let (space_request_sender, mut receiver) =
[m[32m+        tokio::sync::mpsc::unbounded_channel::<SpaceRequest>();
[m     // Give the request sender channel endpoint to the RoomsList widget.
[31m-    enqueue_rooms_list_update(RoomsListUpdate::SpaceRequestSender(space_request_sender.clone()));
[m[32m+    enqueue_rooms_list_update(RoomsListUpdate::SpaceRequestSender(
[m[32m+        space_request_sender.clone(),
[m[32m+    ));
[m
     // Create the actual space service.
     let space_service = SpaceService::new(client.clone()).await;
Diff in /app/src/space_service_sync.rs:103:
     // along with a sender to send `SpaceRoomListRequest`s to those tasks.
     let mut space_room_list_tasks = HashMap::new();
     // A closure to make it easier to use/spawn a `space_room_list_loop` task.
[31m-    let get_or_spawn_space_room_list = async |
[m[31m-        space_room_list_tasks: &mut HashMap<OwnedRoomId, (UnboundedSender<SpaceRoomListRequest>, JoinHandle<()>)>,
[m[31m-        space_id: &OwnedRoomId,
[m[31m-        parent_chain: &ParentChain,
[m[31m-    | -> UnboundedSender<SpaceRoomListRequest> {
[m[32m+    let get_or_spawn_space_room_list = async |space_room_list_tasks: &mut HashMap<
[m[32m+        OwnedRoomId,
[m[32m+        (UnboundedSender<SpaceRoomListRequest>, JoinHandle<()>),
[m[32m+    >,
[m[32m+                                              space_id: &OwnedRoomId,
[m[32m+                                              parent_chain: &ParentChain|
[m[32m+           -> UnboundedSender<SpaceRoomListRequest> {
[m         match space_room_list_tasks.entry(space_id.clone()) {
             Entry::Occupied(occ) => occ.get().0.clone(),
             Entry::Vacant(vac) => {
Diff in /app/src/space_service_sync.rs:114:
[31m-                let (sender, receiver) = tokio::sync::mpsc::unbounded_channel::<SpaceRoomListRequest>();
[m[32m+                let (sender, receiver) =
[m[32m+                    tokio::sync::mpsc::unbounded_channel::<SpaceRoomListRequest>();
[m                 let space_room_list = space_service.space_room_list(space_id.clone()).await;
[31m-                let join_handle = Handle::current().spawn(
[m[31m-                    space_room_list_loop(
[m[31m-                        space_id.clone(),
[m[31m-                        parent_chain.clone(),
[m[31m-                        receiver,
[m[31m-                        space_room_list,
[m[31m-                        space_request_sender.clone(),
[m[31m-                    )
[m[31m-                );
[m[31m-                vac.insert((sender, join_handle))
[m[31m-                    .0.clone()
[m[32m+                let join_handle = Handle::current().spawn(space_room_list_loop(
[m[32m+                    space_id.clone(),
[m[32m+                    parent_chain.clone(),
[m[32m+                    receiver,
[m[32m+                    space_room_list,
[m[32m+                    space_request_sender.clone(),
[m[32m+                ));
[m[32m+                vac.insert((sender, join_handle)).0.clone()
[m             }
         }
     };
Diff in /app/src/space_service_sync.rs:130:

     // Get the set of top-level (root) spaces that the user has joined.
[31m-    let (initial_spaces, mut spaces_diff_stream) = space_service.subscribe_to_top_level_joined_spaces().await;
[m[32m+    let (initial_spaces, mut spaces_diff_stream) =
[m[32m+        space_service.subscribe_to_top_level_joined_spaces().await;
[m     for space in &initial_spaces {
         add_new_space(space, &client).await;
     }
Diff in /app/src/space_service_sync.rs:136:
     let mut all_joined_spaces: Vector<SpaceRoom> = initial_spaces;
[31m-    if LOG_SPACE_SERVICE_DIFFS { log!("space_service: initial set: {all_joined_spaces:?}"); }
[m[32m+    if LOG_SPACE_SERVICE_DIFFS {
[m[32m+        log!("space_service: initial set: {all_joined_spaces:?}");
[m[32m+    }
[m
[31m-
[m[31m-    loop { tokio::select! {
[m[31m-        // Handle new space requests.
[m[31m-        request_opt = receiver.recv() => {
[m[31m-            let Some(request) = request_opt else { break };
[m[31m-            match request {
[m[31m-                SpaceRequest::GetChildren { space_id, parent_chain } => {
[m[31m-                    let sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[31m-                    if sender.send(SpaceRoomListRequest::GetChildren).is_err() {
[m[31m-                        error!("BUG: failed to send GetRooms request to space room list loop for space {space_id}");
[m[32m+    loop {
[m[32m+        tokio::select! {
[m[32m+            // Handle new space requests.
[m[32m+            request_opt = receiver.recv() => {
[m[32m+                let Some(request) = request_opt else { break };
[m[32m+                match request {
[m[32m+                    SpaceRequest::GetChildren { space_id, parent_chain } => {
[m[32m+                        let sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[32m+                        if sender.send(SpaceRoomListRequest::GetChildren).is_err() {
[m[32m+                            error!("BUG: failed to send GetRooms request to space room list loop for space {space_id}");
[m[32m+                        }
[m                     }
[31m-                }
[m[31m-                SpaceRequest::SubscribeToSpaceRoomList { space_id, parent_chain } => {
[m[31m-                    let _sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[31m-                }
[m[31m-                SpaceRequest::PaginateSpaceRoomList { space_id, parent_chain } => {
[m[31m-                    let sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[31m-                    if sender.send(SpaceRoomListRequest::Paginate).is_err() {
[m[31m-                        error!("BUG: failed to send paginate request to space room list loop for space {space_id}");
[m[32m+                    SpaceRequest::SubscribeToSpaceRoomList { space_id, parent_chain } => {
[m[32m+                        let _sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m                     }
[31m-                }
[m[31m-                SpaceRequest::UnsubscribeFromSpaceRoomList { space_id } => {
[m[31m-                    if let Some((sender, join_handle)) = space_room_list_tasks.remove(&space_id) {
[m[31m-                        let _ = sender.send(SpaceRoomListRequest::Shutdown);
[m[31m-                        join_handle.abort();
[m[32m+                    SpaceRequest::PaginateSpaceRoomList { space_id, parent_chain } => {
[m[32m+                        let sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[32m+                        if sender.send(SpaceRoomListRequest::Paginate).is_err() {
[m[32m+                            error!("BUG: failed to send paginate request to space room list loop for space {space_id}");
[m[32m+                        }
[m                     }
[31m-                }
[m[31m-                SpaceRequest::LeaveSpace { space_name_id } => {
[m[31m-                    match space_service.leave_space(space_name_id.room_id()).await {
[m[31m-                        Ok(leave_handle) => {
[m[31m-                            match leave_handle.leave(|_| true).await {
[m[31m-                                Ok(()) => {
[m[31m-                                    if let Some((sender, join_handle)) = space_room_list_tasks.remove(space_name_id.room_id()) {
[m[31m-                                        match sender.send(SpaceRoomListRequest::Shutdown) {
[m[31m-                                            // If we successfully sent shutdown message, just let the space room list loop task
[m[31m-                                            // end gracefully on its own in the background.
[m[31m-                                            Ok(_) => { }
[m[31m-                                            // If we failed to send the shutdown message, just abort the space room list loop task.
[m[31m-                                            Err(_) => join_handle.abort(),
[m[32m+                    SpaceRequest::UnsubscribeFromSpaceRoomList { space_id } => {
[m[32m+                        if let Some((sender, join_handle)) = space_room_list_tasks.remove(&space_id) {
[m[32m+                            let _ = sender.send(SpaceRoomListRequest::Shutdown);
[m[32m+                            join_handle.abort();
[m[32m+                        }
[m[32m+                    }
[m[32m+                    SpaceRequest::LeaveSpace { space_name_id } => {
[m[32m+                        match space_service.leave_space(space_name_id.room_id()).await {
[m[32m+                            Ok(leave_handle) => {
[m[32m+                                match leave_handle.leave(|_| true).await {
[m[32m+                                    Ok(()) => {
[m[32m+                                        if let Some((sender, join_handle)) = space_room_list_tasks.remove(space_name_id.room_id()) {
[m[32m+                                            match sender.send(SpaceRoomListRequest::Shutdown) {
[m[32m+                                                // If we successfully sent shutdown message, just let the space room list loop task
[m[32m+                                                // end gracefully on its own in the background.
[m[32m+                                                Ok(_) => { }
[m[32m+                                                // If we failed to send the shutdown message, just abort the space room list loop task.
[m[32m+                                                Err(_) => join_handle.abort(),
[m[32m+                                            }
[m                                         }
[32m+                                        Cx::post_action(SpaceRoomListAction::LeaveSpaceResult {
[m[32m+                                            space_name_id,
[m[32m+                                            result: Ok(()),
[m[32m+                                        });
[m                                     }
[31m-                                    Cx::post_action(SpaceRoomListAction::LeaveSpaceResult {
[m[31m-                                        space_name_id,
[m[31m-                                        result: Ok(()),
[m[31m-                                    });
[m[32m+                                    Err(error) => {
[m[32m+                                        error!("LeaveSpace: failed to leave all rooms in space {space_name_id}: {error:?}");
[m[32m+                                        Cx::post_action(SpaceRoomListAction::LeaveSpaceResult {
[m[32m+                                            space_name_id,
[m[32m+                                            result: Err(error),
[m[32m+                                        });
[m[32m+                                    }
[m                                 }
[31m-                                Err(error) => {
[m[31m-                                    error!("LeaveSpace: failed to leave all rooms in space {space_name_id}: {error:?}");
[m[31m-                                    Cx::post_action(SpaceRoomListAction::LeaveSpaceResult {
[m[31m-                                        space_name_id,
[m[31m-                                        result: Err(error),
[m[31m-                                    });
[m[31m-                                }
[m                             }
[32m+                            Err(error) => {
[m[32m+                                error!("Failed to leave space {space_name_id}: {error:?}");
[m[32m+                                Cx::post_action(SpaceRoomListAction::LeaveSpaceResult {
[m[32m+                                    space_name_id,
[m[32m+                                    result: Err(error),
[m[32m+                                });
[m[32m+                            }
[m                         }
[31m-                        Err(error) => {
[m[31m-                            error!("Failed to leave space {space_name_id}: {error:?}");
[m[31m-                            Cx::post_action(SpaceRoomListAction::LeaveSpaceResult {
[m[31m-                                space_name_id,
[m[31m-                                result: Err(error),
[m[31m-                            });
[m[32m+                    }
[m[32m+                    SpaceRequest::GetDetailedChildren { space_id, parent_chain } => {
[m[32m+                        let sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[32m+                        if sender.send(SpaceRoomListRequest::GetDetailedChildren).is_err() {
[m[32m+                            error!("BUG: failed to send GetDetailedChildren request to space room list loop for space {space_id}");
[m                         }
                     }
[31m-                }
[m[31m-                SpaceRequest::GetDetailedChildren { space_id, parent_chain } => {
[m[31m-                    let sender = get_or_spawn_space_room_list(&mut space_room_list_tasks, &space_id, &parent_chain).await;
[m[31m-                    if sender.send(SpaceRoomListRequest::GetDetailedChildren).is_err() {
[m[31m-                        error!("BUG: failed to send GetDetailedChildren request to space room list loop for space {space_id}");
[m[32m+                    SpaceRequest::GetTopLevelSpaceDetails { space_id } => {
[m[32m+                        if let Some(space) = all_joined_spaces.iter().find(|s| s.room_id == space_id) {
[m[32m+                            Cx::post_action(SpaceRoomListAction::TopLevelSpaceDetails(space.clone()));
[m[32m+                        } else {
[m[32m+                            error!("GetSpaceDetails: space {space_id} not found in all_joined_spaces");
[m[32m+                        }
[m                     }
                 }
[31m-                SpaceRequest::GetTopLevelSpaceDetails { space_id } => {
[m[31m-                    if let Some(space) = all_joined_spaces.iter().find(|s| s.room_id == space_id) {
[m[31m-                        Cx::post_action(SpaceRoomListAction::TopLevelSpaceDetails(space.clone()));
[m[31m-                    } else {
[m[31m-                        error!("GetSpaceDetails: space {space_id} not found in all_joined_spaces");
[m[31m-                    }
[m[31m-                }
[m             }
[31m-        }
[m
[31m-        // Handle updates to the list of spaces.
[m[31m-        batch_opt = spaces_diff_stream.next() => {
[m[31m-            let Some(batch) = batch_opt else { break };
[m[31m-            let mut peekable_diffs = batch.into_iter().peekable();
[m[31m-            while let Some(diff) = peekable_diffs.next() {
[m[31m-                match diff {
[m[31m-                    VectorDiff::Append { values: new_spaces } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Append {}", new_spaces.len()); }
[m[31m-                        for new_space in new_spaces {
[m[32m+            // Handle updates to the list of spaces.
[m[32m+            batch_opt = spaces_diff_stream.next() => {
[m[32m+                let Some(batch) = batch_opt else { break };
[m[32m+                let mut peekable_diffs = batch.into_iter().peekable();
[m[32m+                while let Some(diff) = peekable_diffs.next() {
[m[32m+                    match diff {
[m[32m+                        VectorDiff::Append { values: new_spaces } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Append {}", new_spaces.len()); }
[m[32m+                            for new_space in new_spaces {
[m[32m+                                add_new_space(&new_space, &client).await;
[m[32m+                                all_joined_spaces.push_back(new_space);
[m[32m+                            }
[m[32m+                        }
[m[32m+                        VectorDiff::Clear => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Clear"); }
[m[32m+                            all_joined_spaces.clear();
[m[32m+                            enqueue_spaces_list_update(SpacesListUpdate::ClearSpaces);
[m[32m+                        }
[m[32m+                        VectorDiff::PushFront { value: new_space } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PushFront"); }
[m                             add_new_space(&new_space, &client).await;
[32m+                            all_joined_spaces.push_front(new_space);
[m[32m+                        }
[m[32m+                        VectorDiff::PushBack { value: new_space } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PushBack"); }
[m[32m+                            add_new_space(&new_space, &client).await;
[m                             all_joined_spaces.push_back(new_space);
                         }
[31m-                    }
[m[31m-                    VectorDiff::Clear => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Clear"); }
[m[31m-                        all_joined_spaces.clear();
[m[31m-                        enqueue_spaces_list_update(SpacesListUpdate::ClearSpaces);
[m[31m-                    }
[m[31m-                    VectorDiff::PushFront { value: new_space } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PushFront"); }
[m[31m-                        add_new_space(&new_space, &client).await;
[m[31m-                        all_joined_spaces.push_front(new_space);
[m[31m-                    }
[m[31m-                    VectorDiff::PushBack { value: new_space } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PushBack"); }
[m[31m-                        add_new_space(&new_space, &client).await;
[m[31m-                        all_joined_spaces.push_back(new_space);
[m[31m-                    }
[m[31m-                    remove_diff @ VectorDiff::PopFront => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PopFront"); }
[m[31m-                        if let Some(space) = all_joined_spaces.pop_front() {
[m[31m-                            optimize_remove_then_add_into_update(
[m[31m-                                remove_diff,
[m[31m-                                space,
[m[31m-                                &mut peekable_diffs,
[m[31m-                                &mut all_joined_spaces,
[m[31m-                                &client,
[m[31m-                            ).await;
[m[32m+                        remove_diff @ VectorDiff::PopFront => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PopFront"); }
[m[32m+                            if let Some(space) = all_joined_spaces.pop_front() {
[m[32m+                                optimize_remove_then_add_into_update(
[m[32m+                                    remove_diff,
[m[32m+                                    space,
[m[32m+                                    &mut peekable_diffs,
[m[32m+                                    &mut all_joined_spaces,
[m[32m+                                    &client,
[m[32m+                                ).await;
[m[32m+                            }
[m                         }
[31m-                    }
[m[31m-                    remove_diff @ VectorDiff::PopBack => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PopBack"); }
[m[31m-                        if let Some(space) = all_joined_spaces.pop_back() {
[m[31m-                            optimize_remove_then_add_into_update(
[m[31m-                                remove_diff,
[m[31m-                                space,
[m[31m-                                &mut peekable_diffs,
[m[31m-                                &mut all_joined_spaces,
[m[31m-                                &client,
[m[31m-                            ).await;
[m[32m+                        remove_diff @ VectorDiff::PopBack => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff PopBack"); }
[m[32m+                            if let Some(space) = all_joined_spaces.pop_back() {
[m[32m+                                optimize_remove_then_add_into_update(
[m[32m+                                    remove_diff,
[m[32m+                                    space,
[m[32m+                                    &mut peekable_diffs,
[m[32m+                                    &mut all_joined_spaces,
[m[32m+                                    &client,
[m[32m+                                ).await;
[m[32m+                            }
[m                         }
[31m-                    }
[m[31m-                    VectorDiff::Insert { index, value: new_space } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Insert at {index}"); }
[m[31m-                        add_new_space(&new_space, &client).await;
[m[31m-                        all_joined_spaces.insert(index, new_space);
[m[31m-                    }
[m[31m-                    VectorDiff::Set { index, value: changed_space } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Set at {index}"); }
[m[31m-                        if let Some(old_space) = all_joined_spaces.get(index) {
[m[31m-                            update_space(old_space, &changed_space, &client).await;
[m[31m-                        } else {
[m[31m-                            error!("BUG: space_service diff: Set index {index} was out of bounds.");
[m[32m+                        VectorDiff::Insert { index, value: new_space } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Insert at {index}"); }
[m[32m+                            add_new_space(&new_space, &client).await;
[m[32m+                            all_joined_spaces.insert(index, new_space);
[m                         }
[31m-                        all_joined_spaces.set(index, changed_space);
[m[31m-                    }
[m[31m-                    remove_diff @ VectorDiff::Remove { index: remove_index } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Remove at {remove_index}"); }
[m[31m-                        if remove_index < all_joined_spaces.len() {
[m[31m-                            let space = all_joined_spaces.remove(remove_index);
[m[31m-                            optimize_remove_then_add_into_update(
[m[31m-                                remove_diff,
[m[31m-                                space,
[m[31m-                                &mut peekable_diffs,
[m[31m-                                &mut all_joined_spaces,
[m[31m-                                &client,
[m[31m-                            ).await;
[m[31m-                        } else {
[m[31m-                            error!("BUG: space_service: diff Remove index {remove_index} out of bounds, len {}", all_joined_spaces.len());
[m[32m+                        VectorDiff::Set { index, value: changed_space } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Set at {index}"); }
[m[32m+                            if let Some(old_space) = all_joined_spaces.get(index) {
[m[32m+                                update_space(old_space, &changed_space, &client).await;
[m[32m+                            } else {
[m[32m+                                error!("BUG: space_service diff: Set index {index} was out of bounds.");
[m[32m+                            }
[m[32m+                            all_joined_spaces.set(index, changed_space);
[m                         }
[31m-                    }
[m[31m-                    VectorDiff::Truncate { length } => {
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Truncate to {length}"); }
[m[31m-                        // Iterate manually so we can know which spaces are being removed.
[m[31m-                        while all_joined_spaces.len() > length {
[m[31m-                            if let Some(space) = all_joined_spaces.pop_back() {
[m[31m-                                remove_space(&space);
[m[32m+                        remove_diff @ VectorDiff::Remove { index: remove_index } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Remove at {remove_index}"); }
[m[32m+                            if remove_index < all_joined_spaces.len() {
[m[32m+                                let space = all_joined_spaces.remove(remove_index);
[m[32m+                                optimize_remove_then_add_into_update(
[m[32m+                                    remove_diff,
[m[32m+                                    space,
[m[32m+                                    &mut peekable_diffs,
[m[32m+                                    &mut all_joined_spaces,
[m[32m+                                    &client,
[m[32m+                                ).await;
[m[32m+                            } else {
[m[32m+                                error!("BUG: space_service: diff Remove index {remove_index} out of bounds, len {}", all_joined_spaces.len());
[m                             }
                         }
[31m-                        all_joined_spaces.truncate(length); // sanity check
[m[31m-                    }
[m[31m-                    VectorDiff::Reset { values: new_spaces } => {
[m[31m-                        // We implement this by clearing all spaces and then adding back the new values.
[m[31m-                        if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Reset, old length {}, new length {}", all_joined_spaces.len(), new_spaces.len()); }
[m[31m-                        // Iterate manually so we can know which spaces are being removed.
[m[31m-                        while let Some(space) = all_joined_spaces.pop_back() {
[m[31m-                            remove_space(&space);
[m[32m+                        VectorDiff::Truncate { length } => {
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Truncate to {length}"); }
[m[32m+                            // Iterate manually so we can know which spaces are being removed.
[m[32m+                            while all_joined_spaces.len() > length {
[m[32m+                                if let Some(space) = all_joined_spaces.pop_back() {
[m[32m+                                    remove_space(&space);
[m[32m+                                }
[m[32m+                            }
[m[32m+                            all_joined_spaces.truncate(length); // sanity check
[m                         }
[31m-                        enqueue_spaces_list_update(SpacesListUpdate::ClearSpaces);
[m[31m-                        for new_space in &new_spaces {
[m[31m-                            add_new_space(new_space, &client).await;
[m[32m+                        VectorDiff::Reset { values: new_spaces } => {
[m[32m+                            // We implement this by clearing all spaces and then adding back the new values.
[m[32m+                            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: diff Reset, old length {}, new length {}", all_joined_spaces.len(), new_spaces.len()); }
[m[32m+                            // Iterate manually so we can know which spaces are being removed.
[m[32m+                            while let Some(space) = all_joined_spaces.pop_back() {
[m[32m+                                remove_space(&space);
[m[32m+                            }
[m[32m+                            enqueue_spaces_list_update(SpacesListUpdate::ClearSpaces);
[m[32m+                            for new_space in &new_spaces {
[m[32m+                                add_new_space(new_space, &client).await;
[m[32m+                            }
[m[32m+                            all_joined_spaces = new_spaces;
[m                         }
[31m-                        all_joined_spaces = new_spaces;
[m                     }
                 }
[32m+                if LOG_SPACE_SERVICE_DIFFS { log!("space_service: after batch diff: {all_joined_spaces:?}"); }
[m             }
[31m-            if LOG_SPACE_SERVICE_DIFFS { log!("space_service: after batch diff: {all_joined_spaces:?}"); }
[m[31m-        }
[m
[31m-        else => {
[m[31m-            break;
[m[32m+            else => {
[m[32m+                break;
[m[32m+            }
[m         }
[31m-    } }
[m[32m+    }
[m
     anyhow::bail!("Space service sync loop ended unexpectedly")
 }
Diff in /app/src/space_service_sync.rs:335:

[31m-
[m async fn add_new_space(space: &SpaceRoom, client: &Client) {
     let space_avatar_opt = if let Some(url) = &space.avatar_url {
         fetch_space_avatar(url.clone(), client)
Diff in /app/src/space_service_sync.rs:340:
             .await
[31m-            .inspect_err(|e| error!("Failed to fetch avatar for new space {:?} ({}): {e}", space.display_name, space.room_id))
[m[32m+            .inspect_err(|e| {
[m[32m+                error!(
[m[32m+                    "Failed to fetch avatar for new space {:?} ({}): {e}",
[m[32m+                    space.display_name, space.room_id
[m[32m+                )
[m[32m+            })
[m             .ok()
[31m-    } else { None };
[m[31m-    let space_avatar = space_avatar_opt.unwrap_or_else(
[m[31m-        || utils::avatar_from_room_name(Some(&space.display_name))
[m[31m-    );
[m[32m+    } else {
[m[32m+        None
[m[32m+    };
[m[32m+    let space_avatar =
[m[32m+        space_avatar_opt.unwrap_or_else(|| utils::avatar_from_room_name(Some(&space.display_name)));
[m
     let jsi = JoinedSpaceInfo {
         space_name_id: RoomNameId::new(
Diff in /app/src/space_service_sync.rs:362:
     enqueue_spaces_list_update(SpacesListUpdate::AddJoinedSpace(jsi));
 }

[31m-
[m /// Attempts to optimize a common SpaceService operation of remove + add.
 ///
 /// If a `Remove` diff (or `PopBack` or `PopFront`) is immediately followed by
Diff in /app/src/space_service_sync.rs:381:
 ) {
     let next_diff_was_handled: bool;
     match peekable_diffs.peek() {
[31m-        Some(VectorDiff::Insert { index: insert_index, value: new_space })
[m[31m-            if space.room_id == new_space.room_id =>
[m[31m-        {
[m[32m+        Some(VectorDiff::Insert {
[m[32m+            index: insert_index,
[m[32m+            value: new_space,
[m[32m+        }) if space.room_id == new_space.room_id => {
[m             if LOG_SPACE_SERVICE_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + Insert({insert_index}) into Update for space {}", space.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + Insert({insert_index}) into Update for space {}",
[m[32m+                    space.room_id
[m[32m+                );
[m             }
             update_space(&space, new_space, client).await;
             all_joined_spaces.insert(*insert_index, new_space.clone());
Diff in /app/src/space_service_sync.rs:392:
             next_diff_was_handled = true;
         }
[31m-        Some(VectorDiff::PushFront { value: new_space })
[m[31m-            if space.room_id == new_space.room_id =>
[m[31m-        {
[m[32m+        Some(VectorDiff::PushFront { value: new_space }) if space.room_id == new_space.room_id => {
[m             if LOG_SPACE_SERVICE_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + PushFront into Update for space {}", space.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + PushFront into Update for space {}",
[m[32m+                    space.room_id
[m[32m+                );
[m             }
             update_space(&space, new_space, client).await;
             all_joined_spaces.push_front(new_space.clone());
Diff in /app/src/space_service_sync.rs:402:
             next_diff_was_handled = true;
         }
[31m-        Some(VectorDiff::PushBack { value: new_space })
[m[31m-            if space.room_id == new_space.room_id =>
[m[31m-        {
[m[32m+        Some(VectorDiff::PushBack { value: new_space }) if space.room_id == new_space.room_id => {
[m             if LOG_SPACE_SERVICE_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + PushBack into Update for space {}", space.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + PushBack into Update for space {}",
[m[32m+                    space.room_id
[m[32m+                );
[m             }
             update_space(&space, new_space, client).await;
             all_joined_spaces.push_back(new_space.clone());
Diff in /app/src/space_service_sync.rs:420:
     }
 }

[31m-
[m /// Invoked when the space service has received an update that changes an existing space.
[31m-async fn update_space(
[m[31m-    old_space: &SpaceRoom,
[m[31m-    new_space: &SpaceRoom,
[m[31m-    client: &Client,
[m[31m-) {
[m[32m+async fn update_space(old_space: &SpaceRoom, new_space: &SpaceRoom, client: &Client) {
[m     let new_space_id = new_space.room_id.clone();
     if old_space.room_id == new_space_id {
         // Handle state transitions for a space.
Diff in /app/src/space_service_sync.rs:433:
         if LOG_SPACE_SERVICE_DIFFS {
[31m-            log!("Space {:?} ({new_space_id}) state went from {:?} --> {:?}", new_space.display_name, old_space.state, new_space.state);
[m[32m+            log!(
[m[32m+                "Space {:?} ({new_space_id}) state went from {:?} --> {:?}",
[m[32m+                new_space.display_name,
[m[32m+                old_space.state,
[m[32m+                new_space.state
[m[32m+            );
[m         }
         if old_space.state != new_space.state {
             match new_space.state {
Diff in /app/src/space_service_sync.rs:438:
                 Some(RoomState::Banned) => {
                     // TODO: handle spaces that this user has been banned from.
[31m-                    log!("Removing Banned space: {:?} ({new_space_id})", new_space.display_name);
[m[32m+                    log!(
[m[32m+                        "Removing Banned space: {:?} ({new_space_id})",
[m[32m+                        new_space.display_name
[m[32m+                    );
[m                     remove_space(new_space);
                     return;
                 }
Diff in /app/src/space_service_sync.rs:444:
                 Some(RoomState::Left) => {
[31m-                    log!("Removing Left space: {:?} ({new_space_id})", new_space.display_name);
[m[32m+                    log!(
[m[32m+                        "Removing Left space: {:?} ({new_space_id})",
[m[32m+                        new_space.display_name
[m[32m+                    );
[m                     // TODO: instead of removing this, we could optionally add it to
                     //       a separate list of left space, which would be collapsed by default.
                     //       Upon clicking a left space, we could show a splash page
Diff in /app/src/space_service_sync.rs:452:
                     return;
                 }
                 Some(RoomState::Joined) => {
[31m-                    log!("update_space(): adding new Joined space: {:?} ({new_space_id})", new_space.display_name);
[m[32m+                    log!(
[m[32m+                        "update_space(): adding new Joined space: {:?} ({new_space_id})",
[m[32m+                        new_space.display_name
[m[32m+                    );
[m                     add_new_space(new_space, client).await;
                     return;
                 }
Diff in /app/src/space_service_sync.rs:459:
                 Some(RoomState::Invited) => {
[31m-                    log!("update_space(): adding new Invited space: {:?} ({new_space_id})", new_space.display_name);
[m[32m+                    log!(
[m[32m+                        "update_space(): adding new Invited space: {:?} ({new_space_id})",
[m[32m+                        new_space.display_name
[m[32m+                    );
[m                     add_new_space(new_space, client).await;
                     return;
                 }
Diff in /app/src/space_service_sync.rs:466:
                     return;
                 }
                 None => {
[31m-                    error!("WARNING: UNTESTED: new space {} ({}) RoomState is None", new_space.display_name, new_space.room_id);
[m[32m+                    error!(
[m[32m+                        "WARNING: UNTESTED: new space {} ({}) RoomState is None",
[m[32m+                        new_space.display_name, new_space.room_id
[m[32m+                    );
[m                 }
             }
         }
Diff in /app/src/space_service_sync.rs:473:

         if old_space.canonical_alias != new_space.canonical_alias {
[31m-            log!("Updating space {} alias: {:?} --> {:?}", new_space_id, old_space.canonical_alias, new_space.canonical_alias);
[m[32m+            log!(
[m[32m+                "Updating space {} alias: {:?} --> {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.canonical_alias,
[m[32m+                new_space.canonical_alias
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateCanonicalAlias {
                 space_id: new_space_id.clone(),
                 new_canonical_alias: new_space.canonical_alias.clone(),
Diff in /app/src/space_service_sync.rs:480:
         }

         if old_space.display_name != new_space.display_name {
[31m-            log!("Updating space {} name: {:?} --> {:?}", new_space_id, old_space.display_name, new_space.display_name);
[m[32m+            log!(
[m[32m+                "Updating space {} name: {:?} --> {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.display_name,
[m[32m+                new_space.display_name
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateSpaceName {
                 space_id: new_space_id.clone(),
                 new_space_name: new_space.display_name.clone(),
Diff in /app/src/space_service_sync.rs:488:
         }

         if old_space.topic != new_space.topic {
[31m-            log!("Updating space {} topic:\n    {:?}\n  -->\n    {:?}", new_space_id, old_space.topic, new_space.topic);
[m[32m+            log!(
[m[32m+                "Updating space {} topic:\n    {:?}\n  -->\n    {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.topic,
[m[32m+                new_space.topic
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateSpaceTopic {
                 space_id: new_space_id.clone(),
                 topic: new_space.topic.clone(),
Diff in /app/src/space_service_sync.rs:507:
                 let space_avatar_opt = if let Some(url) = url_opt {
                     fetch_space_avatar(url, &client2)
                         .await
[31m-                        .inspect_err(|e| error!("Failed to fetch avatar for space {:?} ({}): {e}", space_display_name, space_id))
[m[32m+                        .inspect_err(|e| {
[m[32m+                            error!(
[m[32m+                                "Failed to fetch avatar for space {:?} ({}): {e}",
[m[32m+                                space_display_name, space_id
[m[32m+                            )
[m[32m+                        })
[m                         .ok()
[31m-                } else { None };
[m[31m-                let avatar = space_avatar_opt.unwrap_or_else(
[m[31m-                    || utils::avatar_from_room_name(Some(&space_display_name))
[m[31m-                );
[m[31m-                enqueue_spaces_list_update(SpacesListUpdate::UpdateSpaceAvatar { space_id, avatar });
[m[32m+                } else {
[m[32m+                    None
[m[32m+                };
[m[32m+                let avatar = space_avatar_opt
[m[32m+                    .unwrap_or_else(|| utils::avatar_from_room_name(Some(&space_display_name)));
[m[32m+                enqueue_spaces_list_update(SpacesListUpdate::UpdateSpaceAvatar {
[m[32m+                    space_id,
[m[32m+                    avatar,
[m[32m+                });
[m             });
         }

Diff in /app/src/space_service_sync.rs:520:
         if old_space.num_joined_members != new_space.num_joined_members {
[31m-            log!("Updating space {} joined members: {} --> {}", new_space_id, old_space.num_joined_members, new_space.num_joined_members);
[m[32m+            log!(
[m[32m+                "Updating space {} joined members: {} --> {}",
[m[32m+                new_space_id,
[m[32m+                old_space.num_joined_members,
[m[32m+                new_space.num_joined_members
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateNumJoinedMembers {
                 space_id: new_space_id.clone(),
                 num_joined_members: new_space.num_joined_members,
Diff in /app/src/space_service_sync.rs:526:
         }

         if old_space.join_rule != new_space.join_rule {
[31m-            log!("Updating space {} join rule: {:?} --> {:?}", new_space_id, old_space.join_rule, new_space.join_rule);
[m[32m+            log!(
[m[32m+                "Updating space {} join rule: {:?} --> {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.join_rule,
[m[32m+                new_space.join_rule
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateJoinRule {
                 space_id: new_space_id.clone(),
                 join_rule: new_space.join_rule.clone(),
Diff in /app/src/space_service_sync.rs:534:
         }

         if old_space.world_readable != new_space.world_readable {
[31m-            log!("Updating space {} world readable: {:?} --> {:?}", new_space_id, old_space.world_readable, new_space.world_readable);
[m[32m+            log!(
[m[32m+                "Updating space {} world readable: {:?} --> {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.world_readable,
[m[32m+                new_space.world_readable
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateWorldReadable {
                 space_id: new_space_id.clone(),
                 world_readable: new_space.world_readable,
Diff in /app/src/space_service_sync.rs:542:
         }

         if old_space.guest_can_join != new_space.guest_can_join {
[31m-            log!("Updating space {} guest can join: {:?} --> {:?}", new_space_id, old_space.guest_can_join, new_space.guest_can_join);
[m[32m+            log!(
[m[32m+                "Updating space {} guest can join: {:?} --> {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.guest_can_join,
[m[32m+                new_space.guest_can_join
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateGuestCanJoin {
                 space_id: new_space_id.clone(),
                 guest_can_join: new_space.guest_can_join,
Diff in /app/src/space_service_sync.rs:550:
         }

         if old_space.children_count != new_space.children_count {
[31m-            log!("Updating space {} children count: {:?} --> {:?}", new_space_id, old_space.children_count, new_space.children_count);
[m[32m+            log!(
[m[32m+                "Updating space {} children count: {:?} --> {:?}",
[m[32m+                new_space_id,
[m[32m+                old_space.children_count,
[m[32m+                new_space.children_count
[m[32m+            );
[m             enqueue_spaces_list_update(SpacesListUpdate::UpdateChildrenCount {
                 space_id: new_space_id.clone(),
                 children_count: new_space.children_count,
Diff in /app/src/space_service_sync.rs:557:
             });
         }
[31m-    }
[m[31m-    else {
[m[31m-        warning!("UNTESTED SCENARIO: update_space(): removing old room {}, replacing with new room {}",
[m[31m-            old_space.room_id, new_space_id,
[m[32m+    } else {
[m[32m+        warning!(
[m[32m+            "UNTESTED SCENARIO: update_space(): removing old room {}, replacing with new room {}",
[m[32m+            old_space.room_id,
[m[32m+            new_space_id,
[m         );
         remove_space(old_space);
         add_new_space(new_space, client).await;
Diff in /app/src/space_service_sync.rs:566:
     }
 }

[31m-
[m /// Invoked when the space service has received an update to remove an existing space.
 fn remove_space(space: &SpaceRoom) {
     enqueue_spaces_list_update(SpacesListUpdate::RemoveSpace {
Diff in /app/src/space_service_sync.rs:575:
     });
 }

[31m-
[m /// Fetches the avatar for the space at the given URL.
 ///
 /// Returns `Some` if the avatar image was successfully fetched.
Diff in /app/src/space_service_sync.rs:582:
[31m-async fn fetch_space_avatar(url: OwnedMxcUri, client: &Client) -> matrix_sdk::Result<FetchedRoomAvatar> {
[m[32m+async fn fetch_space_avatar(
[m[32m+    url: OwnedMxcUri,
[m[32m+    client: &Client,
[m[32m+) -> matrix_sdk::Result<FetchedRoomAvatar> {
[m     let request = MediaRequestParameters {
         source: MediaSource::Plain(url),
         format: utils::AVATAR_THUMBNAIL_FORMAT.into(),
Diff in /app/src/space_service_sync.rs:586:
     };
[31m-    client.media()
[m[32m+    client
[m[32m+        .media()
[m         .get_media_content(&request, true)
         .await
         .map(|img_data| FetchedRoomAvatar::Image(img_data.into()))
Diff in /app/src/space_service_sync.rs:591:
 }

[31m-
[m[31m-
[m /// Extension trait for `SpaceRoom` to provide utility methods.
 pub trait SpaceRoomExt {
     /// Returns true if this `SpaceRoom` is a space itself;
Diff in /app/src/space_service_sync.rs:605:
     }
 }

[31m-
[m[31m-
[m /// A loop that listens for changes to the set of rooms in a given space.
 async fn space_room_list_loop(
     space_id: OwnedRoomId,
Diff in /app/src/space_service_sync.rs:628:
         }),
     };

[31m-    // First, we paginate the space once to get at least *some* child rooms.
[m[32m+    // First, we paginate the space once to get at least *some* child rooms.
[m     paginate_once().await;

     // The set of subspaces within this `space_id` that are already known to us.
Diff in /app/src/space_service_sync.rs:635:
     let mut known_subspaces = HashSet::new();

[31m-    let (mut all_rooms_in_space, mut space_room_stream) = space_room_list.subscribe_to_room_updates();
[m[31m-    handle_subspaces(&space_id, &parent_chain, &mut known_subspaces, all_rooms_in_space.iter(), &request_sender);
[m[32m+    let (mut all_rooms_in_space, mut space_room_stream) =
[m[32m+        space_room_list.subscribe_to_room_updates();
[m[32m+    handle_subspaces(
[m[32m+        &space_id,
[m[32m+        &parent_chain,
[m[32m+        &mut known_subspaces,
[m[32m+        all_rooms_in_space.iter(),
[m[32m+        &request_sender,
[m[32m+    );
[m
     // A tuple of: the latest `(direct child rooms, and direct subspaces)` within this space.
     // This makes it very cheap & fast to repeatedly handle `GetChildren` requests.
Diff in /app/src/space_service_sync.rs:642:
     let mut cached_hash_sets = space_children_to_hash_sets(&all_rooms_in_space);

[31m-    loop { tokio::select! {
[m[31m-        // Handle new requests.
[m[31m-        request_opt = receiver.recv() => {
[m[31m-            let Some(request) = request_opt else { break };
[m[31m-            match request {
[m[31m-                SpaceRoomListRequest::GetChildren => {
[m[31m-                    Cx::post_action(SpaceRoomListAction::UpdatedChildren {
[m[31m-                        space_id: space_id.clone(),
[m[31m-                        parent_chain: parent_chain.clone(),
[m[31m-                        direct_child_rooms: Arc::clone(&cached_hash_sets.0),
[m[31m-                        direct_subspaces: Arc::clone(&cached_hash_sets.1),
[m[31m-                    });
[m[32m+    loop {
[m[32m+        tokio::select! {
[m[32m+            // Handle new requests.
[m[32m+            request_opt = receiver.recv() => {
[m[32m+                let Some(request) = request_opt else { break };
[m[32m+                match request {
[m[32m+                    SpaceRoomListRequest::GetChildren => {
[m[32m+                        Cx::post_action(SpaceRoomListAction::UpdatedChildren {
[m[32m+                            space_id: space_id.clone(),
[m[32m+                            parent_chain: parent_chain.clone(),
[m[32m+                            direct_child_rooms: Arc::clone(&cached_hash_sets.0),
[m[32m+                            direct_subspaces: Arc::clone(&cached_hash_sets.1),
[m[32m+                        });
[m[32m+                    }
[m[32m+                    SpaceRoomListRequest::GetDetailedChildren => {
[m[32m+                        Cx::post_action(SpaceRoomListAction::DetailedChildren {
[m[32m+                            space_id: space_id.clone(),
[m[32m+                            parent_chain: parent_chain.clone(),
[m[32m+                            // The `imbl::Vector` type is very cheap to clone here
[m[32m+                            // because we're not modifying it, so we just send that value directly.
[m[32m+                            children: all_rooms_in_space.clone(),
[m[32m+                        });
[m[32m+                    }
[m[32m+                    SpaceRoomListRequest::Paginate => {
[m[32m+                        paginate_once().await;
[m[32m+                    }
[m[32m+                    SpaceRoomListRequest::Shutdown => return,
[m                 }
[31m-                SpaceRoomListRequest::GetDetailedChildren => {
[m[31m-                    Cx::post_action(SpaceRoomListAction::DetailedChildren {
[m[31m-                        space_id: space_id.clone(),
[m[31m-                        parent_chain: parent_chain.clone(),
[m[31m-                        // The `imbl::Vector` type is very cheap to clone here
[m[31m-                        // because we're not modifying it, so we just send that value directly.
[m[31m-                        children: all_rooms_in_space.clone(),
[m[31m-                    });
[m[31m-                }
[m[31m-                SpaceRoomListRequest::Paginate => {
[m[31m-                    paginate_once().await;
[m[31m-                }
[m[31m-                SpaceRoomListRequest::Shutdown => return,
[m             }
[31m-        }
[m
[31m-        // Handle updates to the list of rooms and subspaces in this space.
[m[31m-        batch_opt = space_room_stream.next() => {
[m[31m-            let Some(batch) = batch_opt else { break };
[m[31m-            for diff in batch {
[m[31m-                // Manually inspect any diff that could result in new space room(s),
[m[31m-                // such that we can check to see if any of them are nested subspaces.
[m[31m-                match &diff {
[m[31m-                    VectorDiff::Append { values }
[m[31m-                    | VectorDiff::Reset { values } => handle_subspaces(
[m[31m-                        &space_id,
[m[31m-                        &parent_chain,
[m[31m-                        &mut known_subspaces,
[m[31m-                        values.iter(),
[m[31m-                        &request_sender,
[m[31m-                    ),
[m[31m-                    VectorDiff::PushFront { value }
[m[31m-                    | VectorDiff::PushBack { value }
[m[31m-                    | VectorDiff::Insert { value, .. }
[m[31m-                    | VectorDiff::Set { value, .. } => handle_subspaces(
[m[31m-                        &space_id,
[m[31m-                        &parent_chain,
[m[31m-                        &mut known_subspaces,
[m[31m-                        std::iter::once(value),
[m[31m-                        &request_sender,
[m[31m-                    ),
[m[31m-                    _ => { }
[m[31m-                };
[m[31m-                diff.apply(&mut all_rooms_in_space);
[m[32m+            // Handle updates to the list of rooms and subspaces in this space.
[m[32m+            batch_opt = space_room_stream.next() => {
[m[32m+                let Some(batch) = batch_opt else { break };
[m[32m+                for diff in batch {
[m[32m+                    // Manually inspect any diff that could result in new space room(s),
[m[32m+                    // such that we can check to see if any of them are nested subspaces.
[m[32m+                    match &diff {
[m[32m+                        VectorDiff::Append { values }
[m[32m+                        | VectorDiff::Reset { values } => handle_subspaces(
[m[32m+                            &space_id,
[m[32m+                            &parent_chain,
[m[32m+                            &mut known_subspaces,
[m[32m+                            values.iter(),
[m[32m+                            &request_sender,
[m[32m+                        ),
[m[32m+                        VectorDiff::PushFront { value }
[m[32m+                        | VectorDiff::PushBack { value }
[m[32m+                        | VectorDiff::Insert { value, .. }
[m[32m+                        | VectorDiff::Set { value, .. } => handle_subspaces(
[m[32m+                            &space_id,
[m[32m+                            &parent_chain,
[m[32m+                            &mut known_subspaces,
[m[32m+                            std::iter::once(value),
[m[32m+                            &request_sender,
[m[32m+                        ),
[m[32m+                        _ => { }
[m[32m+                    };
[m[32m+                    diff.apply(&mut all_rooms_in_space);
[m[32m+                }
[m[32m+                // Here: children have changed, so we re-calculate the sets of child rooms and subspaces.
[m[32m+                cached_hash_sets = space_children_to_hash_sets(&all_rooms_in_space);
[m[32m+                Cx::post_action(SpaceRoomListAction::UpdatedChildren {
[m[32m+                    space_id: space_id.clone(),
[m[32m+                    parent_chain: parent_chain.clone(),
[m[32m+                    direct_child_rooms: Arc::clone(&cached_hash_sets.0),
[m[32m+                    direct_subspaces: Arc::clone(&cached_hash_sets.1),
[m[32m+                });
[m             }
[31m-            // Here: children have changed, so we re-calculate the sets of child rooms and subspaces.
[m[31m-            cached_hash_sets = space_children_to_hash_sets(&all_rooms_in_space);
[m[31m-            Cx::post_action(SpaceRoomListAction::UpdatedChildren {
[m[31m-                space_id: space_id.clone(),
[m[31m-                parent_chain: parent_chain.clone(),
[m[31m-                direct_child_rooms: Arc::clone(&cached_hash_sets.0),
[m[31m-                direct_subspaces: Arc::clone(&cached_hash_sets.1),
[m[31m-            });
[m         }
[31m-    } }
[m[32m+    }
[m }

 /// Finds nested/subspaces within a list of space rooms and submits a request
Diff in /app/src/space_service_sync.rs:720:
     changed_space_rooms: impl Iterator<Item = &'a SpaceRoom>,
     request_sender: &UnboundedSender<SpaceRequest>,
 ) {
[31m-    for sr in changed_space_rooms.filter(|&sr| sr.is_space()) {
[m[32m+    for sr in changed_space_rooms.filter(|&sr| sr.is_space()) {
[m         if known_subspaces.contains(&sr.room_id) {
             continue;
         }
Diff in /app/src/space_service_sync.rs:732:
             npc.push(parent_space_id.clone());
             npc
         };
[31m-        if request_sender.send(SpaceRequest::SubscribeToSpaceRoomList {
[m[31m-            space_id: sr.room_id.clone(),
[m[31m-            parent_chain: new_parent_chain,
[m[31m-        }).is_err() {
[m[31m-            error!("BUG: failed to send subscribe request to nested/subspace {}.", sr.room_id);
[m[32m+        if request_sender
[m[32m+            .send(SpaceRequest::SubscribeToSpaceRoomList {
[m[32m+                space_id: sr.room_id.clone(),
[m[32m+                parent_chain: new_parent_chain,
[m[32m+            })
[m[32m+            .is_err()
[m[32m+        {
[m[32m+            error!(
[m[32m+                "BUG: failed to send subscribe request to nested/subspace {}.",
[m[32m+                sr.room_id
[m[32m+            );
[m         }
     }
 }
Diff in /app/src/space_service_sync.rs:745:
 /// 1. the set of child rooms directly within this space.
 /// 2. the set of subspaces directly within this space.
 fn space_children_to_hash_sets(
[31m-    all_rooms_in_space: &Vector<SpaceRoom>
[m[32m+    all_rooms_in_space: &Vector<SpaceRoom>,
[m ) -> (Arc<HashSet<OwnedRoomId>>, Arc<HashSet<OwnedRoomId>>) {
     let mut direct_child_rooms = HashSet::new();
     let mut direct_subspaces = HashSet::new();
Diff in /app/src/space_service_sync.rs:807:
 impl std::fmt::Debug for SpaceRoomListAction {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
[31m-            SpaceRoomListAction::UpdatedChildren { space_id, parent_chain, direct_child_rooms, direct_subspaces } => {
[m[31m-                f.debug_struct("SpaceRoomListAction::UpdatedChildren")
[m[31m-                    .field("space_id", space_id)
[m[31m-                    .field("parent_chain", &parent_chain)
[m[31m-                    .field("num_direct_child_rooms", &direct_child_rooms.len())
[m[31m-                    .field("num_direct_subspaces", &direct_subspaces.len())
[m[31m-                    .finish()
[m[31m-            }
[m[31m-            SpaceRoomListAction::PaginationState { space_id, parent_chain, state } => {
[m[31m-                f.debug_struct("SpaceRoomListAction::PaginationState")
[m[31m-                    .field("space_id", space_id)
[m[31m-                    .field("parent_chain", &parent_chain)
[m[31m-                    .field("state", state)
[m[31m-                    .finish()
[m[31m-            }
[m[31m-            SpaceRoomListAction::PaginationError { space_id, error } => {
[m[31m-                f.debug_struct("SpaceRoomListAction::PaginationError")
[m[31m-                    .field("space_id", space_id)
[m[31m-                    .field("error", error)
[m[31m-                    .finish()
[m[31m-            }
[m[31m-            SpaceRoomListAction::DetailedChildren { space_id, parent_chain, children } => {
[m[31m-                f.debug_struct("SpaceRoomListAction::DetailedChildren")
[m[31m-                    .field("space_id", space_id)
[m[31m-                    .field("parent_chain", &parent_chain)
[m[31m-                    .field("num_children", &children.len())
[m[31m-                    .finish()
[m[31m-            }
[m[31m-            SpaceRoomListAction::TopLevelSpaceDetails(space) => {
[m[31m-                f.debug_tuple("SpaceRoomListAction::TopLevelSpaceDetails")
[m[31m-                    .field(space)
[m[31m-                    .finish()
[m[31m-            }
[m[31m-            SpaceRoomListAction::LeaveSpaceResult { space_name_id, result } => {
[m[31m-                f.debug_struct("SpaceRoomListAction::LeaveSpaceResult")
[m[31m-                    .field("space_name_id", space_name_id)
[m[31m-                    .field("result", result)
[m[31m-                    .finish()
[m[31m-            }
[m[32m+            SpaceRoomListAction::UpdatedChildren {
[m[32m+                space_id,
[m[32m+                parent_chain,
[m[32m+                direct_child_rooms,
[m[32m+                direct_subspaces,
[m[32m+            } => f
[m[32m+                .debug_struct("SpaceRoomListAction::UpdatedChildren")
[m[32m+                .field("space_id", space_id)
[m[32m+                .field("parent_chain", &parent_chain)
[m[32m+                .field("num_direct_child_rooms", &direct_child_rooms.len())
[m[32m+                .field("num_direct_subspaces", &direct_subspaces.len())
[m[32m+                .finish(),
[m[32m+            SpaceRoomListAction::PaginationState {
[m[32m+                space_id,
[m[32m+                parent_chain,
[m[32m+                state,
[m[32m+            } => f
[m[32m+                .debug_struct("SpaceRoomListAction::PaginationState")
[m[32m+                .field("space_id", space_id)
[m[32m+                .field("parent_chain", &parent_chain)
[m[32m+                .field("state", state)
[m[32m+                .finish(),
[m[32m+            SpaceRoomListAction::PaginationError { space_id, error } => f
[m[32m+                .debug_struct("SpaceRoomListAction::PaginationError")
[m[32m+                .field("space_id", space_id)
[m[32m+                .field("error", error)
[m[32m+                .finish(),
[m[32m+            SpaceRoomListAction::DetailedChildren {
[m[32m+                space_id,
[m[32m+                parent_chain,
[m[32m+                children,
[m[32m+            } => f
[m[32m+                .debug_struct("SpaceRoomListAction::DetailedChildren")
[m[32m+                .field("space_id", space_id)
[m[32m+                .field("parent_chain", &parent_chain)
[m[32m+                .field("num_children", &children.len())
[m[32m+                .finish(),
[m[32m+            SpaceRoomListAction::TopLevelSpaceDetails(space) => f
[m[32m+                .debug_tuple("SpaceRoomListAction::TopLevelSpaceDetails")
[m[32m+                .field(space)
[m[32m+                .finish(),
[m[32m+            SpaceRoomListAction::LeaveSpaceResult {
[m[32m+                space_name_id,
[m[32m+                result,
[m[32m+            } => f
[m[32m+                .debug_struct("SpaceRoomListAction::LeaveSpaceResult")
[m[32m+                .field("space_name_id", space_name_id)
[m[32m+                .field("result", result)
[m[32m+                .finish(),
[m         }
     }
 }
Diff in /app/src/temp_storage.rs:1:
 use std::{sync::OnceLock, path::PathBuf};

[31m-
[m /// Creates and returns the path to a temp directory for storage.
 ///
 /// This is very efficient to call multiple times because the result is cached
Diff in /app/src/temp_storage.rs:16:
         path
     })
 }
[31m-
[m
Diff in /app/src/tsp/create_did_modal.rs:4:

 use crate::{shared::styles::*, tsp};

[31m-
[m live_design! {
     link tsp_enabled

Diff in /app/src/tsp/create_did_modal.rs:203:
                         color: (COLOR_FG_DANGER_RED),
                     }
                     icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                     draw_bg: {
                         border_color: (COLOR_FG_DANGER_RED),
                         color: (COLOR_BG_DANGER_RED)
Diff in /app/src/tsp/create_did_modal.rs:276:
     IdentityCreationError,
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct CreateDidModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: CreateDidModalState,
[m[31m-    #[rust] is_showing_error: bool,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: CreateDidModalState,
[m[32m+    #[rust]
[m[32m+    is_showing_error: bool,
[m }

 impl Widget for CreateDidModal {
Diff in /app/src/tsp/create_did_modal.rs:302:

         // Handle canceling/closing the modal.
         let cancel_clicked = cancel_button.clicked(actions);
[31m-        if cancel_clicked ||
[m[31m-            actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m[32m+        if cancel_clicked
[m[32m+            || actions
[m[32m+                .iter()
[m[32m+                .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m         {
             // If the modal was dismissed by clicking outside of it, we MUST NOT emit
             // a `CreateDidModalAction::Close` action, as that would cause
Diff in /app/src/tsp/create_did_modal.rs:340:
                     // Check to ensure that the user has entered all required fields.
                     if username.is_empty() {
                         self.is_showing_error = true;
[31m-                        status_label.apply_over(cx, live!(
[m[31m-                            text: "Please enter a DID username.",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_FG_DANGER_RED),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Please enter a DID username.",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_FG_DANGER_RED),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                     } else {
                         let alias = match alias_input.text().trim() {
                             "" => None,
Diff in /app/src/tsp/create_did_modal.rs:365:
                             username: username.to_string(),
                             alias,
                             server,
[31m-                            did_server
[m[32m+                            did_server,
[m                         });

                         self.state = CreateDidModalState::WaitingForIdentityCreation;
Diff in /app/src/tsp/create_did_modal.rs:372:
                         self.is_showing_error = false;
[31m-                        status_label.apply_over(cx, live!(
[m[31m-                            text: "Waiting for identity to be created and published...",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_ACTIVE_PRIMARY_DARKER),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Waiting for identity to be created and published...",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_ACTIVE_PRIMARY_DARKER),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                         accept_button.set_enabled(cx, false);
                         cancel_button.set_enabled(cx, false); // TODO: support canceling the identity creation request?
                         username_input.set_is_read_only(cx, true);
Diff in /app/src/tsp/create_did_modal.rs:387:
                     needs_redraw = true;
                 }

[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }

Diff in /app/src/tsp/create_did_modal.rs:394:
[31m-
[m         // If the user changes any of the input fields, clear the error message
         // and reset the accept button to its default state.
         if self.is_showing_error {
Diff in /app/src/tsp/create_did_modal.rs:403:
                 self.is_showing_error = false;
                 self.view.label(ids!(status_label)).set_text(cx, "");
                 self.state = CreateDidModalState::WaitingForUserInput;
[31m-                accept_button.apply_over(cx, live!(
[m[31m-                    text: "Create DID",
[m[31m-                    enabled: true,
[m[31m-                    draw_text: {
[m[31m-                        color: (COLOR_FG_ACCEPT_GREEN),
[m[31m-                    },
[m[31m-                ));
[m[32m+                accept_button.apply_over(
[m[32m+                    cx,
[m[32m+                    live!(
[m[32m+                        text: "Create DID",
[m[32m+                        enabled: true,
[m[32m+                        draw_text: {
[m[32m+                            color: (COLOR_FG_ACCEPT_GREEN),
[m[32m+                        },
[m[32m+                    ),
[m[32m+                );
[m                 needs_redraw = true;
             }
         }
Diff in /app/src/tsp/create_did_modal.rs:416:

         for action in actions {
             match action.downcast_ref() {
[31m-                Some(tsp::TspIdentityAction::DidCreationResult(Ok(did)))=> {
[m[32m+                Some(tsp::TspIdentityAction::DidCreationResult(Ok(did))) => {
[m                     self.state = CreateDidModalState::IdentityCreated;
                     self.is_showing_error = false;
                     let message = format!("Successfully created and published DID: \"{}\"", did);
Diff in /app/src/tsp/create_did_modal.rs:423:
[31m-                    status_label.apply_over(cx, live!(
[m[31m-                        text: (message),
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_FG_ACCEPT_GREEN),
[m[31m-                        },
[m[31m-                    ));
[m[31m-                    accept_button.apply_over(cx, live!(
[m[31m-                        enabled: true,
[m[31m-                        text: "Okay",
[m[31m-                        draw_bg: {
[m[31m-                            color: (COLOR_ACTIVE_PRIMARY),
[m[31m-                        },
[m[31m-                        draw_icon: {
[m[31m-                            color: (COLOR_PRIMARY),
[m[31m-                        }
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_PRIMARY),
[m[31m-                        },
[m[31m-                    ));
[m[32m+                    status_label.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            text: (message),
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_FG_ACCEPT_GREEN),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m[32m+                    accept_button.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            enabled: true,
[m[32m+                            text: "Okay",
[m[32m+                            draw_bg: {
[m[32m+                                color: (COLOR_ACTIVE_PRIMARY),
[m[32m+                            },
[m[32m+                            draw_icon: {
[m[32m+                                color: (COLOR_PRIMARY),
[m[32m+                            }
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_PRIMARY),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m                     cancel_button.set_visible(cx, false);
                     needs_redraw = true;
                 }
Diff in /app/src/tsp/create_did_modal.rs:445:

                 // Upon an error, update the status label and disable the accept button.
                 // Re-enable the input fields so the user can change the input values to try again.
[31m-                Some(tsp::TspIdentityAction::DidCreationResult(Err(e)))=> {
[m[32m+                Some(tsp::TspIdentityAction::DidCreationResult(Err(e))) => {
[m                     self.state = CreateDidModalState::IdentityCreationError;
                     self.is_showing_error = true;
                     let message = format!("Failed to create DID: {e}");
Diff in /app/src/tsp/create_did_modal.rs:452:
[31m-                    status_label.apply_over(cx, live!(
[m[31m-                        text: (message),
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_FG_DANGER_RED),
[m[31m-                        },
[m[31m-                    ));
[m[32m+                    status_label.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            text: (message),
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_FG_DANGER_RED),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m                     accept_button.set_enabled(cx, false);
                     cancel_button.set_enabled(cx, true);
                     username_input.set_is_read_only(cx, false);
Diff in /app/src/tsp/create_did_modal.rs:464:
                     needs_redraw = true;
                 }

[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }
[31m-
[m[32m+
[m         if needs_redraw {
             self.view.redraw(cx);
         }
Diff in /app/src/tsp/create_did_modal.rs:488:
         accept_button.set_visible(cx, true);
         cancel_button.set_visible(cx, true);
         // TODO: return buttons to their default state/appearance
[31m-        self.view.text_input(ids!(username_input)).set_is_read_only(cx, false);
[m[31m-        self.view.text_input(ids!(alias_input)).set_is_read_only(cx, false);
[m[31m-        self.view.text_input(ids!(server_input)).set_is_read_only(cx, false);
[m[31m-        self.view.text_input(ids!(did_server_input)).set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(username_input))
[m[32m+            .set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(alias_input))
[m[32m+            .set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(server_input))
[m[32m+            .set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(did_server_input))
[m[32m+            .set_is_read_only(cx, false);
[m         self.view.label(ids!(status_label)).set_text(cx, "");
         self.is_showing_error = false;
[31m-        self.view.redraw(cx);
[m[32m+        self.view.redraw(cx);
[m     }
 }

Diff in /app/src/tsp/create_did_modal.rs:501:
 impl CreateDidModalRef {
     pub fn show(&self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx);
     }
 }
Diff in /app/src/tsp/create_wallet_modal.rs:2:

 use makepad_widgets::*;

[31m-use crate::{shared::styles::*, tsp::{self, TspWalletMetadata}};
[m[32m+use crate::{
[m[32m+    shared::styles::*,
[m[32m+    tsp::{self, TspWalletMetadata},
[m[32m+};
[m
[31m-
[m live_design! {
     link tsp_enabled

Diff in /app/src/tsp/create_wallet_modal.rs:157:
                         color: (COLOR_FG_DANGER_RED),
                     }
                     icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                     draw_bg: {
                         border_color: (COLOR_FG_DANGER_RED),
                         color: (COLOR_BG_DANGER_RED)
Diff in /app/src/tsp/create_wallet_modal.rs:228:
     WalletCreationError,
 }

[31m-
[m #[derive(Live, LiveHook, Widget)]
 pub struct CreateWalletModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: CreateWalletModalState,
[m[31m-    #[rust] is_showing_error: bool,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: CreateWalletModalState,
[m[32m+    #[rust]
[m[32m+    is_showing_error: bool,
[m }

 impl Widget for CreateWalletModal {
Diff in /app/src/tsp/create_wallet_modal.rs:254:

         // Handle canceling/closing the modal.
         let cancel_clicked = cancel_button.clicked(actions);
[31m-        if cancel_clicked ||
[m[31m-            actions.iter().any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m[32m+        if cancel_clicked
[m[32m+            || actions
[m[32m+                .iter()
[m[32m+                .any(|a| matches!(a.downcast_ref(), Some(ModalAction::Dismissed)))
[m         {
             // If the modal was dismissed by clicking outside of it, we MUST NOT emit
             // a `CreateWalletModalAction::Close` action, as that would cause
Diff in /app/src/tsp/create_wallet_modal.rs:293:
                     // Check to ensure that the user has entered all required fields.
                     if password.is_empty() || confirm_password.is_empty() {
                         self.is_showing_error = true;
[31m-                        status_label.apply_over(cx, live!(
[m[31m-                            text: "Please enter a wallet password.",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_FG_DANGER_RED),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Please enter a wallet password.",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_FG_DANGER_RED),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                     } else if password != confirm_password {
                         self.is_showing_error = true;
[31m-                        status_label.apply_over(cx, live!(
[m[31m-                            text: "Passwords do not match.",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_FG_DANGER_RED),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Passwords do not match.",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_FG_DANGER_RED),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                     } else if wallet_name.is_empty() {
                         self.is_showing_error = true;
[31m-                        status_label.apply_over(cx, live!(
[m[31m-                            text: "Please enter a wallet name.",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_FG_DANGER_RED),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Please enter a wallet name.",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_FG_DANGER_RED),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                     } else {
                         let url = tsp::TspWalletSqliteUrl::from_wallet_file_name(
                             match wallet_file_name_input.text() {
Diff in /app/src/tsp/create_wallet_modal.rs:321:
                                 empty if empty.is_empty() => wallet_file_name_input.empty_text(),
                                 non_empty => tsp::sanitize_wallet_name(&non_empty),
                             }
[31m-                            .as_str()
[m[32m+                            .as_str(),
[m                         );
                         let metadata = TspWalletMetadata {
                             wallet_name,
Diff in /app/src/tsp/create_wallet_modal.rs:332:
                         tsp::submit_tsp_request(tsp::TspRequest::CreateWallet { metadata });
                         self.state = CreateWalletModalState::WaitingForWalletCreation;
                         self.is_showing_error = false;
[31m-                        status_label.apply_over(cx, live!(
[m[31m-                            text: "Waiting for wallet to be created...",
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_ACTIVE_PRIMARY_DARKER),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        status_label.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Waiting for wallet to be created...",
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_ACTIVE_PRIMARY_DARKER),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                         accept_button.set_enabled(cx, false);
                         cancel_button.set_enabled(cx, false); // TODO: support canceling the wallet creation request?
                         wallet_name_input.set_is_read_only(cx, true);
Diff in /app/src/tsp/create_wallet_modal.rs:349:
                     needs_redraw = true;
                 }

[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }

Diff in /app/src/tsp/create_wallet_modal.rs:356:
[31m-
[m         // Clear the error message if the user changes any of the input fields.
         if self.is_showing_error {
             if wallet_name_input.changed(actions).is_some()
Diff in /app/src/tsp/create_wallet_modal.rs:364:
                 self.is_showing_error = false;
                 self.view.label(ids!(status_label)).set_text(cx, "");
                 self.state = CreateWalletModalState::WaitingForUserInput;
[31m-                accept_button.apply_over(cx, live!(
[m[31m-                    text: "Create Wallet",
[m[31m-                    enabled: true,
[m[31m-                    draw_text: {
[m[31m-                        color: (COLOR_FG_ACCEPT_GREEN),
[m[31m-                    },
[m[31m-                ));
[m[32m+                accept_button.apply_over(
[m[32m+                    cx,
[m[32m+                    live!(
[m[32m+                        text: "Create Wallet",
[m[32m+                        enabled: true,
[m[32m+                        draw_text: {
[m[32m+                            color: (COLOR_FG_ACCEPT_GREEN),
[m[32m+                        },
[m[32m+                    ),
[m[32m+                );
[m                 needs_redraw = true;
             }
         }
Diff in /app/src/tsp/create_wallet_modal.rs:384:
         for action in actions {
             match action.downcast_ref() {
                 // Handle the wallet creation success action.
[31m-                Some(tsp::TspWalletAction::CreateWalletSuccess { metadata, is_default }) => {
[m[32m+                Some(tsp::TspWalletAction::CreateWalletSuccess {
[m[32m+                    metadata,
[m[32m+                    is_default,
[m[32m+                }) => {
[m                     self.state = CreateWalletModalState::WalletCreated;
                     self.is_showing_error = false;
                     let message = if *is_default {
Diff in /app/src/tsp/create_wallet_modal.rs:391:
[31m-                        format!("Wallet \"{}\" created successfully and set as the default.", metadata.wallet_name)
[m[32m+                        format!(
[m[32m+                            "Wallet \"{}\" created successfully and set as the default.",
[m[32m+                            metadata.wallet_name
[m[32m+                        )
[m                     } else {
                         format!("Wallet \"{}\" created successfully.", metadata.wallet_name)
                     };
Diff in /app/src/tsp/create_wallet_modal.rs:395:
[31m-                    status_label.apply_over(cx, live!(
[m[31m-                        text: (message),
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_FG_ACCEPT_GREEN),
[m[31m-                        },
[m[31m-                    ));
[m[31m-                    accept_button.apply_over(cx, live!(
[m[31m-                        enabled: true,
[m[31m-                        text: "Okay",
[m[31m-                        draw_bg: {
[m[31m-                            color: (COLOR_ACTIVE_PRIMARY),
[m[31m-                        },
[m[31m-                        draw_icon: {
[m[31m-                            color: (COLOR_PRIMARY),
[m[31m-                        }
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_PRIMARY),
[m[31m-                        },
[m[31m-                    ));
[m[32m+                    status_label.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            text: (message),
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_FG_ACCEPT_GREEN),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m[32m+                    accept_button.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            enabled: true,
[m[32m+                            text: "Okay",
[m[32m+                            draw_bg: {
[m[32m+                                color: (COLOR_ACTIVE_PRIMARY),
[m[32m+                            },
[m[32m+                            draw_icon: {
[m[32m+                                color: (COLOR_PRIMARY),
[m[32m+                            }
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_PRIMARY),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m                     cancel_button.set_visible(cx, false);
                 }

Diff in /app/src/tsp/create_wallet_modal.rs:419:
                     self.state = CreateWalletModalState::WalletCreationError;
                     self.is_showing_error = true;
                     let message = format!("Failed to create wallet: {error}.");
[31m-                    status_label.apply_over(cx, live!(
[m[31m-                        text: (message),
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_FG_DANGER_RED),
[m[31m-                        },
[m[31m-                    ));
[m[32m+                    status_label.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            text: (message),
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_FG_DANGER_RED),
[m[32m+                            },
[m[32m+                        ),
[m[32m+                    );
[m                     accept_button.set_enabled(cx, false);
                     cancel_button.set_enabled(cx, true);
                     wallet_name_input.set_is_read_only(cx, false);
Diff in /app/src/tsp/create_wallet_modal.rs:433:
                     confirm_password_input.set_is_read_only(cx, false);
                 }

[31m-                _ => { }
[m[32m+                _ => {}
[m             }
         }
[31m-
[m[32m+
[m         if needs_redraw {
             self.view.redraw(cx);
         }
Diff in /app/src/tsp/create_wallet_modal.rs:457:
         accept_button.set_visible(cx, true);
         cancel_button.set_visible(cx, true);
         // TODO: return buttons to their default state/appearance
[31m-        self.view.text_input(ids!(wallet_name_input)).set_is_read_only(cx, false);
[m[31m-        self.view.text_input(ids!(wallet_file_name_input)).set_is_read_only(cx, false);
[m[31m-        self.view.text_input(ids!(password_input)).set_is_read_only(cx, false);
[m[31m-        self.view.text_input(ids!(confirm_password_input)).set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(wallet_name_input))
[m[32m+            .set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(wallet_file_name_input))
[m[32m+            .set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(password_input))
[m[32m+            .set_is_read_only(cx, false);
[m[32m+        self.view
[m[32m+            .text_input(ids!(confirm_password_input))
[m[32m+            .set_is_read_only(cx, false);
[m         self.view.label(ids!(status_label)).set_text(cx, "");
         self.is_showing_error = false;
[31m-        self.view.redraw(cx);
[m[32m+        self.view.redraw(cx);
[m     }
 }

Diff in /app/src/tsp/create_wallet_modal.rs:470:
 impl CreateWalletModalRef {
     pub fn show(&self, cx: &mut Cx) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx);
     }
 }
Diff in /app/src/tsp/mod.rs:1:
[31m-use std::{borrow::Cow, collections::BTreeMap, ops::Deref, path::Path, sync::{Arc, Mutex, OnceLock}};
[m[32m+use std::{
[m[32m+    borrow::Cow,
[m[32m+    collections::BTreeMap,
[m[32m+    ops::Deref,
[m[32m+    path::Path,
[m[32m+    sync::{Arc, Mutex, OnceLock},
[m[32m+};
[m
 use anyhow::anyhow;
 use futures_util::StreamExt;
Diff in /app/src/tsp/mod.rs:6:
 use matrix_sdk::ruma::{OwnedUserId, UserId};
 use quinn::rustls::crypto::{CryptoProvider, aws_lc_rs};
 use serde::{Deserialize, Serialize};
[31m-use tokio::{task::JoinHandle, runtime::Handle, sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender}};
[m[31m-use tsp_sdk::{definitions::{PublicKeyData, PublicVerificationKeyData, VidEncryptionKeyType, VidSignatureKeyType}, vid::{verify_vid, VidError}, AskarSecureStorage, AsyncSecureStore, OwnedVid, ReceivedTspMessage, SecureStorage, VerifiedVid, Vid};
[m[32m+use tokio::{
[m[32m+    task::JoinHandle,
[m[32m+    runtime::Handle,
[m[32m+    sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},
[m[32m+};
[m[32m+use tsp_sdk::{
[m[32m+    definitions::{
[m[32m+        PublicKeyData, PublicVerificationKeyData, VidEncryptionKeyType, VidSignatureKeyType,
[m[32m+    },
[m[32m+    vid::{verify_vid, VidError},
[m[32m+    AskarSecureStorage, AsyncSecureStore, OwnedVid, ReceivedTspMessage, SecureStorage, VerifiedVid,
[m[32m+    Vid,
[m[32m+};
[m use url::Url;

[31m-use crate::{persistence::{self, tsp_wallets_dir, SavedTspState}, shared::popup_list::{enqueue_popup_notification, PopupKind}, sliding_sync::current_user_id, tsp::tsp_verification_modal::TspVerificationModalAction, utils::DebugWrapper};
[m[32m+use crate::{
[m[32m+    persistence::{self, tsp_wallets_dir, SavedTspState},
[m[32m+    shared::popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+    sliding_sync::current_user_id,
[m[32m+    tsp::tsp_verification_modal::TspVerificationModalAction,
[m[32m+    utils::DebugWrapper,
[m[32m+};
[m
[31m-
[m pub mod create_did_modal;
 pub mod create_wallet_modal;
 pub mod sign_anycast_checkbox;
Diff in /app/src/tsp/mod.rs:68:
     sender: UnboundedSender<TspReceiveLoopRequest>,
 }

[31m-
[m /// The global singleton TSP state, storing all known TSP wallets.
 static TSP_STATE: Mutex<TspState> = Mutex::new(TspState::new());
 pub fn tsp_state_ref() -> &'static Mutex<TspState> {
Diff in /app/src/tsp/mod.rs:143:
                     log!("Restored current local VID {saved_local_vid} from in default wallet.");
                     current_local_vid = Some(saved_local_vid);
                 } else {
[31m-                    warning!("Previously-saved local VID {saved_local_vid} was not found in default wallet.");
[m[32m+                    warning!(
[m[32m+                        "Previously-saved local VID {saved_local_vid} was not found in default wallet."
[m[32m+                    );
[m                     enqueue_popup_notification(
[31m-                        format!("Previously-saved local VID \"{saved_local_vid}\" \
[m[32m+                        format!(
[m[32m+                            "Previously-saved local VID \"{saved_local_vid}\" \
[m                             was not found in default wallet.\n\n\
[31m-                            Please select a default wallet and then a new default VID."),
[m[31m-                         PopupKind::Warning,
[m[31m-                         None,
[m[32m+                            Please select a default wallet and then a new default VID."
[m[32m+                        ),
[m[32m+                        PopupKind::Warning,
[m[32m+                        None,
[m                     );
                 }
             } else {
Diff in /app/src/tsp/mod.rs:156:
[31m-                warning!("Found a previously-saved local VID {saved_local_vid}, but not the default wallet that contained it.");
[m[32m+                warning!(
[m[32m+                    "Found a previously-saved local VID {saved_local_vid}, but not the default wallet that contained it."
[m[32m+                );
[m                 enqueue_popup_notification(
[31m-                    format!("Found a previously-saved local VID \"{saved_local_vid}\", \
[m[32m+                    format!(
[m[32m+                        "Found a previously-saved local VID \"{saved_local_vid}\", \
[m                         but not the default wallet that contained it.\n\n\
[31m-                        Please select or create a default wallet and a new default VID."),
[m[32m+                        Please select or create a default wallet and a new default VID."
[m[32m+                    ),
[m                     PopupKind::Warning,
                     None,
                 );
Diff in /app/src/tsp/mod.rs:185:
     pub async fn close_and_serialize(self) -> Result<SavedTspState, tsp_sdk::Error> {
         let mut default_wallet = None;
         let mut wallets = Vec::<TspWalletMetadata>::with_capacity(
[31m-            self.current_wallet.is_some() as usize + self.other_wallets.len()
[m[32m+            self.current_wallet.is_some() as usize + self.other_wallets.len(),
[m         );

         if let Some(current_wallet) = self.current_wallet {
Diff in /app/src/tsp/mod.rs:216:

     /// Returns the verified VID for a given Matrix user ID, if the association exists
     /// and the user's associated DID is in the current default wallet.
[31m-    pub fn get_verified_vid_for(
[m[31m-        &self,
[m[31m-        user_id: &UserId,
[m[31m-    ) -> Option<Arc<dyn VerifiedVid>> {
[m[32m+    pub fn get_verified_vid_for(&self, user_id: &UserId) -> Option<Arc<dyn VerifiedVid>> {
[m         let did = self.get_associated_did(user_id)?;
[31m-        self.current_wallet.as_ref()?
[m[32m+        self.current_wallet
[m[32m+            .as_ref()?
[m             .db
             .as_store()
             .get_verified_vid(did)
Diff in /app/src/tsp/mod.rs:242:
         }

         let (sender, receiver) = unbounded_channel::<TspReceiveLoopRequest>();
[31m-        let join_handle = rt_handle.spawn(
[m[31m-            receive_messages_for_vid(wallet_db.clone(), vid.to_string(), receiver)
[m[31m-        );
[m[32m+        let join_handle = rt_handle.spawn(receive_messages_for_vid(
[m[32m+            wallet_db.clone(),
[m[32m+            vid.to_string(),
[m[32m+            receiver,
[m[32m+        ));
[m         let old = self.receive_loop_tasks.insert(
             vid.to_string(),
[31m-            ReceiveLoopTask { join_handle, sender: sender.clone() }
[m[32m+            ReceiveLoopTask {
[m[32m+                join_handle,
[m[32m+                sender: sender.clone(),
[m[32m+            },
[m         );
         if let Some(old) = old {
             warning!("BUG: aborting previous receive loop for VID \"{}\".", vid);
Diff in /app/src/tsp/mod.rs:257:
     }
 }

[31m-
[m /// A TSP wallet entry known to Robrix. Derefs to `TspWalletMetadata`.
 #[derive(Debug)]
 pub enum TspWalletEntry {
Diff in /app/src/tsp/mod.rs:284:
     }
 }

[31m-
[m /// A TSP wallet that exists and is currently opened / ready to use.
 pub struct OpenedTspWallet {
     pub vault: AskarSecureStorage,
Diff in /app/src/tsp/mod.rs:378:
     // Create a channel to be used between UI thread(s) and the TSP async worker thread.
     // We do this early on in order to allow TSP init routines to submit requests.
     let (sender, receiver) = tokio::sync::mpsc::unbounded_channel::<TspRequest>();
[31m-    TSP_REQUEST_SENDER.set(sender).expect("BUG: TSP_REQUEST_SENDER already set!");
[m[32m+    TSP_REQUEST_SENDER
[m[32m+        .set(sender)
[m[32m+        .expect("BUG: TSP_REQUEST_SENDER already set!");
[m
     // Start a high-level async task that will start and monitor all other tasks.
     let _monitor = rt_handle.spawn(async move {
Diff in /app/src/tsp/mod.rs:445:
     Ok(())
 }

[31m-
[m async fn inner_tsp_init() -> anyhow::Result<()> {
     // Load the TSP state from persistent storage.
     let saved_tsp_state = persistence::load_tsp_state().await?;
Diff in /app/src/tsp/mod.rs:460:
     }
     // If there is a private VID and a current wallet, spawn a receive loop
     // to listen for incoming messages for that private VID.
[31m-    if let (Some(private_vid), Some(cw)) =
[m[31m-        (new_tsp_state.current_local_vid.clone(), new_tsp_state.current_wallet.as_ref())
[m[31m-    {
[m[32m+    if let (Some(private_vid), Some(cw)) = (
[m[32m+        new_tsp_state.current_local_vid.clone(),
[m[32m+        new_tsp_state.current_wallet.as_ref(),
[m[32m+    ) {
[m         log!("Starting receive loop for private VID \"{}\".", private_vid);
[31m-        new_tsp_state.get_or_spawn_receive_loop(
[m[31m-            Handle::current(),
[m[31m-            &cw.db.clone(),
[m[31m-            &private_vid,
[m[31m-        );
[m[32m+        new_tsp_state.get_or_spawn_receive_loop(Handle::current(), &cw.db.clone(), &private_vid);
[m     }
     *TSP_STATE.lock().unwrap() = new_tsp_state;
     Ok(())
Diff in /app/src/tsp/mod.rs:475:
 }

[31m-
[m /// Actions related to TSP wallets.
 #[derive(Debug)]
 pub enum TspWalletAction {
Diff in /app/src/tsp/mod.rs:514:
     /// with their Matrix user ID.
     ///
     /// This does *NOT* mean that the response has been received yet.
[31m-    SentDidAssociationRequest {
[m[31m-        did: String,
[m[31m-        user_id: OwnedUserId,
[m[31m-    },
[m[32m+    SentDidAssociationRequest { did: String, user_id: OwnedUserId },
[m     /// An error occurred while sending the request to associate another
     /// user's DID with their Matrix user ID.
     ErrorSendingDidAssociationRequest {
Diff in /app/src/tsp/mod.rs:548:
     },
 }

[31m-
[m /// Requests that can be sent to the TSP async worker thread.
 pub enum TspRequest {
     /// Request to create a new TSP wallet.
Diff in /app/src/tsp/mod.rs:555:
[31m-    CreateWallet {
[m[31m-        metadata: TspWalletMetadata,
[m[31m-    },
[m[32m+    CreateWallet { metadata: TspWalletMetadata },
[m     /// Request to open an existing TSP wallet.
     ///
     /// This does not modify the current active/default wallet.
Diff in /app/src/tsp/mod.rs:561:
     /// If the wallet exists in the list of other wallets, it will be opened in-place,
     /// otherwise it will be opened and added to the end of the other wallets list.
[31m-    OpenWallet {
[m[31m-        metadata: TspWalletMetadata,
[m[31m-    },
[m[32m+    OpenWallet { metadata: TspWalletMetadata },
[m     /// Request to set an existing open wallet as the default.
     SetDefaultWallet(TspWalletMetadata),
     /// Request to remove a TSP wallet from the list without deleting it.
Diff in /app/src/tsp/mod.rs:580:
     /// Request to re-publish/re-upload our own DID back up to the DID server.
     ///
     /// The given `did` must already exist in the current default wallet.
[31m-    RepublishDid {
[m[31m-        did: String,
[m[31m-    },
[m[32m+    RepublishDid { did: String },
[m     /// Request to associate another user's identity (DID) with their Matrix User ID.
     ///
     /// This will verify the DID and store it in the current default wallet
Diff in /app/src/tsp/mod.rs:589:
     /// (using their Matrix User ID as the alias for that new verified ID),
     /// and then send a verification/relationship request to that new verified ID.
[31m-    AssociateDidWithUserId {
[m[31m-        did: String,
[m[31m-        user_id: OwnedUserId,
[m[31m-    },
[m[32m+    AssociateDidWithUserId { did: String, user_id: OwnedUserId },
[m     /// Request to respond to a previously-received `DidAssociationRequest`.
     RespondToDidAssociationRequest {
         details: TspVerificationDetails,
Diff in /app/src/tsp/mod.rs:603:
     // CancelAssociateDidRequest(TspVerificationDetails),
 }

[31m-
[m fn create_reqwest_client() -> reqwest::Result<reqwest::Client> {
     reqwest::ClientBuilder::new()
         .user_agent(format!("Robrix v{}", env!("CARGO_PKG_VERSION")))
Diff in /app/src/tsp/mod.rs:610:
         .build()
 }

[31m-
[m /// The entry point for an async worker thread that processes TSP-related async tasks.
 ///
 /// All this task does is wait for [`TspRequests`] from other threads
Diff in /app/src/tsp/mod.rs:623:
     // Allow lazy initialization of the reqwest client.
     let mut __reqwest_client = None;
     let mut get_reqwest_client = || {
[31m-        __reqwest_client.get_or_insert_with(|| create_reqwest_client().unwrap()).clone()
[m[32m+        __reqwest_client
[m[32m+            .get_or_insert_with(|| create_reqwest_client().unwrap())
[m[32m+            .clone()
[m     };

[31m-    while let Some(req) = request_receiver.recv().await { match req {
[m[31m-        TspRequest::CreateWallet { metadata } => {
[m[31m-            log!("Received TspRequest::CreateWallet({metadata:?})");
[m[31m-            Handle::current().spawn(async move {
[m[31m-                if let Some(sqlite_path) = metadata.url.get_path() {
[m[31m-                    if let Ok(true) = tokio::fs::try_exists(sqlite_path).await {
[m[31m-                        error!("Wallet already exists at path: {}", sqlite_path.display());
[m[31m-                        Cx::post_action(TspWalletAction::CreateWalletError {
[m[31m-                            metadata: metadata.clone(),
[m[31m-                            error: anyhow!("Wallet already exists at path: {}", sqlite_path.display()),
[m[31m-                        });
[m[31m-                        return;
[m[31m-                    }
[m[31m-                    if let Some(parent_dir) = sqlite_path.parent() {
[m[31m-                        log!("Ensuring that new wallet's parent dir exists: {}", parent_dir.display());
[m[31m-                        if let Err(e) = tokio::fs::create_dir_all(parent_dir).await {
[m[31m-                            error!("Failed to create directory to hold new wallet: {e:?}");
[m[32m+    while let Some(req) = request_receiver.recv().await {
[m[32m+        match req {
[m[32m+            TspRequest::CreateWallet { metadata } => {
[m[32m+                log!("Received TspRequest::CreateWallet({metadata:?})");
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    if let Some(sqlite_path) = metadata.url.get_path() {
[m[32m+                        if let Ok(true) = tokio::fs::try_exists(sqlite_path).await {
[m[32m+                            error!("Wallet already exists at path: {}", sqlite_path.display());
[m                             Cx::post_action(TspWalletAction::CreateWalletError {
                                 metadata: metadata.clone(),
[31m-                                error: anyhow!("Failed to create directory for new wallet: {}, error: {}", parent_dir.display(), e),
[m[32m+                                error: anyhow!(
[m[32m+                                    "Wallet already exists at path: {}",
[m[32m+                                    sqlite_path.display()
[m[32m+                                ),
[m                             });
                             return;
                         }
Diff in /app/src/tsp/mod.rs:652:
[31m-                    }
[m[31m-                }
[m[31m-                let encoded_url = metadata.url.to_url_encoded();
[m[31m-                log!("Attempting to create new wallet at:\n   Reg: {}\n   Enc: {}", metadata.url, encoded_url);
[m[31m-                match AskarSecureStorage::new(&encoded_url, metadata.password.as_bytes()).await {
[m[31m-                    Ok(vault) => {
[m[31m-                        log!("Successfully created new wallet: {metadata:?}");
[m[31m-                        let db = AsyncSecureStore::new();
[m[31m-                        let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[31m-                        let opened_wallet = OpenedTspWallet {
[m[31m-                            vault,
[m[31m-                            db,
[m[31m-                            metadata: metadata.clone(),
[m[31m-                        };
[m[31m-                        let is_default: bool;
[m[31m-                        if tsp_state.current_wallet.is_none() {
[m[31m-                            tsp_state.current_wallet = Some(opened_wallet);
[m[31m-                            is_default = true;
[m[31m-                        } else {
[m[31m-                            tsp_state.other_wallets.push(TspWalletEntry::Opened(opened_wallet));
[m[31m-                            is_default = false;
[m[32m+                        if let Some(parent_dir) = sqlite_path.parent() {
[m[32m+                            log!(
[m[32m+                                "Ensuring that new wallet's parent dir exists: {}",
[m[32m+                                parent_dir.display()
[m[32m+                            );
[m[32m+                            if let Err(e) = tokio::fs::create_dir_all(parent_dir).await {
[m[32m+                                error!("Failed to create directory to hold new wallet: {e:?}");
[m[32m+                                Cx::post_action(TspWalletAction::CreateWalletError {
[m[32m+                                    metadata: metadata.clone(),
[m[32m+                                    error: anyhow!(
[m[32m+                                        "Failed to create directory for new wallet: {}, error: {}",
[m[32m+                                        parent_dir.display(),
[m[32m+                                        e
[m[32m+                                    ),
[m[32m+                                });
[m[32m+                                return;
[m[32m+                            }
[m                         }
[31m-                        Cx::post_action(
[m[31m-                            TspWalletAction::CreateWalletSuccess {
[m[32m+                    }
[m[32m+                    let encoded_url = metadata.url.to_url_encoded();
[m[32m+                    log!(
[m[32m+                        "Attempting to create new wallet at:\n   Reg: {}\n   Enc: {}",
[m[32m+                        metadata.url,
[m[32m+                        encoded_url
[m[32m+                    );
[m[32m+                    match AskarSecureStorage::new(&encoded_url, metadata.password.as_bytes()).await
[m[32m+                    {
[m[32m+                        Ok(vault) => {
[m[32m+                            log!("Successfully created new wallet: {metadata:?}");
[m[32m+                            let db = AsyncSecureStore::new();
[m[32m+                            let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[32m+                            let opened_wallet = OpenedTspWallet {
[m[32m+                                vault,
[m[32m+                                db,
[m[32m+                                metadata: metadata.clone(),
[m[32m+                            };
[m[32m+                            let is_default: bool;
[m[32m+                            if tsp_state.current_wallet.is_none() {
[m[32m+                                tsp_state.current_wallet = Some(opened_wallet);
[m[32m+                                is_default = true;
[m[32m+                            } else {
[m[32m+                                tsp_state
[m[32m+                                    .other_wallets
[m[32m+                                    .push(TspWalletEntry::Opened(opened_wallet));
[m[32m+                                is_default = false;
[m[32m+                            }
[m[32m+                            Cx::post_action(TspWalletAction::CreateWalletSuccess {
[m                                 metadata,
                                 is_default,
[31m-                            }
[m[31m-                        );
[m[31m-                    }
[m[31m-                    Err(error) => {
[m[31m-                        error!("Failed to create new wallet: {error:?}");
[m[31m-                        Cx::post_action(
[m[31m-                            TspWalletAction::CreateWalletError {
[m[32m+                            });
[m[32m+                        }
[m[32m+                        Err(error) => {
[m[32m+                            error!("Failed to create new wallet: {error:?}");
[m[32m+                            Cx::post_action(TspWalletAction::CreateWalletError {
[m                                 metadata: metadata.clone(),
                                 error: error.into(),
[31m-                            }
[m[31m-                        );
[m[32m+                            });
[m[32m+                        }
[m                     }
[31m-                }
[m[31m-            });
[m[31m-        }
[m[31m-
[m[31m-        TspRequest::SetDefaultWallet(metadata) => {
[m[31m-            log!("Received TspRequest::SetDefaultWallet({metadata:?})");
[m[31m-            match tsp_state_ref().lock().unwrap().current_wallet.as_ref() {
[m[31m-                Some(cw) if cw.metadata == metadata => {
[m[31m-                    log!("Wallet was already set as default: {metadata:?}");
[m[31m-                    continue;
[m[31m-                }
[m[31m-                _ => {}
[m[32m+                });
[m             }

[31m-            // If the new default wallet exists and is already opened, set it as default.
[m[31m-            Handle::current().spawn(async move {
[m[31m-                let mut result = Err(());
[m[31m-                let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[31m-                if let Some(TspWalletEntry::Opened(opened)) = tsp_state.other_wallets.iter()
[m[31m-                    .position(|w| match w {
[m[31m-                        TspWalletEntry::Opened(opened) => opened.metadata == metadata,
[m[31m-                        _ => false,
[m[31m-                    })
[m[31m-                    .map(|idx| tsp_state.other_wallets.remove(idx))
[m[31m-                {
[m[31m-                    let prev_opt = tsp_state.current_wallet.replace(opened);
[m[31m-                    if let Some(previous_active) = prev_opt {
[m[31m-                        tsp_state.other_wallets.insert(0, TspWalletEntry::Opened(previous_active));
[m[32m+            TspRequest::SetDefaultWallet(metadata) => {
[m[32m+                log!("Received TspRequest::SetDefaultWallet({metadata:?})");
[m[32m+                match tsp_state_ref().lock().unwrap().current_wallet.as_ref() {
[m[32m+                    Some(cw) if cw.metadata == metadata => {
[m[32m+                        log!("Wallet was already set as default: {metadata:?}");
[m[32m+                        continue;
[m                     }
[31m-                    result = Ok(metadata);
[m[32m+                    _ => {}
[m                 }
[31m-                Cx::post_action(TspWalletAction::DefaultWalletChanged(result));
[m[31m-            });
[m[31m-        }
[m
[31m-        TspRequest::OpenWallet { metadata } => {
[m[31m-            log!("Received TspRequest::OpenWallet({metadata:?})");
[m[31m-            Handle::current().spawn(async move {
[m[31m-                let result = match metadata.open_wallet().await {
[m[31m-                    Ok(opened_wallet) => {
[m[31m-                        log!("Successfully opened wallet: {metadata:?}");
[m[31m-                        let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[31m-                        // If the newly-opened wallet exists in the other wallets list,
[m[31m-                        // convert it into an opened wallet in-place.
[m[31m-                        // Otherwise, add it to the end of the other wallet list
[m[31m-                        if let Some(w) = tsp_state.other_wallets.iter_mut().find(|w| w.metadata() == &metadata) {
[m[31m-                            *w = TspWalletEntry::Opened(opened_wallet);
[m[31m-                        } else {
[m[31m-                            tsp_state.other_wallets.push(TspWalletEntry::Opened(opened_wallet));
[m[32m+                // If the new default wallet exists and is already opened, set it as default.
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let mut result = Err(());
[m[32m+                    let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[32m+                    if let Some(TspWalletEntry::Opened(opened)) = tsp_state
[m[32m+                        .other_wallets
[m[32m+                        .iter()
[m[32m+                        .position(|w| match w {
[m[32m+                            TspWalletEntry::Opened(opened) => opened.metadata == metadata,
[m[32m+                            _ => false,
[m[32m+                        })
[m[32m+                        .map(|idx| tsp_state.other_wallets.remove(idx))
[m[32m+                    {
[m[32m+                        let prev_opt = tsp_state.current_wallet.replace(opened);
[m[32m+                        if let Some(previous_active) = prev_opt {
[m[32m+                            tsp_state
[m[32m+                                .other_wallets
[m[32m+                                .insert(0, TspWalletEntry::Opened(previous_active));
[m                         }
[31m-                        Ok(metadata)
[m[32m+                        result = Ok(metadata);
[m                     }
[31m-                    Err(error) => {
[m[31m-                        error!("Error opening wallet {metadata:?}: {error:?}");
[m[31m-                        Err(error)
[m[31m-                    }
[m[31m-                };
[m[31m-                Cx::post_action(TspWalletAction::WalletOpened(result));
[m[31m-            });
[m[31m-        }
[m[32m+                    Cx::post_action(TspWalletAction::DefaultWalletChanged(result));
[m[32m+                });
[m[32m+            }
[m
[31m-        TspRequest::RemoveWallet(metadata) => {
[m[31m-            log!("Received TspRequest::RemoveWallet({metadata:?})");
[m[31m-            Handle::current().spawn(async move {
[m[31m-                let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[31m-                let was_default = if tsp_state.current_wallet.as_ref().is_some_and(|cw| cw.metadata == metadata) {
[m[31m-                    tsp_state.current_wallet = None;
[m[31m-                    true
[m[31m-                }
[m[31m-                else if let Some(i) = tsp_state.other_wallets.iter().position(|w| w.metadata() == &metadata) {
[m[31m-                    tsp_state.other_wallets.remove(i);
[m[31m-                    false
[m[31m-                } else {
[m[31m-                    error!("BUG: failed to remove wallet not found in TSP state: {metadata:?}");
[m[31m-                    return;
[m[31m-                };
[m[31m-                Cx::post_action(TspWalletAction::WalletRemoved { metadata, was_default });
[m[31m-            });
[m[31m-        }
[m[32m+            TspRequest::OpenWallet { metadata } => {
[m[32m+                log!("Received TspRequest::OpenWallet({metadata:?})");
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let result = match metadata.open_wallet().await {
[m[32m+                        Ok(opened_wallet) => {
[m[32m+                            log!("Successfully opened wallet: {metadata:?}");
[m[32m+                            let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[32m+                            // If the newly-opened wallet exists in the other wallets list,
[m[32m+                            // convert it into an opened wallet in-place.
[m[32m+                            // Otherwise, add it to the end of the other wallet list
[m[32m+                            if let Some(w) = tsp_state
[m[32m+                                .other_wallets
[m[32m+                                .iter_mut()
[m[32m+                                .find(|w| w.metadata() == &metadata)
[m[32m+                            {
[m[32m+                                *w = TspWalletEntry::Opened(opened_wallet);
[m[32m+                            } else {
[m[32m+                                tsp_state
[m[32m+                                    .other_wallets
[m[32m+                                    .push(TspWalletEntry::Opened(opened_wallet));
[m[32m+                            }
[m[32m+                            Ok(metadata)
[m[32m+                        }
[m[32m+                        Err(error) => {
[m[32m+                            error!("Error opening wallet {metadata:?}: {error:?}");
[m[32m+                            Err(error)
[m[32m+                        }
[m[32m+                    };
[m[32m+                    Cx::post_action(TspWalletAction::WalletOpened(result));
[m[32m+                });
[m[32m+            }
[m
[31m-        TspRequest::DeleteWallet(metadata) => {
[m[31m-            log!("Received TspRequest::DeleteWallet({metadata:?})");
[m[31m-            todo!("handle deleting a wallet");
[m[31m-        }
[m[32m+            TspRequest::RemoveWallet(metadata) => {
[m[32m+                log!("Received TspRequest::RemoveWallet({metadata:?})");
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let mut tsp_state = tsp_state_ref().lock().unwrap();
[m[32m+                    let was_default = if tsp_state
[m[32m+                        .current_wallet
[m[32m+                        .as_ref()
[m[32m+                        .is_some_and(|cw| cw.metadata == metadata)
[m[32m+                    {
[m[32m+                        tsp_state.current_wallet = None;
[m[32m+                        true
[m[32m+                    } else if let Some(i) = tsp_state
[m[32m+                        .other_wallets
[m[32m+                        .iter()
[m[32m+                        .position(|w| w.metadata() == &metadata)
[m[32m+                    {
[m[32m+                        tsp_state.other_wallets.remove(i);
[m[32m+                        false
[m[32m+                    } else {
[m[32m+                        error!("BUG: failed to remove wallet not found in TSP state: {metadata:?}");
[m[32m+                        return;
[m[32m+                    };
[m[32m+                    Cx::post_action(TspWalletAction::WalletRemoved {
[m[32m+                        metadata,
[m[32m+                        was_default,
[m[32m+                    });
[m[32m+                });
[m[32m+            }
[m
[31m-        TspRequest::CreateDid { username, alias, server, did_server } => {
[m[31m-            log!("Received TspRequest::CreateDid(username: {username}, alias: {alias:?}, server: {server}, did_server: {did_server})");
[m[31m-            let client = get_reqwest_client();
[m[32m+            TspRequest::DeleteWallet(metadata) => {
[m[32m+                log!("Received TspRequest::DeleteWallet({metadata:?})");
[m[32m+                todo!("handle deleting a wallet");
[m[32m+            }
[m
[31m-            Handle::current().spawn(async move {
[m[31m-                let result = create_did_and_add_to_wallet(
[m[31m-                    &client,
[m[31m-                    username,
[m[31m-                    alias,
[m[31m-                    server,
[m[31m-                    did_server,
[m[31m-                ).await;
[m[31m-                Cx::post_action(TspIdentityAction::DidCreationResult(result));
[m[31m-            });
[m[31m-        }
[m[32m+            TspRequest::CreateDid {
[m[32m+                username,
[m[32m+                alias,
[m[32m+                server,
[m[32m+                did_server,
[m[32m+            } => {
[m[32m+                log!(
[m[32m+                    "Received TspRequest::CreateDid(username: {username}, alias: {alias:?}, server: {server}, did_server: {did_server})"
[m[32m+                );
[m[32m+                let client = get_reqwest_client();
[m
[31m-        TspRequest::RepublishDid { did } => {
[m[31m-            log!("Received TspRequest::RepublishDid(did: {did})");
[m[31m-            let client = get_reqwest_client();
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let result =
[m[32m+                        create_did_and_add_to_wallet(&client, username, alias, server, did_server)
[m[32m+                            .await;
[m[32m+                    Cx::post_action(TspIdentityAction::DidCreationResult(result));
[m[32m+                });
[m[32m+            }
[m
[31m-            Handle::current().spawn(async move {
[m[31m-                let result = republish_did(&did, &client).await
[m[31m-                    .map(|_| did);
[m[31m-                Cx::post_action(TspIdentityAction::DidRepublishResult(result));
[m[31m-            });
[m[31m-        }
[m[32m+            TspRequest::RepublishDid { did } => {
[m[32m+                log!("Received TspRequest::RepublishDid(did: {did})");
[m[32m+                let client = get_reqwest_client();
[m
[31m-        TspRequest::AssociateDidWithUserId { did, user_id } => {
[m[31m-            log!("Received TspRequest::AssociateDidWithUserId(did: {did}, user_id: {user_id})");
[m[31m-            Handle::current().spawn(async move {
[m[31m-                let action = match associate_did_with_user_id(&did, &user_id).await {
[m[31m-                    Ok(_) => TspIdentityAction::SentDidAssociationRequest { did, user_id },
[m[31m-                    Err(error) => TspIdentityAction::ErrorSendingDidAssociationRequest { did, user_id, error },
[m[31m-                };
[m[31m-                Cx::post_action(action);
[m[31m-            });
[m[31m-        }
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let result = republish_did(&did, &client).await.map(|_| did);
[m[32m+                    Cx::post_action(TspIdentityAction::DidRepublishResult(result));
[m[32m+                });
[m[32m+            }
[m
[31m-        TspRequest::RespondToDidAssociationRequest { details, wallet_db, accepted } => {
[m[31m-            log!("Received TspRequest::RespondToDidAssociationRequest(details: {details:?}, accepted: {accepted})");
[m[31m-            Handle::current().spawn(async move {
[m[31m-                let result = respond_to_did_association_request(&details, &wallet_db, accepted).await;
[m[31m-                // If all was successful, add this new association to the TSP state.
[m[31m-                if result.is_ok() {
[m[31m-                    tsp_state_ref().lock().unwrap().associations.insert(
[m[31m-                        details.initiating_user_id.clone(),
[m[31m-                        details.initiating_vid.clone(),
[m[31m-                    );
[m[31m-                }
[m[31m-                Cx::post_action(TspVerificationModalAction::SentDidAssociationResponse {
[m[31m-                    details,
[m[31m-                    result,
[m[32m+            TspRequest::AssociateDidWithUserId { did, user_id } => {
[m[32m+                log!("Received TspRequest::AssociateDidWithUserId(did: {did}, user_id: {user_id})");
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let action = match associate_did_with_user_id(&did, &user_id).await {
[m[32m+                        Ok(_) => TspIdentityAction::SentDidAssociationRequest { did, user_id },
[m[32m+                        Err(error) => TspIdentityAction::ErrorSendingDidAssociationRequest {
[m[32m+                            did,
[m[32m+                            user_id,
[m[32m+                            error,
[m[32m+                        },
[m[32m+                    };
[m[32m+                    Cx::post_action(action);
[m                 });
[31m-            });
[m[32m+            }
[m[32m+
[m[32m+            TspRequest::RespondToDidAssociationRequest {
[m[32m+                details,
[m[32m+                wallet_db,
[m[32m+                accepted,
[m[32m+            } => {
[m[32m+                log!(
[m[32m+                    "Received TspRequest::RespondToDidAssociationRequest(details: {details:?}, accepted: {accepted})"
[m[32m+                );
[m[32m+                Handle::current().spawn(async move {
[m[32m+                    let result =
[m[32m+                        respond_to_did_association_request(&details, &wallet_db, accepted).await;
[m[32m+                    // If all was successful, add this new association to the TSP state.
[m[32m+                    if result.is_ok() {
[m[32m+                        tsp_state_ref().lock().unwrap().associations.insert(
[m[32m+                            details.initiating_user_id.clone(),
[m[32m+                            details.initiating_vid.clone(),
[m[32m+                        );
[m[32m+                    }
[m[32m+                    Cx::post_action(TspVerificationModalAction::SentDidAssociationResponse {
[m[32m+                        details,
[m[32m+                        result,
[m[32m+                    });
[m[32m+                });
[m[32m+            }
[m         }
     }
[31m-}
[m
     error!("async_tsp_worker task ended unexpectedly");
     anyhow::bail!("async_tsp_worker task ended unexpectedly")
Diff in /app/src/tsp/mod.rs:835:
 }

[31m-
[m /// Creates & publishes a new DID, adds it to the default wallet,
 /// and sets the new private VID to be default if none exists.
 ///
Diff in /app/src/tsp/mod.rs:846:
     server: String,
     did_server: String,
 ) -> Result<String, anyhow::Error> {
[31m-    let cw_db = tsp_state_ref().lock().unwrap()
[m[31m-        .current_wallet.as_ref()
[m[32m+    let cw_db = tsp_state_ref()
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .current_wallet
[m[32m+        .as_ref()
[m         .map(|w| w.db.clone())
         .ok_or_else(|| anyhow!("Please choose a default TSP wallet to hold the DID."))?;
[31m-    let (did, private_vid, metadata) = create_did_web(&did_server, &server, &username, client).await?;
[m[32m+    let (did, private_vid, metadata) =
[m[32m+        create_did_web(&did_server, &server, &username, client).await?;
[m     let new_vid = private_vid.identifier().to_string();
[31m-    log!("Successfully created & published new DID: {did}.\n\
[m[32m+    log!(
[m[32m+        "Successfully created & published new DID: {did}.\n\
[m         Adding private VID {new_vid} to current wallet...",
     );
     let did = store_did_in_wallet(&cw_db, private_vid, metadata, alias, did)?;
Diff in /app/src/tsp/mod.rs:863:
         // and start a receive loop to listen for incoming requests for it.
         let mut tsp_state = tsp_state_ref().lock().unwrap();
         if tsp_state.current_local_vid.is_none() {
[31m-            log!("Setting new VID \"{}\" (from DID \"{}\") as current local VID and starting receive loop...", new_vid, did);
[m[31m-            tsp_state.current_local_vid = Some(new_vid.clone());
[m[31m-            tsp_state.get_or_spawn_receive_loop(
[m[31m-                Handle::current(),
[m[31m-                &cw_db,
[m[31m-                &new_vid,
[m[32m+            log!(
[m[32m+                "Setting new VID \"{}\" (from DID \"{}\") as current local VID and starting receive loop...",
[m[32m+                new_vid,
[m[32m+                did
[m             );
[32m+            tsp_state.current_local_vid = Some(new_vid.clone());
[m[32m+            tsp_state.get_or_spawn_receive_loop(Handle::current(), &cw_db, &new_vid);
[m             if let Some(user_id) = current_user_id() {
                 tsp_state.associations
                     .entry(user_id.clone())
Diff in /app/src/tsp/mod.rs:902:
         username,
     );

[31m-    let transport = Url::parse(
[m[31m-        &format!("https://{}/endpoint/{}",
[m[31m-            server,
[m[31m-            &did.replace("%", "%25")
[m[31m-        )
[m[31m-    ).map_err(|e| anyhow!("Invalid transport URL: {e}"))?;
[m[32m+    let transport = Url::parse(&format!(
[m[32m+        "https://{}/endpoint/{}",
[m[32m+        server,
[m[32m+        &did.replace("%", "%25")
[m[32m+    ))
[m[32m+    .map_err(|e| anyhow!("Invalid transport URL: {e}"))?;
[m
     let private_vid = OwnedVid::bind(&did, transport);
     log!("created identity {}", private_vid.identifier());
Diff in /app/src/tsp/mod.rs:921:
         .map_err(|e| anyhow!("Could not publish VID. The DID server responded with error: {e}"))?;

     let vid_result: Result<Vid, anyhow::Error> = match response.status() {
[31m-        r if r.is_success() => {
[m[31m-            response.json().await
[m[31m-                .map_err(|e| anyhow!("Could not decode response from DID server as a valid VID: {e}"))
[m[31m-        }
[m[32m+        r if r.is_success() => response
[m[32m+            .json()
[m[32m+            .await
[m[32m+            .map_err(|e| anyhow!("Could not decode response from DID server as a valid VID: {e}")),
[m         r => {
[31m-            let text = response.text().await.unwrap_or_else(|_| "[Unknown]".to_string());
[m[32m+            let text = response
[m[32m+                .text()
[m[32m+                .await
[m[32m+                .unwrap_or_else(|_| "[Unknown]".to_string());
[m             if r.as_u16() == 500 {
                 return Err(anyhow!(
                     "The DID server returned error code 500. The DID username may already exist, \
Diff in /app/src/tsp/mod.rs:943:

     let _vid = vid_result?;

[31m-    log!("published DID document at {}",
[m[32m+    log!(
[m[32m+        "published DID document at {}",
[m         tsp_sdk::vid::did::get_resolve_url(&did)?.to_string()
     );

Diff in /app/src/tsp/mod.rs:954:
     Ok((did, private_vid, metadata))
 }

[31m-
[m /// Stores the given private VID in the current default TSP wallet,
 /// and optionally establishes an alias for the given `did`.
 ///
Diff in /app/src/tsp/mod.rs:974:
     Ok(did)
 }

[31m-
[m /// Re-publishes/re-uploads our own DID to the DID server it was originally created on.
[31m-async fn republish_did(
[m[31m-    did: &str,
[m[31m-    client: &reqwest::Client,
[m[31m-) -> Result<(), anyhow::Error> {
[m[31m-
[m[32m+async fn republish_did(did: &str, client: &reqwest::Client) -> Result<(), anyhow::Error> {
[m     /// A copy of the Vid struct that we can actually instantiate
     /// from an existing VID in a local wallet.
     ///
Diff in /app/src/tsp/mod.rs:999:
         public_enckey: PublicKeyData,
     }

[31m-
[m     let our_vid = {
         let tsp_state = tsp_state_ref().lock().unwrap();
[31m-        tsp_state.current_wallet.as_ref()
[m[32m+        tsp_state
[m[32m+            .current_wallet
[m[32m+            .as_ref()
[m             .ok_or_else(no_default_wallet_error)?
             .db
             .as_store()
Diff in /app/src/tsp/mod.rs:1009:
             .get_verified_vid(did)
[31m-            .map_err(|_e| anyhow!("The DID to republish \"{did}\" was not found in the current default wallet."))?
[m[32m+            .map_err(|_e| {
[m[32m+                anyhow!(
[m[32m+                    "The DID to republish \"{did}\" was not found in the current default wallet."
[m[32m+                )
[m[32m+            })?
[m     };

     let vid_dup = VidDuplicate {
Diff in /app/src/tsp/mod.rs:1022:
     let did_transport_url = tsp_sdk::vid::did::get_resolve_url(did)?;

     let response = client
[31m-        .post(format!("{}/add-vid", did_transport_url.origin().ascii_serialization()))
[m[32m+        .post(format!(
[m[32m+            "{}/add-vid",
[m[32m+            did_transport_url.origin().ascii_serialization()
[m[32m+        ))
[m         .json(&vid_dup)
         .send()
         .await
Diff in /app/src/tsp/mod.rs:1029:
[31m-        .map_err(|e| anyhow!("Could not republish VID. The DID server responded with error: {e}"))?;
[m[32m+        .map_err(|e| {
[m[32m+            anyhow!("Could not republish VID. The DID server responded with error: {e}")
[m[32m+        })?;
[m
     match response.status() {
         r if r.is_success() => {
Diff in /app/src/tsp/mod.rs:1034:
             Ok(())
         }
         r => {
[31m-            let text = response.text().await.unwrap_or_else(|_| "[Unknown]".to_string());
[m[32m+            let text = response
[m[32m+                .text()
[m[32m+                .await
[m[32m+                .unwrap_or_else(|_| "[Unknown]".to_string());
[m             if r.as_u16() == 500 {
                 Err(anyhow!(
                     "The DID server returned error code 500. The DID username may already exist, \
Diff in /app/src/tsp/mod.rs:1050:
     }
 }

[31m-
[m async fn receive_messages_for_vid(
     wallet_db: AsyncSecureStore,
     private_vid_to_receive_on: String,
Diff in /app/src/tsp/mod.rs:1057:
     mut request_rx: UnboundedReceiver<TspReceiveLoopRequest>,
 ) -> Result<(), anyhow::Error> {
     // Ensure that our receiving VID is currently published to the DID server.
[31m-    if republish_did(&private_vid_to_receive_on, &create_reqwest_client()?).await.is_ok() {
[m[32m+    if republish_did(&private_vid_to_receive_on, &create_reqwest_client()?)
[m[32m+        .await
[m[32m+        .is_ok()
[m[32m+    {
[m         log!("Auto-republished DID \"{private_vid_to_receive_on}\" to its DID server.");
     }

Diff in /app/src/tsp/mod.rs:1135:
     Ok(())
 }

[31m-
[m fn no_default_wallet_error() -> anyhow::Error {
     anyhow!("Please choose a default TSP wallet.")
 }
Diff in /app/src/tsp/mod.rs:1142:

 fn no_default_vid_error() -> anyhow::Error {
[31m-    anyhow!("Please choose a default VID from your default \
[m[31m-        TSP wallet to represent your own Matrix account.")
[m[32m+    anyhow!(
[m[32m+        "Please choose a default VID from your default \
[m[32m+        TSP wallet to represent your own Matrix account."
[m[32m+    )
[m }

[31m-
[m /// Associates the given DID with a Matrix User ID.
 ///
 /// This function only performs the local verification of the given DID into
Diff in /app/src/tsp/mod.rs:1152:
 /// the local default wallet, and then sends a verification request to the user.
 /// It does not wait to receive a verification response.
[31m-async fn associate_did_with_user_id(
[m[31m-    did: &str,
[m[31m-    user_id: &OwnedUserId,
[m[31m-) -> Result<(), anyhow::Error> {
[m[31m-    let our_user_id = crate::sliding_sync::current_user_id()
[m[31m-        .ok_or_else(|| anyhow!("Must be logged into Matrix in order to associate a DID with a Matrix User ID."))?;
[m[32m+async fn associate_did_with_user_id(did: &str, user_id: &OwnedUserId) -> Result<(), anyhow::Error> {
[m[32m+    let our_user_id = crate::sliding_sync::current_user_id().ok_or_else(|| {
[m[32m+        anyhow!("Must be logged into Matrix in order to associate a DID with a Matrix User ID.")
[m[32m+    })?;
[m     let (wallet_db, our_vid) = {
         let tsp_state = tsp_state_ref().lock().unwrap();
[31m-        let wallet = tsp_state.current_wallet.as_ref().ok_or_else(no_default_wallet_error)?;
[m[31m-        let our_vid = tsp_state.current_local_vid.clone().ok_or_else(no_default_vid_error)?;
[m[32m+        let wallet = tsp_state
[m[32m+            .current_wallet
[m[32m+            .as_ref()
[m[32m+            .ok_or_else(no_default_wallet_error)?;
[m[32m+        let our_vid = tsp_state
[m[32m+            .current_local_vid
[m[32m+            .clone()
[m[32m+            .ok_or_else(no_default_vid_error)?;
[m         (wallet.db.clone(), our_vid)
     };
     if !wallet_db.has_verified_vid(did)? {
Diff in /app/src/tsp/mod.rs:1182:
                 .collect()
         },
     };
[31m-    tsp_state_ref().lock().unwrap().pending_verification_requests.push(verification_details.clone());
[m[32m+    tsp_state_ref()
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .pending_verification_requests
[m[32m+        .push(verification_details.clone());
[m     let request_msg = TspMessage::VerificationRequest(verification_details);
[31m-    wallet_db.send(
[m[31m-        &our_vid,
[m[31m-        did,
[m[31m-        // This is just for debugging and should be removed before production.
[m[31m-        Some(format!("Verification from {our_user_id} to {user_id}").as_bytes()),
[m[31m-        serde_json::to_string(&request_msg)?.as_bytes(),
[m[31m-    ).await?;
[m[32m+    wallet_db
[m[32m+        .send(
[m[32m+            &our_vid,
[m[32m+            did,
[m[32m+            // This is just for debugging and should be removed before production.
[m[32m+            Some(format!("Verification from {our_user_id} to {user_id}").as_bytes()),
[m[32m+            serde_json::to_string(&request_msg)?.as_bytes(),
[m[32m+        )
[m[32m+        .await?;
[m
     // Note: the receive loop will wait to receive the verification response,
     //       upon which the verification procedure will be completed
Diff in /app/src/tsp/mod.rs:1198:
     Ok(())
 }

[31m-
[m /// Sends a positive/negative response to a previous incoming DID association request.
 async fn respond_to_did_association_request(
     details: &TspVerificationDetails,
Diff in /app/src/tsp/mod.rs:1205:
     wallet_db: &AsyncSecureStore,
     accepted: bool,
 ) -> Result<(), anyhow::Error> {
[31m-    wallet_db.verify_vid(&details.initiating_vid, Some(details.initiating_user_id.to_string())).await?;
[m[31m-    log!("Verification requester's initiating DID {} was verified and added to your wallet.", details.initiating_vid);
[m[32m+    wallet_db
[m[32m+        .verify_vid(
[m[32m+            &details.initiating_vid,
[m[32m+            Some(details.initiating_user_id.to_string()),
[m[32m+        )
[m[32m+        .await?;
[m[32m+    log!(
[m[32m+        "Verification requester's initiating DID {} was verified and added to your wallet.",
[m[32m+        details.initiating_vid
[m[32m+    );
[m
     let response_msg = TspMessage::VerificationResponse {
         details: details.clone(),
Diff in /app/src/tsp/mod.rs:1213:
         accepted,
     };
[31m-    wallet_db.send(
[m[31m-        &details.responding_vid,
[m[31m-        &details.initiating_vid,
[m[31m-        // This is just for debugging and should be removed before production.
[m[31m-        Some(format!("Verification Response ({accepted}) from {} to {}", details.responding_user_id, details.initiating_user_id).as_bytes()),
[m[31m-        serde_json::to_string(&response_msg)?.as_bytes(),
[m[31m-    ).await?;
[m[32m+    wallet_db
[m[32m+        .send(
[m[32m+            &details.responding_vid,
[m[32m+            &details.initiating_vid,
[m[32m+            // This is just for debugging and should be removed before production.
[m[32m+            Some(
[m[32m+                format!(
[m[32m+                    "Verification Response ({accepted}) from {} to {}",
[m[32m+                    details.responding_user_id, details.initiating_user_id
[m[32m+                )
[m[32m+                .as_bytes(),
[m[32m+            ),
[m[32m+            serde_json::to_string(&response_msg)?.as_bytes(),
[m[32m+        )
[m[32m+        .await?;
[m
     Ok(())
 }
Diff in /app/src/tsp/mod.rs:1228:
     let (wallet_db, signing_vid) = {
         let tsp_state = tsp_state_ref().lock().unwrap();
         (
[31m-            tsp_state.current_wallet.as_ref().ok_or_else(no_default_wallet_error)?.db.clone(),
[m[31m-            tsp_state.current_local_vid.clone().ok_or_else(no_default_vid_error)?,
[m[32m+            tsp_state
[m[32m+                .current_wallet
[m[32m+                .as_ref()
[m[32m+                .ok_or_else(no_default_wallet_error)?
[m[32m+                .db
[m[32m+                .clone(),
[m[32m+            tsp_state
[m[32m+                .current_local_vid
[m[32m+                .clone()
[m[32m+                .ok_or_else(no_default_vid_error)?,
[m         )
     };
     let signed = wallet_db.as_store().sign_anycast(&signing_vid, message)?;
Diff in /app/src/tsp/mod.rs:1236:
     Ok(signed)
 }

[31m-
[m /// The types/schema of messages that we send over the TSP protocol.
 #[derive(Debug, Serialize, Deserialize)]
 enum TspMessage {
Diff in /app/src/tsp/mod.rs:1269:

 /// Sanitizes a wallet name to ensure it is safe to use in file paths.
 pub fn sanitize_wallet_name(name: &str) -> String {
[31m-    sanitize_filename::sanitize(name)
[m[31m-        .replace(char::is_whitespace, "_")
[m[32m+    sanitize_filename::sanitize(name).replace(char::is_whitespace, "_")
[m }

[31m-
[m /// Represents a SQLite URL for a TSP wallet, which is *NOT* percent-encoded yet.
 ///
 /// Currently the scheme is always "sqlite://" (or "sqlite:///" for absolute paths),
Diff in /app/src/tsp/mod.rs:1308:
     pub fn get_path(&self) -> Option<&Path> {
         let url = &self.0;
         // Handle URLs with a scheme for absolute paths, e.g., "sqlite:///"
[31m-        if let Some(p) = url.find(":///").and_then(|pos| url.get(pos + 4 ..)) {
[m[32m+        if let Some(p) = url.find(":///").and_then(|pos| url.get(pos + 4..)) {
[m             Some(Path::new(p))
         }
         // Handle URLs with a scheme for relative paths, e.g., "sqlite://"
Diff in /app/src/tsp/mod.rs:1315:
[31m-        else if let Some(p) = url.find("://").and_then(|pos| url.get(pos + 3 ..)) {
[m[32m+        else if let Some(p) = url.find("://").and_then(|pos| url.get(pos + 3..)) {
[m             Some(Path::new(p))
[32m+        } else {
[m[32m+            None
[m         }
[31m-        else { None }
[m     }

     /// Returns the URL as a string that is not percent-encoded.
Diff in /app/src/tsp/mod.rs:1327:
         &self.0
     }

[31m-
[m     /// Converts this wallet URL to a percent-encoded URL.
     ///
     /// ## Usage notes
Diff in /app/src/tsp/mod.rs:1338:
     /// We cannot use the `Path`/`PathBuf` type because the sqlite backend
     /// always expects URLs with filename paths encoded using Unix-style `/` path separators,
     /// even on Windows. Therefore, we manually percent-encode each part of the path
[31m-    /// and push them in between manually-added `/` separators, instead of using
[m[32m+    /// and push them in between manually-added `/` separators, instead of using
[m     /// the Rust `std::path` functions like `Path::join()` or `PathBuf::push()`.
     pub fn to_url_encoded(&self) -> Cow<'_, str> {
         const DELIMITER_ABS: &str = ":///";
Diff in /app/src/tsp/mod.rs:1351:

         let try_encode = |delim: &str| -> Option<String> {
             if let Some(idx) = self.0.find(delim) {
[31m-                let before = self.0.get(.. (idx + delim.len())).unwrap_or("");
[m[31m-                let after  = self.0.get((idx + delim.len()) ..).unwrap_or("");
[m[32m+                let before = self.0.get(..(idx + delim.len())).unwrap_or("");
[m[32m+                let after = self.0.get((idx + delim.len())..).unwrap_or("");
[m                 let mut after_encoded = String::new();
                 for component in Path::new(after).components() {
                     match component {
Diff in /app/src/tsp/mod.rs:1359:
                         std::path::Component::Prefix(prefix) => {
                             // Windows drive prefixes must not be percent-encoded.
[31m-                            after_encoded = format!("{}{}{}", after_encoded, SEPARATOR, prefix.as_os_str().to_string_lossy());
[m[32m+                            after_encoded = format!(
[m[32m+                                "{}{}{}",
[m[32m+                                after_encoded,
[m[32m+                                SEPARATOR,
[m[32m+                                prefix.as_os_str().to_string_lossy()
[m[32m+                            );
[m                         }
                         std::path::Component::RootDir => {
                             // ignore, since we already manually add '/' between components.
Diff in /app/src/tsp/mod.rs:1366:
                         std::path::Component::Normal(p) => {
                             let percent_encoded = percent_encoding::percent_encode(
                                 p.as_encoded_bytes(),
[31m-                                percent_encoding::NON_ALPHANUMERIC
[m[32m+                                percent_encoding::NON_ALPHANUMERIC,
[m                             );
[31m-                            after_encoded = format!("{}{}{}", after_encoded, SEPARATOR_PE, percent_encoded);
[m[32m+                            after_encoded =
[m[32m+                                format!("{}{}{}", after_encoded, SEPARATOR_PE, percent_encoded);
[m                         }
                         other => {
[31m-                            after_encoded = format!("{}{}{}", after_encoded, SEPARATOR_PE, other.as_os_str().to_string_lossy());
[m[32m+                            after_encoded = format!(
[m[32m+                                "{}{}{}",
[m[32m+                                after_encoded,
[m[32m+                                SEPARATOR_PE,
[m[32m+                                other.as_os_str().to_string_lossy()
[m[32m+                            );
[m                         }
                     }
                 }
Diff in /app/src/tsp/mod.rs:1385:
             .or_else(|| try_encode(DELIMITER_REG))
             .map(Cow::from)
             .unwrap_or_else(|| {
[31m-                percent_encoding::utf8_percent_encode(
[m[31m-                    &self.0,
[m[31m-                    percent_encoding::NON_ALPHANUMERIC,
[m[31m-                ).into()
[m[32m+                percent_encoding::utf8_percent_encode(&self.0, percent_encoding::NON_ALPHANUMERIC)
[m[32m+                    .into()
[m             })
     }
 }
Diff in /app/src/tsp/tsp_settings_screen.rs:1:
[31m-
[m use makepad_widgets::*;

[31m-use crate::{shared::{popup_list::{enqueue_popup_notification, PopupKind}, styles::*}, tsp::{create_did_modal::CreateDidModalAction, create_wallet_modal::CreateWalletModalAction, submit_tsp_request, tsp_state_ref, TspIdentityAction, TspRequest, TspWalletAction, TspWalletEntry, TspWalletMetadata}};
[m[32m+use crate::{
[m[32m+    shared::{
[m[32m+        popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+        styles::*,
[m[32m+    },
[m[32m+    tsp::{
[m[32m+        create_did_modal::CreateDidModalAction, create_wallet_modal::CreateWalletModalAction,
[m[32m+        submit_tsp_request, tsp_state_ref, TspIdentityAction, TspRequest, TspWalletAction,
[m[32m+        TspWalletEntry, TspWalletMetadata,
[m[32m+    },
[m[32m+};
[m
 const REPUBLISH_IDENTITY_BUTTON_TEXT: &str = "Republish Current Identity to DID Server";

Diff in /app/src/tsp/tsp_settings_screen.rs:216:
     fn get(&self, index: usize) -> Option<(&TspWalletMetadata, WalletStatusAndDefault)> {
         if let Some(active) = self.active_wallet.as_ref() {
             if index == 0 {
[31m-                Some((active, WalletStatusAndDefault::new(WalletStatus::Opened, true)))
[m[32m+                Some((
[m[32m+                    active,
[m[32m+                    WalletStatusAndDefault::new(WalletStatus::Opened, true),
[m[32m+                ))
[m             } else {
[31m-                self.other_wallets.get(index - 1).map(|(m, s)|
[m[31m-                    (m, WalletStatusAndDefault::new(*s, false))
[m[31m-                )
[m[32m+                self.other_wallets
[m[32m+                    .get(index - 1)
[m[32m+                    .map(|(m, s)| (m, WalletStatusAndDefault::new(*s, false)))
[m             }
         } else {
[31m-            self.other_wallets.get(index).map(|(m, s)|
[m[31m-                (m, WalletStatusAndDefault::new(*s, false))
[m[31m-            )
[m[32m+            self.other_wallets
[m[32m+                .get(index)
[m[32m+                .map(|(m, s)| (m, WalletStatusAndDefault::new(*s, false)))
[m         }
     }
 }
Diff in /app/src/tsp/tsp_settings_screen.rs:250:
 /// The view containing all TSP-related settings.
 #[derive(Live, LiveHook, Widget)]
 pub struct TspSettingsScreen {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
     /// The list of wallets that are known by this widget.
     ///
Diff in /app/src/tsp/tsp_settings_screen.rs:262:
     /// This is sort of a "cache" of the wallets that have been drawn
     /// to avoid having to re-fetch them from the shared TSP state every time,
     /// as that requires locking the mutex and can be expensive.
[31m-    #[rust] wallets: Option<WalletState>,
[m[32m+    #[rust]
[m[32m+    wallets: Option<WalletState>,
[m }

 impl Widget for TspSettingsScreen {
Diff in /app/src/tsp/tsp_settings_screen.rs:279:
         }

         // Draw the current identity label and republish button based on the active identity.
[31m-        let (current_did_text, current_did_text_color, show_republish_button) = match
[m[31m-            self.wallets.as_ref().and_then(|ws| ws.active_identity.as_deref())
[m[32m+        let (current_did_text, current_did_text_color, show_republish_button) = match self
[m[32m+            .wallets
[m[32m+            .as_ref()
[m[32m+            .and_then(|ws| ws.active_identity.as_deref())
[m         {
             Some(current_did) => (current_did, COLOR_FG_ACCEPT_GREEN, true),
[31m-            None => ("No default identity has been set.", COLOR_WARNING_NOT_FOUND, false),
[m[32m+            None => (
[m[32m+                "No default identity has been set.",
[m[32m+                COLOR_WARNING_NOT_FOUND,
[m[32m+                false,
[m[32m+            ),
[m         };
[31m-        self.view.label(ids!(current_identity_label)).apply_over(cx, live!(
[m[31m-            text: (current_did_text),
[m[31m-            draw_text: { color: (current_did_text_color) },
[m[31m-        ));
[m[31m-        self.view.button(ids!(republish_identity_button)).set_visible(cx, show_republish_button);
[m[32m+        self.view.label(ids!(current_identity_label)).apply_over(
[m[32m+            cx,
[m[32m+            live!(
[m[32m+                text: (current_did_text),
[m[32m+                draw_text: { color: (current_did_text_color) },
[m[32m+            ),
[m[32m+        );
[m[32m+        self.view
[m[32m+            .button(ids!(republish_identity_button))
[m[32m+            .set_visible(cx, show_republish_button);
[m
[31m-
[m         // If we don't have any wallets, show the "no wallets" label.
         let is_wallets_empty = self.wallets.as_ref().is_none_or(|w| w.is_empty());
[31m-        self.view.view(ids!(no_wallets_label)).set_visible(cx, is_wallets_empty);
[m[32m+        self.view
[m[32m+            .view(ids!(no_wallets_label))
[m[32m+            .set_visible(cx, is_wallets_empty);
[m
         while let Some(subview) = self.view.draw_walk(cx, scope, walk).step() {
             // Here, we only need to handle drawing the wallet list.
Diff in /app/src/tsp/tsp_settings_screen.rs:301:
             let flat_list_ref = subview.as_flat_list();
             let Some(mut list) = flat_list_ref.borrow_mut() else {
[31m-                error!("!!! TspSettingsScreen::draw_walk(): BUG: expected a FlatList widget, but got something else");
[m[32m+                error!(
[m[32m+                    "!!! TspSettingsScreen::draw_walk(): BUG: expected a FlatList widget, but got something else"
[m[32m+                );
[m                 continue;
             };
             let Some(wallets) = self.wallets.as_ref() else {
Diff in /app/src/tsp/tsp_settings_screen.rs:307:
                 return DrawStep::done();
             };

[31m-            for (metadata, mut status_and_default) in (0..wallets.len()).filter_map(|i| wallets.get(i)) {
[m[32m+            for (metadata, mut status_and_default) in
[m[32m+                (0..wallets.len()).filter_map(|i| wallets.get(i))
[m[32m+            {
[m                 let item_live_id = LiveId::from_str(metadata.url.as_url_unencoded());
                 let item = list.item(cx, item_live_id, id!(wallet_entry)).unwrap();
                 // Pass the wallet metadata in through Scope via props,
Diff in /app/src/tsp/tsp_settings_screen.rs:327:
         for action in actions {
             match action.downcast_ref() {
                 // Add the new wallet to the list of drawn wallets.
[31m-                Some(TspWalletAction::CreateWalletSuccess { metadata, is_default }) => {
[m[32m+                Some(TspWalletAction::CreateWalletSuccess {
[m[32m+                    metadata,
[m[32m+                    is_default,
[m[32m+                }) => {
[m                     let wallets = self.wallets.get_or_insert_default();
                     if *is_default {
                         wallets.active_wallet = Some(metadata.clone());
Diff in /app/src/tsp/tsp_settings_screen.rs:334:
                     } else {
[31m-                        wallets.other_wallets.push((metadata.clone(), WalletStatus::Opened));
[m[32m+                        wallets
[m[32m+                            .other_wallets
[m[32m+                            .push((metadata.clone(), WalletStatus::Opened));
[m                     }
                     self.view.redraw(cx);
                     continue;
Diff in /app/src/tsp/tsp_settings_screen.rs:339:
                 }

                 // Remove the wallet from the list of drawn wallets.
[31m-                Some(TspWalletAction::WalletRemoved { metadata, was_default }) => {
[m[31m-                    let Some(wallets) = &mut self.wallets.as_mut() else { continue };
[m[32m+                Some(TspWalletAction::WalletRemoved {
[m[32m+                    metadata,
[m[32m+                    was_default,
[m[32m+                }) => {
[m[32m+                    let Some(wallets) = &mut self.wallets.as_mut() else {
[m[32m+                        continue;
[m[32m+                    };
[m                     if *was_default {
                         wallets.active_wallet = None;
[31m-                    }
[m[31m-                    else if let Some(pos) = wallets.other_wallets.iter().position(|(w, _)| w == metadata) {
[m[32m+                    } else if let Some(pos) = wallets
[m[32m+                        .other_wallets
[m[32m+                        .iter()
[m[32m+                        .position(|(w, _)| w == metadata)
[m[32m+                    {
[m                         wallets.other_wallets.remove(pos);
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         continue;
                     }
                     enqueue_popup_notification(
Diff in /app/src/tsp/tsp_settings_screen.rs:375:
                     let previous_active = wallets.active_wallet.replace(metadata.clone());
                     // If the newly-default wallet was in the other wallets list, remove it
                     // and then add the previous active wallet back to that other wallets list.
[31m-                    if let Some(idx_to_remove) = wallets.other_wallets.iter().position(|(w, _)| w == metadata) {
[m[32m+                    if let Some(idx_to_remove) = wallets
[m[32m+                        .other_wallets
[m[32m+                        .iter()
[m[32m+                        .position(|(w, _)| w == metadata)
[m[32m+                    {
[m                         wallets.other_wallets.remove(idx_to_remove);
                     }
                     if let Some(previous_active) = previous_active {
Diff in /app/src/tsp/tsp_settings_screen.rs:382:
[31m-                        wallets.other_wallets.insert(0, (previous_active, WalletStatus::Opened));
[m[32m+                        wallets
[m[32m+                            .other_wallets
[m[32m+                            .insert(0, (previous_active, WalletStatus::Opened));
[m                     }
                     self.view.redraw(cx);
                     continue;
Diff in /app/src/tsp/tsp_settings_screen.rs:396:
                 // Handle a newly-opened wallet.
                 Some(TspWalletAction::WalletOpened(Ok(metadata))) => {
                     let wallets = self.wallets.get_or_insert_default();
[31m-                    if let Some((_m, status)) = wallets.other_wallets.iter_mut().find(|(w, _)| w == metadata) {
[m[32m+                    if let Some((_m, status)) = wallets
[m[32m+                        .other_wallets
[m[32m+                        .iter_mut()
[m[32m+                        .find(|(w, _)| w == metadata)
[m[32m+                    {
[m                         *status = WalletStatus::Opened;
                     } else {
[31m-                        wallets.other_wallets.push((metadata.clone(), WalletStatus::Opened));
[m[32m+                        wallets
[m[32m+                            .other_wallets
[m[32m+                            .push((metadata.clone(), WalletStatus::Opened));
[m                     }
                     self.view.redraw(cx);
                     continue;
Diff in /app/src/tsp/tsp_settings_screen.rs:414:
                 }

                 // This is handled in the CreateWalletModal
[31m-                Some(TspWalletAction::CreateWalletError { .. }) => { continue; }
[m[31m-                None => { }
[m[32m+                Some(TspWalletAction::CreateWalletError { .. }) => {
[m[32m+                    continue;
[m[32m+                }
[m[32m+                None => {}
[m             }

             match action.downcast_ref() {
Diff in /app/src/tsp/tsp_settings_screen.rs:430:
                 }
                 Some(TspIdentityAction::DidRepublishResult(result)) => {
                     // restore the republish button to its original state.
[31m-                    republish_identity_button.apply_over(cx, live!(
[m[31m-                        enabled: true,
[m[31m-                        text: (REPUBLISH_IDENTITY_BUTTON_TEXT),
[m[31m-                    ));
[m[32m+                    republish_identity_button.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            enabled: true,
[m[32m+                            text: (REPUBLISH_IDENTITY_BUTTON_TEXT),
[m[32m+                        ),
[m[32m+                    );
[m                     match result {
                         Ok(did) => {
                             enqueue_popup_notification(
Diff in /app/src/tsp/tsp_settings_screen.rs:440:
[31m-                                format!("Successfully republished identity \"{}\" to the DID server.", did),
[m[32m+                                format!(
[m[32m+                                    "Successfully republished identity \"{}\" to the DID server.",
[m[32m+                                    did
[m[32m+                                ),
[m                                 PopupKind::Success,
                                 Some(5.0),
                             );
Diff in /app/src/tsp/tsp_settings_screen.rs:452:
                     }
                     continue;
                 }
[31m-                Some(TspIdentityAction::SentDidAssociationRequest { .. }) => { continue; } // handled in the TspVerifyUser widget
[m[31m-                Some(TspIdentityAction::ErrorSendingDidAssociationRequest { .. }) => { continue; } // handled in the TspVerifyUser widget
[m[31m-                Some(TspIdentityAction::ReceivedDidAssociationResponse { .. }) => { continue; } // handled in the TspVerifyUser widget
[m[31m-                Some(TspIdentityAction::ReceivedDidAssociationRequest { .. }) => { continue; } // handled in the TspVerificationModal widget
[m[31m-                Some(TspIdentityAction::ReceiveLoopError { .. }) => { continue; } // handled in the top-level app
[m[31m-                None => { }
[m[32m+                Some(TspIdentityAction::SentDidAssociationRequest { .. }) => {
[m[32m+                    continue;
[m[32m+                } // handled in the TspVerifyUser widget
[m[32m+                Some(TspIdentityAction::ErrorSendingDidAssociationRequest { .. }) => {
[m[32m+                    continue;
[m[32m+                } // handled in the TspVerifyUser widget
[m[32m+                Some(TspIdentityAction::ReceivedDidAssociationResponse { .. }) => {
[m[32m+                    continue;
[m[32m+                } // handled in the TspVerifyUser widget
[m[32m+                Some(TspIdentityAction::ReceivedDidAssociationRequest { .. }) => {
[m[32m+                    continue;
[m[32m+                } // handled in the TspVerificationModal widget
[m[32m+                Some(TspIdentityAction::ReceiveLoopError { .. }) => {
[m[32m+                    continue;
[m[32m+                } // handled in the top-level app
[m[32m+                None => {}
[m             }
         }

Diff in /app/src/tsp/tsp_settings_screen.rs:464:
[31m-
[m[31m-        if self.view.button(ids!(copy_identity_button)).clicked(actions) {
[m[31m-            if let Some(did) = self.wallets.as_ref().and_then(|ws| ws.active_identity.as_deref()) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(copy_identity_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m[32m+            if let Some(did) = self
[m[32m+                .wallets
[m[32m+                .as_ref()
[m[32m+                .and_then(|ws| ws.active_identity.as_deref())
[m[32m+            {
[m                 cx.copy_to_clipboard(did);
                 enqueue_popup_notification(
                     "Copied your default TSP identity to the clipboard.",
Diff in /app/src/tsp/tsp_settings_screen.rs:482:
         // Allow the user to republish their identity to the DID server.
         // This is primarily needed because some DID servers (e.g., the test servers)
         // frequently wipe their identity storage after a certain period of time.
[31m-        if self.view.button(ids!(republish_identity_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(republish_identity_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             if self.has_default_wallet() {
[31m-                if let Some(our_did) = self.wallets.as_ref().and_then(|ws| ws.active_identity.as_deref()) {
[m[31m-                    republish_identity_button.apply_over(cx, live!(
[m[31m-                        enabled: false,
[m[31m-                        text: "Republishing DID now...",
[m[31m-                    ));
[m[32m+                if let Some(our_did) = self
[m[32m+                    .wallets
[m[32m+                    .as_ref()
[m[32m+                    .and_then(|ws| ws.active_identity.as_deref())
[m[32m+                {
[m[32m+                    republish_identity_button.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            enabled: false,
[m[32m+                            text: "Republishing DID now...",
[m[32m+                        ),
[m[32m+                    );
[m
[31m-                    submit_tsp_request(TspRequest::RepublishDid { did: our_did.to_string() });
[m[32m+                    submit_tsp_request(TspRequest::RepublishDid {
[m[32m+                        did: our_did.to_string(),
[m[32m+                    });
[m                 } else {
                     enqueue_popup_notification(
                         "You must set a default TSP identity to be republished.",
Diff in /app/src/tsp/tsp_settings_screen.rs:501:
             }
         }

[31m-        if self.view.button(ids!(create_wallet_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(create_wallet_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             cx.action(CreateWalletModalAction::Open);
         }

Diff in /app/src/tsp/tsp_settings_screen.rs:511:
             }
         }

[31m-        if self.view.button(ids!(import_wallet_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(import_wallet_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             // TODO: support importing an existing wallet.
             enqueue_popup_notification(
                 "Importing an existing wallet is not yet implemented.",
Diff in /app/src/tsp/tsp_settings_screen.rs:526:
     /// Re-fetches the TSP state and populates this widget's list of wallets.
     fn refresh_wallets(&mut self) {
         let tsp_state = tsp_state_ref().lock().unwrap();
[31m-        let current_wallet = tsp_state.current_wallet.as_ref().map(|w| w.metadata.clone());
[m[31m-        let other_wallets = tsp_state.other_wallets
[m[32m+        let current_wallet = tsp_state
[m[32m+            .current_wallet
[m[32m+            .as_ref()
[m[32m+            .map(|w| w.metadata.clone());
[m[32m+        let other_wallets = tsp_state
[m[32m+            .other_wallets
[m             .iter()
             .map(|entry| match entry {
                 TspWalletEntry::Opened(opened) => (opened.metadata.clone(), WalletStatus::Opened),
Diff in /app/src/tsp/tsp_sign_indicator.rs:2:

 use makepad_widgets::*;

[31m-use crate::shared::{callout_tooltip::{CalloutTooltipOptions, TooltipAction}, styles::*};
[m[32m+use crate::shared::{
[m[32m+    callout_tooltip::{CalloutTooltipOptions, TooltipAction},
[m[32m+    styles::*,
[m[32m+};
[m
 live_design! {
     link tsp_enabled
Diff in /app/src/tsp/tsp_sign_indicator.rs:49:
     WrongSignature,
 }

[31m-
[m /// An indicator that is shown nearby a message that has a TSP signature.
 ///
 /// This widget is basically just a clickable icon group that shows
Diff in /app/src/tsp/tsp_sign_indicator.rs:63:
 ///
 #[derive(Live, LiveHook, Widget)]
 pub struct TspSignIndicator {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: TspSignState,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: TspSignState,
[m }

 impl Widget for TspSignIndicator {
Diff in /app/src/tsp/tsp_sign_indicator.rs:73:

         let area = self.view.area();
         let should_hover_in = match event.hits(cx, area) {
[31m-            Hit::FingerLongPress(_)
[m[31m-            | Hit::FingerHoverIn(..) => true,
[m[32m+            Hit::FingerLongPress(_) | Hit::FingerHoverIn(..) => true,
[m             // TODO: show user profile and TSP info on click
             // Hit::FingerUp(fue) if fue.is_over && fue.is_primary_hit() => {
             //     log!("todo: show user profile and TSP info.");
Diff in /app/src/tsp/tsp_sign_indicator.rs:94:
                 ),
                 TspSignState::Verified => (
                     "This message was signed with the user's verified TSP identity.",
[31m-                    COLOR_FG_ACCEPT_GREEN,
[m[32m+                    COLOR_FG_ACCEPT_GREEN,
[m                 ),
                 TspSignState::WrongSignature => (
                     "Warning: this message's TSP signature does NOT match the expected sender signature.",
Diff in /app/src/tsp/tsp_sign_indicator.rs:127:
         let tsp_html_ref = self.view.html(ids!(tsp_html));
         if let Some(mut tsp_html) = tsp_html_ref.borrow_mut() {
             let (text, font_color) = match state {
[31m-                TspSignState::Unknown => {
[m[31m-                    ("TSP ❔", COLOR_MESSAGE_NOTICE_TEXT)
[m[31m-                }
[m[31m-                TspSignState::Verified => {
[m[31m-                    ("TSP ✅", COLOR_FG_ACCEPT_GREEN)
[m[31m-                }
[m[31m-                TspSignState::WrongSignature => {
[m[31m-                    ("❗TSP❗", COLOR_FG_DANGER_RED)
[m[31m-                }
[m[32m+                TspSignState::Unknown => ("TSP ❔", COLOR_MESSAGE_NOTICE_TEXT),
[m[32m+                TspSignState::Verified => ("TSP ✅", COLOR_FG_ACCEPT_GREEN),
[m[32m+                TspSignState::WrongSignature => ("❗TSP❗", COLOR_FG_DANGER_RED),
[m             };
             tsp_html.set_text(cx, text);
             tsp_html.font_color = font_color;
Diff in /app/src/tsp/tsp_sign_indicator.rs:154:
         }
     }
 }
[31m-
[m
 /// Actions emitted by an `TspSignIndicator` widget.
 #[derive(Clone, Debug, DefaultNone)]
Diff in /app/src/tsp/tsp_verification_modal.rs:1:
[31m-
[m use makepad_widgets::*;
 use tsp_sdk::AsyncSecureStore;

Diff in /app/src/tsp/tsp_verification_modal.rs:5:
[31m-use crate::{shared::styles::*, sliding_sync::current_user_id, tsp::{submit_tsp_request, TspRequest, TspVerificationDetails}};
[m[32m+use crate::{
[m[32m+    shared::styles::*,
[m[32m+    sliding_sync::current_user_id,
[m[32m+    tsp::{submit_tsp_request, TspRequest, TspVerificationDetails},
[m[32m+};
[m
 live_design! {
     link tsp_enabled
Diff in /app/src/tsp/tsp_verification_modal.rs:77:
                             color: (COLOR_FG_DANGER_RED),
                         }
                         icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                         draw_bg: {
                             border_color: (COLOR_FG_DANGER_RED),
                             color: (COLOR_BG_DANGER_RED)
Diff in /app/src/tsp/tsp_verification_modal.rs:96:
                             color: (COLOR_FG_ACCEPT_GREEN),
                         }
                         icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                         draw_bg: {
                             border_color: (COLOR_FG_ACCEPT_GREEN),
                             color: (COLOR_BG_ACCEPT_GREEN)
Diff in /app/src/tsp/tsp_verification_modal.rs:114:

 #[derive(Live, LiveHook, Widget)]
 pub struct TspVerificationModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: TspVerificationModalState,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: TspVerificationModalState,
[m }

 #[derive(Default)]
Diff in /app/src/tsp/tsp_verification_modal.rs:209:
                     // the wallet. If not, we need to show an error instructing the user
                     // to add that VID to their wallet first and then retry the verification process.
                     // Then, we need to send a negative response to the initiator of the request.
[31m-                    let error_text = if !wallet_db.has_private_vid(&details.responding_vid).is_ok_and(|v| v) {
[m[32m+                    let error_text = if !wallet_db
[m[32m+                        .has_private_vid(&details.responding_vid)
[m[32m+                        .is_ok_and(|v| v)
[m[32m+                    {
[m                         Some(format!(
                             "Error: the VID \"{}\" was not found in your current wallet.\n\n\
                             Either the requestor has the wrong VID for you, or you have not yet added that VID to your wallet.\n\n\
Diff in /app/src/tsp/tsp_verification_modal.rs:235:
                             accepted: false,
                         });
                         cancel_button.set_visible(cx, false);
[31m-                        accept_button.apply_over(cx, live!(
[m[31m-                            text: "Okay",
[m[31m-                            draw_bg: {
[m[31m-                                color: (COLOR_ACTIVE_PRIMARY),
[m[31m-                            },
[m[31m-                            draw_icon: {
[m[31m-                                color: (COLOR_PRIMARY),
[m[31m-                            }
[m[31m-                            draw_text: {
[m[31m-                                color: (COLOR_PRIMARY),
[m[31m-                            },
[m[31m-                        ));
[m[32m+                        accept_button.apply_over(
[m[32m+                            cx,
[m[32m+                            live!(
[m[32m+                                text: "Okay",
[m[32m+                                draw_bg: {
[m[32m+                                    color: (COLOR_ACTIVE_PRIMARY),
[m[32m+                                },
[m[32m+                                draw_icon: {
[m[32m+                                    color: (COLOR_PRIMARY),
[m[32m+                                }
[m[32m+                                draw_text: {
[m[32m+                                    color: (COLOR_PRIMARY),
[m[32m+                                },
[m[32m+                            ),
[m[32m+                        );
[m                         new_state = TspVerificationModalState::RequestDeclined;
[31m-                    }
[m[31m-                    else {
[m[31m-                        let prompt = format!("You have accepted the TSP verification request.\n\n\
[m[32m+                    } else {
[m[32m+                        let prompt = format!(
[m[32m+                            "You have accepted the TSP verification request.\n\n\
[m                             Please confirm that the following code matches for both users:\n\n\
                             Code: \"{}\"\n",
                             details.random_str,
Diff in /app/src/tsp/tsp_verification_modal.rs:257:
                         );
                         prompt_label.set_text(cx, &prompt);
                         accept_button.set_text(cx, "Yes, they match!");
[31m-                        new_state = TspVerificationModalState::RequestAccepted { details, wallet_db };
[m[32m+                        new_state =
[m[32m+                            TspVerificationModalState::RequestAccepted { details, wallet_db };
[m                     }
                 }

Diff in /app/src/tsp/tsp_verification_modal.rs:270:
                     let prompt_text = "You have confirmed the TSP verification request.\n\nSending a response now...";
                     prompt_label.set_text(cx, prompt_text);
                     accept_button.set_enabled(cx, false);
[31m-                    // stay in this same state until we get an acknowledgment back
[m[32m+                    // stay in this same state until we get an acknowledgment back
[m                     // that we sent the response (the `SentDidAssociationResponse` action).
                     new_state = TspVerificationModalState::RequestAccepted { details, wallet_db };
                 }
Diff in /app/src/tsp/tsp_verification_modal.rs:287:

         for action in actions {
             match action.downcast_ref() {
[31m-                Some(TspVerificationModalAction::SentDidAssociationResponse { details, result })
[m[31m-                    if self.state.details().is_some_and(|d| d == details) =>
[m[31m-                {
[m[32m+                Some(TspVerificationModalAction::SentDidAssociationResponse {
[m[32m+                    details,
[m[32m+                    result,
[m[32m+                }) if self.state.details().is_some_and(|d| d == details) => {
[m                     match result {
                         Ok(()) => {
                             self.label(ids!(prompt)).set_text(cx, "The TSP verification process has completed successfully.\n\nYou may now close this.");
Diff in /app/src/tsp/tsp_verification_modal.rs:296:
                             self.state = TspVerificationModalState::RequestVerified;
                         }
                         Err(e) => {
[31m-                            self.label(ids!(prompt)).set_text(cx, &format!("Error: failed to complete the TSP verification process:\n\n{e}"));
[m[32m+                            self.label(ids!(prompt)).set_text(
[m[32m+                                cx,
[m[32m+                                &format!(
[m[32m+                                    "Error: failed to complete the TSP verification process:\n\n{e}"
[m[32m+                                ),
[m[32m+                            );
[m                             self.state = TspVerificationModalState::RequestDeclined;
                         }
                     }
Diff in /app/src/tsp/tsp_verification_modal.rs:303:
                     cancel_button.set_visible(cx, false);
[31m-                    accept_button.apply_over(cx, live!(
[m[31m-                        enabled: true,
[m[31m-                        text: "Okay",
[m[31m-                        draw_bg: {
[m[31m-                            color: (COLOR_ACTIVE_PRIMARY),
[m[31m-                        },
[m[31m-                        draw_icon: {
[m[31m-                            color: (COLOR_PRIMARY),
[m[31m-                        }
[m[31m-                        draw_text: {
[m[31m-                            color: (COLOR_PRIMARY),
[m[31m-                        }
[m[31m-                    ));
[m[32m+                    accept_button.apply_over(
[m[32m+                        cx,
[m[32m+                        live!(
[m[32m+                            enabled: true,
[m[32m+                            text: "Okay",
[m[32m+                            draw_bg: {
[m[32m+                                color: (COLOR_ACTIVE_PRIMARY),
[m[32m+                            },
[m[32m+                            draw_icon: {
[m[32m+                                color: (COLOR_PRIMARY),
[m[32m+                            }
[m[32m+                            draw_text: {
[m[32m+                                color: (COLOR_PRIMARY),
[m[32m+                            }
[m[32m+                        ),
[m[32m+                    );
[m                     self.redraw(cx);
                 }
                 _ => {}
Diff in /app/src/tsp/tsp_verification_modal.rs:330:
         wallet_db: AsyncSecureStore,
     ) {
         log!("Initializing TSP verification modal with: {:?}", details);
[31m-        let prompt_text = format!("Matrix User \"{}\" is requesting to verify your identity via TSP.\n\
[m[32m+        let prompt_text = format!(
[m[32m+            "Matrix User \"{}\" is requesting to verify your identity via TSP.\n\
[m             Their TSP identity is: \"{}\".\n\n\
             They want to verify your TSP identity \"{}\" associated with Matrix User ID \"{}\".\n\n\
             If you recognize these details, would you like to accept this request?",
Diff in /app/src/tsp/tsp_verification_modal.rs:352:
         cancel_button.set_visible(cx, true);
         cancel_button.reset_hover(cx);

[31m-        self.state = TspVerificationModalState::ReceivedRequest {
[m[31m-            details,
[m[31m-            wallet_db,
[m[31m-        };
[m[32m+        self.state = TspVerificationModalState::ReceivedRequest { details, wallet_db };
[m     }
 }

Diff in /app/src/tsp/tsp_verification_modal.rs:363:
     /// Initialize this modal with the details of a TSP verification request.
     pub fn initialize_with_details(
         &self,
[31m-        cx: &mut Cx,
[m[32m+        cx: &mut Cx,
[m         details: TspVerificationDetails,
         wallet_db: AsyncSecureStore,
     ) {
Diff in /app/src/tsp/verify_user.rs:1:
[31m-
[m use makepad_widgets::*;
 use matrix_sdk::ruma::OwnedUserId;

Diff in /app/src/tsp/verify_user.rs:5:
[31m-use crate::{shared::popup_list::{enqueue_popup_notification, PopupKind}, tsp::{submit_tsp_request, tsp_state_ref, TspIdentityAction, TspRequest}};
[m[32m+use crate::{
[m[32m+    shared::popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+    tsp::{submit_tsp_request, tsp_state_ref, TspIdentityAction, TspRequest},
[m[32m+};
[m
 live_design! {
     link tsp_enabled
Diff in /app/src/tsp/verify_user.rs:141:

 #[derive(Live, LiveHook, Widget)]
 pub struct TspVerifyUser {
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m     /// The Matrix User ID of the other user that we want to verify.
[31m-    #[rust] user_id: Option<OwnedUserId>,
[m[32m+    #[rust]
[m[32m+    user_id: Option<OwnedUserId>,
[m     /// Info about whether the other user has or has not been verified via TSP.
[31m-    #[rust] verified_info: TspVerifiedInfo,
[m[32m+    #[rust]
[m[32m+    verified_info: TspVerifiedInfo,
[m }

 impl Widget for TspVerifyUser {
Diff in /app/src/tsp/verify_user.rs:160:
 }
 impl MatchEvent for TspVerifyUser {
     fn handle_actions(&mut self, cx: &mut Cx, actions: &Actions) {
[31m-        if self.view.button(ids!(remove_tsp_association_button)).clicked(actions) {
[m[32m+        if self
[m[32m+            .view
[m[32m+            .button(ids!(remove_tsp_association_button))
[m[32m+            .clicked(actions)
[m[32m+        {
[m             enqueue_popup_notification(
                 "Removing a TSP association is not yet implemented",
                 PopupKind::Warning,
Diff in /app/src/tsp/verify_user.rs:193:
                 {
                     verify_user_button.set_text(cx, "Sent request!");
                     enqueue_popup_notification(
[31m-                        format!("Sent TSP verification request.\n\nWaiting for \"{user_id}\" to respond..."),
[m[32m+                        format!(
[m[32m+                            "Sent TSP verification request.\n\nWaiting for \"{user_id}\" to respond..."
[m[32m+                        ),
[m                         PopupKind::Info,
                         Some(5.0),
                     );
Diff in /app/src/tsp/verify_user.rs:200:
                 }
[31m-                Some(TspIdentityAction::ErrorSendingDidAssociationRequest { user_id, error, .. })
[m[31m-                    if Some(user_id) == self.user_id.as_ref() =>
[m[31m-                {
[m[32m+                Some(TspIdentityAction::ErrorSendingDidAssociationRequest {
[m[32m+                    user_id,
[m[32m+                    error,
[m[32m+                    ..
[m[32m+                }) if Some(user_id) == self.user_id.as_ref() => {
[m                     verify_user_button.set_enabled(cx, true);
                     verify_user_button.set_text(cx, "Verify this user via TSP");
                     enqueue_popup_notification(
Diff in /app/src/tsp/verify_user.rs:209:
                         None,
                     );
                 }
[31m-                Some(TspIdentityAction::ReceivedDidAssociationResponse { did, user_id, accepted })
[m[31m-                    if Some(user_id) == self.user_id.as_ref() =>
[m[31m-                {
[m[32m+                Some(TspIdentityAction::ReceivedDidAssociationResponse {
[m[32m+                    did,
[m[32m+                    user_id,
[m[32m+                    accepted,
[m[32m+                }) if Some(user_id) == self.user_id.as_ref() => {
[m                     if *accepted {
                         enqueue_popup_notification(
                             format!("User \"{user_id}\" accepted your TSP verification request."),
Diff in /app/src/tsp/verify_user.rs:245:
             TspVerifiedInfo::Verified { did } => {
                 verified_tsp_view.set_visible(cx, true);
                 unverified_tsp_view.set_visible(cx, false);
[31m-                verified_tsp_view.text_input(ids!(tsp_did_read_only_input)).set_text(cx, did);
[m[32m+                verified_tsp_view
[m[32m+                    .text_input(ids!(tsp_did_read_only_input))
[m[32m+                    .set_text(cx, did);
[m             }
             TspVerifiedInfo::Unverified => {
                 verified_tsp_view.set_visible(cx, false);
Diff in /app/src/tsp/verify_user.rs:252:
                 unverified_tsp_view.set_visible(cx, true);
[31m-                unverified_tsp_view.text_input(ids!(tsp_did_input)).set_text(cx, "");
[m[32m+                unverified_tsp_view
[m[32m+                    .text_input(ids!(tsp_did_input))
[m[32m+                    .set_text(cx, "");
[m                 let verify_user_button = unverified_tsp_view.button(ids!(verify_user_button));
                 verify_user_button.set_enabled(cx, true);
                 verify_user_button.set_text(cx, "Verify this user via TSP");
Diff in /app/src/tsp/verify_user.rs:259:
     }

     fn show(&mut self, cx: &mut Cx, user_id: OwnedUserId) {
[31m-        let verified_info = tsp_state_ref().lock().unwrap()
[m[32m+        let verified_info = tsp_state_ref()
[m[32m+            .lock()
[m[32m+            .unwrap()
[m             .get_associated_did(&user_id)
[31m-            .map_or(
[m[31m-                TspVerifiedInfo::Unverified,
[m[31m-                |did| TspVerifiedInfo::Verified { did: did.to_string() },
[m[31m-            );
[m[32m+            .map_or(TspVerifiedInfo::Unverified, |did| {
[m[32m+                TspVerifiedInfo::Verified {
[m[32m+                    did: did.to_string(),
[m[32m+                }
[m[32m+            });
[m
         self.verified_info = verified_info;
         self.user_id = Some(user_id);
Diff in /app/src/tsp/verify_user.rs:274:

 impl TspVerifyUserRef {
     pub fn show(&self, cx: &mut Cx, user_id: OwnedUserId) {
[31m-        let Some(mut inner) = self.borrow_mut() else { return };
[m[32m+        let Some(mut inner) = self.borrow_mut() else {
[m[32m+            return;
[m[32m+        };
[m         inner.show(cx, user_id);
     }
 }
Diff in /app/src/tsp/wallet_entry/mod.rs:1:
[31m-
[m use std::cell::RefCell;

 use makepad_widgets::*;
Diff in /app/src/tsp/wallet_entry/mod.rs:5:

 use crate::{
     app::ConfirmDeleteAction,
[31m-    shared::{confirmation_modal::ConfirmationModalContent, popup_list::{enqueue_popup_notification, PopupKind}},
[m[31m-    tsp::{submit_tsp_request, tsp_settings_screen::{WalletStatus, WalletStatusAndDefault}, TspRequest, TspWalletMetadata}
[m[32m+    shared::{
[m[32m+        confirmation_modal::ConfirmationModalContent,
[m[32m+        popup_list::{enqueue_popup_notification, PopupKind},
[m[32m+    },
[m[32m+    tsp::{
[m[32m+        submit_tsp_request,
[m[32m+        tsp_settings_screen::{WalletStatus, WalletStatusAndDefault},
[m[32m+        TspRequest, TspWalletMetadata,
[m[32m+    },
[m };

 live_design! {
Diff in /app/src/tsp/wallet_entry/mod.rs:143:

 }

[31m-
[m /// A view showing the details of a single TSP wallet (one entry in the wallets list).
 #[derive(Live, LiveHook, Widget)]
 pub struct WalletEntry {
Diff in /app/src/tsp/wallet_entry/mod.rs:150:
[31m-    #[deref] view: View,
[m[32m+    #[deref]
[m[32m+    view: View,
[m
[31m-    #[rust] metadata: Option<TspWalletMetadata>,
[m[32m+    #[rust]
[m[32m+    metadata: Option<TspWalletMetadata>,
[m }

 impl Widget for WalletEntry {
Diff in /app/src/tsp/wallet_entry/mod.rs:156:
     fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
         self.view.handle_event(cx, event, scope);

[31m-        let Some(metadata) = self.metadata.as_ref() else { return };
[m[32m+        let Some(metadata) = self.metadata.as_ref() else {
[m[32m+            return;
[m[32m+        };
[m         if let Event::Actions(actions) = event {
[31m-            if self.view.button(ids!(set_default_wallet_button)).clicked(actions) {
[m[32m+            if self
[m[32m+                .view
[m[32m+                .button(ids!(set_default_wallet_button))
[m[32m+                .clicked(actions)
[m[32m+            {
[m                 submit_tsp_request(TspRequest::SetDefaultWallet(metadata.clone()));
             }

Diff in /app/src/tsp/wallet_entry/mod.rs:165:
[31m-            if self.view.button(ids!(remove_wallet_button)).clicked(actions) {
[m[32m+            if self
[m[32m+                .view
[m[32m+                .button(ids!(remove_wallet_button))
[m[32m+                .clicked(actions)
[m[32m+            {
[m                 let metadata_clone = metadata.clone();
                 let content = ConfirmationModalContent {
                     title_text: "Remove Wallet".into(),
Diff in /app/src/tsp/wallet_entry/mod.rs:170:
                         "Are you sure you want to remove the wallet \"{}\" \
                         from the list?\n\nThis won't delete the actual wallet file.",
                         metadata.wallet_name
[31m-                    ).into(),
[m[32m+                    )
[m[32m+                    .into(),
[m                     accept_button_text: Some("Remove".into()),
                     on_accept_clicked: Some(Box::new(move |_cx| {
                         submit_tsp_request(TspRequest::RemoveWallet(metadata_clone));
Diff in /app/src/tsp/wallet_entry/mod.rs:180:
                 cx.action(ConfirmDeleteAction::Show(RefCell::new(Some(content))));
             }

[31m-            if self.view.button(ids!(delete_wallet_button)).clicked(actions) {
[m[32m+            if self
[m[32m+                .view
[m[32m+                .button(ids!(delete_wallet_button))
[m[32m+                .clicked(actions)
[m[32m+            {
[m                 // TODO: Implement the delete wallet feature.
                 enqueue_popup_notification(
                     "Delete wallet feature is not yet implemented.",
Diff in /app/src/tsp/wallet_entry/mod.rs:200:
             self.metadata = Some(metadata.clone());
         }

[31m-        self.label(ids!(wallet_name)).set_text(
[m[31m-            cx,
[m[31m-            &metadata.wallet_name,
[m[31m-        );
[m[31m-        self.label(ids!(wallet_path)).set_text(
[m[31m-            cx,
[m[31m-            metadata.url.as_url_unencoded()
[m[31m-        );
[m[32m+        self.label(ids!(wallet_name))
[m[32m+            .set_text(cx, &metadata.wallet_name);
[m[32m+        self.label(ids!(wallet_path))
[m[32m+            .set_text(cx, metadata.url.as_url_unencoded());
[m         // There is a weird makepad bug where if we re-style one instance of the
         // `set_default_wallet_button` in one WalletEntry, all other instances of that button
         // get their styling messed up in weird ways.
Diff in /app/src/tsp/wallet_entry/mod.rs:214:
         // So, as a workaround, we just hide the button entirely and show a `is_default_label_view` instead.

[31m-        self.view(ids!(is_default_label_view)).set_visible(
[m[31m-            cx,
[m[31m-            sd.is_default
[m[31m-        );
[m[31m-        self.label(ids!(not_found_label_view)).set_visible(
[m[31m-            cx,
[m[31m-            sd.status == WalletStatus::NotFound,
[m[31m-        );
[m[31m-        self.button(ids!(set_default_wallet_button)).set_visible(
[m[31m-            cx,
[m[31m-            !sd.is_default && sd.status != WalletStatus::NotFound,
[m[31m-        );
[m[31m-        self.button(ids!(delete_wallet_button)).set_visible(
[m[31m-            cx,
[m[31m-            sd.status != WalletStatus::NotFound,
[m[31m-        );
[m[32m+        self.view(ids!(is_default_label_view))
[m[32m+            .set_visible(cx, sd.is_default);
[m[32m+        self.label(ids!(not_found_label_view))
[m[32m+            .set_visible(cx, sd.status == WalletStatus::NotFound);
[m[32m+        self.button(ids!(set_default_wallet_button))
[m[32m+            .set_visible(cx, !sd.is_default && sd.status != WalletStatus::NotFound);
[m[32m+        self.button(ids!(delete_wallet_button))
[m[32m+            .set_visible(cx, sd.status != WalletStatus::NotFound);
[m
         self.view.draw_walk(cx, scope, walk)
     }
Diff in /app/src/utils.rs:1:
[31m-use std::{borrow::Cow, ops::{Deref, DerefMut}, time::SystemTime};
[m[32m+use std::{
[m[32m+    borrow::Cow,
[m[32m+    ops::{Deref, DerefMut},
[m[32m+    time::SystemTime,
[m[32m+};
[m use serde::{Deserialize, Serialize};
 use url::Url;

Diff in /app/src/utils.rs:5:
 use unicode_segmentation::UnicodeSegmentation;
 use chrono::{DateTime, Duration, Local, TimeZone};
 use makepad_widgets::{Cx, Event, ImageRef, error, image_cache::ImageError};
[31m-use matrix_sdk::{media::{MediaFormat, MediaThumbnailSettings}, ruma::{api::client::media::get_content_thumbnail::v3::Method, MilliSecondsSinceUnixEpoch, OwnedRoomId, RoomId}, RoomDisplayName};
[m[32m+use matrix_sdk::{
[m[32m+    media::{MediaFormat, MediaThumbnailSettings},
[m[32m+    ruma::{
[m[32m+        api::client::media::get_content_thumbnail::v3::Method, MilliSecondsSinceUnixEpoch,
[m[32m+        OwnedRoomId, RoomId,
[m[32m+    },
[m[32m+    RoomDisplayName,
[m[32m+};
[m use matrix_sdk_ui::timeline::{EventTimelineItem, PaginationError, TimelineDetails};

[31m-use crate::{room::FetchedRoomAvatar, sliding_sync::{submit_async_request, MatrixRequest}};
[m[32m+use crate::{
[m[32m+    room::FetchedRoomAvatar,
[m[32m+    sliding_sync::{submit_async_request, MatrixRequest},
[m[32m+};
[m
 /// The scheme for GEO links, used for location messages in Matrix.
 pub const GEO_URI_SCHEME: &str = "geo:";
Diff in /app/src/utils.rs:15:

[31m-
[m /// A wrapper type that implements the `Debug` trait for non-`Debug` types.
 pub struct DebugWrapper<T>(T);
 impl<T> std::fmt::Debug for DebugWrapper<T> {
Diff in /app/src/utils.rs:55:
     matches!(
         event,
         Event::MouseDown(..)
[31m-        | Event::MouseUp(..)
[m[31m-        | Event::MouseMove(..)
[m[31m-        | Event::MouseLeave(..)
[m[31m-        | Event::TouchUpdate(..)
[m[31m-        | Event::Scroll(..)
[m[31m-        | Event::KeyDown(..)
[m[31m-        | Event::KeyUp(..)
[m[31m-        | Event::TextInput(..)
[m[31m-        | Event::TextCopy(..)
[m[31m-        | Event::TextCut(..)
[m[32m+            | Event::MouseUp(..)
[m[32m+            | Event::MouseMove(..)
[m[32m+            | Event::MouseLeave(..)
[m[32m+            | Event::TouchUpdate(..)
[m[32m+            | Event::Scroll(..)
[m[32m+            | Event::KeyDown(..)
[m[32m+            | Event::KeyUp(..)
[m[32m+            | Event::TextInput(..)
[m[32m+            | Event::TextCopy(..)
[m[32m+            | Event::TextCut(..)
[m     )
 }

Diff in /app/src/utils.rs:91:
 ///
 /// Returns an error if either load fails or if the image format is unknown.
 pub fn load_png_or_jpg(img: &ImageRef, cx: &mut Cx, data: &[u8]) -> Result<(), ImageError> {
[31m-
[m     fn attempt_both(img: &ImageRef, cx: &mut Cx, data: &[u8]) -> Result<(), ImageError> {
         img.load_png_from_data(cx, data)
             .or_else(|_| img.load_jpg_from_data(cx, data))
Diff in /app/src/utils.rs:127:
         );
         path.push(filename);
         path.set_extension("unknown");
[31m-        error!("Failed to load PNG/JPG: {err}. Dumping bad image: {:?}", path);
[m[32m+        error!(
[m[32m+            "Failed to load PNG/JPG: {err}. Dumping bad image: {:?}",
[m[32m+            path
[m[32m+        );
[m         let _ = std::fs::write(path, data)
             .inspect_err(|e| error!("Failed to write bad image to disk: {e}"));
     }
Diff in /app/src/utils.rs:134:
     res
 }

[31m-
[m /// A simplified version of `eyeball_im::VectorDiff` that uses `Vec` instead of `imbl::Vector`.
 ///
 /// This is used to communicate room order changes from the room list service to the RoomsList widget.
Diff in /app/src/utils.rs:162:
     Truncate { length: usize },
 }

[31m-
[m pub fn unix_time_millis_to_datetime(millis: MilliSecondsSinceUnixEpoch) -> Option<DateTime<Local>> {
     let millis: i64 = millis.get().into();
     Local.timestamp_millis_opt(millis).single()
Diff in /app/src/utils.rs:170:

 /// Replaces all line breaks, tabs, paragraphs and other separators with a single space `' '`.
 pub fn replace_linebreaks_separators(s: &str) -> String {
[31m-    s.replace(
[m[31m-        ['\n', '\r', '\t', '\x0B', '\x0C', '\x0D'],
[m[31m-        " ",
[m[31m-    )
[m[32m+    s.replace(['\n', '\r', '\t', '\x0B', '\x0C', '\x0D'], " ")
[m }

 /// Looks for and removes the `<mx-reply>` element from the given HTML message body, if it exists.
Diff in /app/src/utils.rs:182:
 /// <https://spec.matrix.org/v1.13/client-server-api/#rich-replies>
 pub fn remove_mx_reply(html_message_body: &str) -> &str {
     const MX_REPLY_START: &str = "<mx-reply>";
[31m-    const MX_REPLY_END:   &str = "</mx-reply>";
[m[32m+    const MX_REPLY_END: &str = "</mx-reply>";
[m     if html_message_body.trim().starts_with(MX_REPLY_START) {
         if let Some(end) = html_message_body.find(MX_REPLY_END) {
[31m-            if let Some(after) = html_message_body.get(end + MX_REPLY_END.len() ..) {
[m[32m+            if let Some(after) = html_message_body.get(end + MX_REPLY_END.len()..) {
[m                 return after;
             }
         }
Diff in /app/src/utils.rs:205:
         // We get the string representation of the error and then search for the "got" state.
         matrix_sdk::Error::WrongRoomState(wrs) => {
             if was_join && wrs.to_string().contains(", got: Joined") {
[31m-                Some(format!("Failed to join {room_name_id}: it has already been joined."))
[m[32m+                Some(format!(
[m[32m+                    "Failed to join {room_name_id}: it has already been joined."
[m[32m+                ))
[m             } else if !was_join && wrs.to_string().contains(", got: Left") {
[31m-                Some(format!("Failed to leave {room_name_id}: it has already been left."))
[m[32m+                Some(format!(
[m[32m+                    "Failed to leave {room_name_id}: it has already been left."
[m[32m+                ))
[m             } else {
                 None
             }
Diff in /app/src/utils.rs:216:
         // This avoids the weird "no known servers" error, which is misleading and incorrect.
         // See: <https://github.com/element-hq/element-web/issues/25627>.
         matrix_sdk::Error::Http(error)
[31m-            if error.as_client_api_error().is_some_and(|e| e.status_code.as_u16() == 404) =>
[m[32m+            if error
[m[32m+                .as_client_api_error()
[m[32m+                .is_some_and(|e| e.status_code.as_u16() == 404) =>
[m         {
             Some(format!(
                 "Failed to {} {room_name_id}: the room no longer exists on the server.{}",
Diff in /app/src/utils.rs:223:
                 if was_join { "join" } else { "leave" },
[31m-                if was_join && was_invite { "\n\nYou may safely reject this invite." } else { "" },
[m[32m+                if was_join && was_invite {
[m[32m+                    "\n\nYou may safely reject this invite."
[m[32m+                } else {
[m[32m+                    ""
[m[32m+                },
[m             ))
         }
         _ => None,
Diff in /app/src/utils.rs:228:
     };
[31m-    msg_opt.unwrap_or_else(|| format!(
[m[31m-        "Failed to {} {}: {}",
[m[31m-        match (was_join, was_invite) {
[m[31m-            (true, true) => "accept invite to",
[m[31m-            (true, false) => "join",
[m[31m-            (false, true) => "reject invite to",
[m[31m-            (false, false) => "leave",
[m[31m-        },
[m[31m-        room_name_id,
[m[31m-        error
[m[31m-    ))
[m[32m+    msg_opt.unwrap_or_else(|| {
[m[32m+        format!(
[m[32m+            "Failed to {} {}: {}",
[m[32m+            match (was_join, was_invite) {
[m[32m+                (true, true) => "accept invite to",
[m[32m+                (true, false) => "join",
[m[32m+                (false, true) => "reject invite to",
[m[32m+                (false, false) => "leave",
[m[32m+            },
[m[32m+            room_name_id,
[m[32m+            error
[m[32m+        )
[m[32m+    })
[m }

 /// Returns a string error message for pagination errors,
Diff in /app/src/utils.rs:253:
         match sdk_error {
             matrix_sdk::Error::Http(http_error) => match http_error.deref() {
                 matrix_sdk::HttpError::Reqwest(reqwest_error) if reqwest_error.is_timeout() => {
[31m-                    return Some(format!("Failed to load earlier messages in \"{room_name}\": request timed out."));
[m[32m+                    return Some(format!(
[m[32m+                        "Failed to load earlier messages in \"{room_name}\": request timed out."
[m[32m+                    ));
[m                 }
                 _ => {}
[31m-            }
[m[32m+            },
[m             _ => {}
         }
         None
Diff in /app/src/utils.rs:264:

     match error {
         TimelineError::PaginationError(PaginationError::NotSupported) => {
[31m-            return format!("Failed to load earlier messages in \"{room_name}\": \
[m[31m-                pagination is not supported in this timeline focus mode.");
[m[32m+            return format!(
[m[32m+                "Failed to load earlier messages in \"{room_name}\": \
[m[32m+                pagination is not supported in this timeline focus mode."
[m[32m+            );
[m         }
[31m-        TimelineError::PaginationError(PaginationError::Paginator(PaginatorError::SdkError(sdk_error)))
[m[31m-        | TimelineError::EventCacheError(EventCacheError::BackpaginationError(sdk_error)) =>
[m[31m-        {
[m[32m+        TimelineError::PaginationError(PaginationError::Paginator(PaginatorError::SdkError(
[m[32m+            sdk_error,
[m[32m+        )))
[m[32m+        | TimelineError::EventCacheError(EventCacheError::BackpaginationError(sdk_error)) => {
[m             if let Some(message) = match_sdk_error(sdk_error) {
[31m-                return message;
[m[32m+                return message;
[m             }
         }
         _ => {}
Diff in /app/src/utils.rs:279:
     format!("Failed to load earlier messages in \"{room_name}\": {error}")
 }

[31m-
[m[31m-
[m /// Formats a given Unix timestamp in milliseconds into a relative human-readable date.
 ///
 /// # Cases:
Diff in /app/src/utils.rs:307:
     if duration < Duration::seconds(60) {
         Some("Now".to_string())
     } else if duration < Duration::minutes(60) {
[31m-        let minutes_text = if duration.num_minutes() == 1 { "min" } else { "mins" };
[m[32m+        let minutes_text = if duration.num_minutes() == 1 {
[m[32m+            "min"
[m[32m+        } else {
[m[32m+            "mins"
[m[32m+        };
[m         Some(format!("{} {} ago", duration.num_minutes(), minutes_text))
     } else if duration < Duration::hours(24) && now.date_naive() == datetime.date_naive() {
         Some(format!("{}", datetime.format("%H:%M"))) // "HH:MM" format for today
Diff in /app/src/utils.rs:329:
 /// skipping any leading "@" characters.
 pub fn user_name_first_letter(user_name: &str) -> Option<&str> {
     use unicode_segmentation::UnicodeSegmentation;
[31m-    user_name
[m[31m-        .graphemes(true)
[m[31m-        .find(|&g| g != "@")
[m[32m+    user_name.graphemes(true).find(|&g| g != "@")
[m }

[31m-
[m /// A const-compatible version of [`MediaFormat`].
 #[derive(Clone, Debug)]
 pub enum MediaFormatConst {
Diff in /app/src/utils.rs:382:
     }
 }

[31m-
[m /// The thumbnail format to use for user and room avatars.
[31m-pub const AVATAR_THUMBNAIL_FORMAT: MediaFormatConst = MediaFormatConst::Thumbnail(
[m[31m-    MediaThumbnailSettingsConst {
[m[32m+pub const AVATAR_THUMBNAIL_FORMAT: MediaFormatConst =
[m[32m+    MediaFormatConst::Thumbnail(MediaThumbnailSettingsConst {
[m         method: Method::Scale,
         width: 40,
         height: 40,
Diff in /app/src/utils.rs:392:
         animated: false,
[31m-    }
[m[31m-);
[m[32m+    });
[m
 /// The thumbnail format to use for regular media images.
[31m-pub const MEDIA_THUMBNAIL_FORMAT: MediaFormatConst = MediaFormatConst::Thumbnail(
[m[31m-    MediaThumbnailSettingsConst {
[m[32m+pub const MEDIA_THUMBNAIL_FORMAT: MediaFormatConst =
[m[32m+    MediaFormatConst::Thumbnail(MediaThumbnailSettingsConst {
[m         method: Method::Scale,
         width: 400,
         height: 400,
Diff in /app/src/utils.rs:402:
         animated: false,
[31m-    }
[m[31m-);
[m[32m+    });
[m
 /// Removes leading whitespace and HTML whitespace tags (`<p>` and `<br>`) from the given `text`.
 pub fn trim_start_html_whitespace(mut text: &str) -> &str {
Diff in /app/src/utils.rs:433:
     const MAILTO: &str = "mailto:";

     use linkify::{Link, LinkFinder, LinkKind};
[31m-    let mut links = LinkFinder::new()
[m[31m-        .links(text)
[m[31m-        .peekable();
[m[32m+    let mut links = LinkFinder::new().links(text).peekable();
[m     if links.peek().is_none() {
         return Cow::Borrowed(text);
     }
Diff in /app/src/utils.rs:455:
         let link_txt = link.as_str();

         // Only linkify the URL if it's not already part of an HTML or mailto href attribute.
[31m-        let is_link_within_href_attr = text.get(.. link.start())
[m[31m-            .is_some_and(ends_with_href);
[m[32m+        let is_link_within_href_attr = text.get(..link.start()).is_some_and(ends_with_href);
[m         let is_link_within_html_tag = |link: &Link| {
[31m-            text.get(link.end() ..)
[m[32m+            text.get(link.end()..)
[m                 .is_some_and(|after| after.trim_end().starts_with("</a>"))
         };
         let is_mailto_link_within_href_attr = |link: &Link| {
Diff in /app/src/utils.rs:465:
[31m-            if !matches!(link.kind(), LinkKind::Email) { return false; }
[m[32m+            if !matches!(link.kind(), LinkKind::Email) {
[m[32m+                return false;
[m[32m+            }
[m             let mailto_start = link.start().saturating_sub(MAILTO.len());
[31m-            text.get(mailto_start .. link.start())
[m[32m+            text.get(mailto_start..link.start())
[m                 .is_some_and(|t| t == MAILTO)
[31m-                .then(|| text.get(.. mailto_start))
[m[32m+                .then(|| text.get(..mailto_start))
[m                 .flatten()
                 .is_some_and(ends_with_href)
         };
Diff in /app/src/utils.rs:512:
         }
         last_end_index = link.end();
     }
[31m-    linkified_text.push_str(
[m[31m-        &escaped(text.get(last_end_index..).unwrap_or_default())
[m[31m-    );
[m[32m+    linkified_text.push_str(&escaped(text.get(last_end_index..).unwrap_or_default()));
[m     Cow::Owned(linkified_text)
 }

Diff in /app/src/utils.rs:540:
     match substr.as_bytes().last() {
         Some(b'\'' | b'"') => {
             if substr
[31m-                .get(.. substr.len().saturating_sub(1))
[m[32m+                .get(..substr.len().saturating_sub(1))
[m                 .map(|s| {
                     substr = s.trim_end();
                     substr.as_bytes().last() == Some(&b'=')
Diff in /app/src/utils.rs:573:
 /// ```
 pub fn human_readable_list<S>(names: &[S], limit: usize) -> String
 where
[31m-    S: AsRef<str>
[m[32m+    S: AsRef<str>,
[m {
     let mut result = String::new();
     match names.len() {
Diff in /app/src/utils.rs:580:
         0 => return result, // early return if no names provided
         1 => {
             result.push_str(names[0].as_ref());
[31m-        },
[m[32m+        }
[m         2 => {
             result.push_str(names[0].as_ref());
             result.push_str(" and ");
Diff in /app/src/utils.rs:587:
             result.push_str(names[1].as_ref());
[31m-        },
[m[32m+        }
[m         _ => {
             let display_count = names.len().min(limit);
             for (i, name) in names.iter().take(display_count - 1).enumerate() {
Diff in /app/src/utils.rs:613:
     result
 }

[31m-
[m /// Returns the sender's display name if available.
 ///
 /// If not available, and if the `room_id` is provided, this function will
Diff in /app/src/utils.rs:674:

 /// Safely replaces text between byte indices with a new string,
 /// ensuring proper grapheme boundaries are respected
[31m-pub fn safe_replace_by_byte_indices(text: &str, start_byte: usize, end_byte: usize, replacement: &str) -> String {
[m[32m+pub fn safe_replace_by_byte_indices(
[m[32m+    text: &str,
[m[32m+    start_byte: usize,
[m[32m+    end_byte: usize,
[m[32m+    replacement: &str,
[m[32m+) -> String {
[m     let text_graphemes: Vec<&str> = text.graphemes(true).collect();

     let start_grapheme_idx = byte_index_to_grapheme_index(text, start_byte);
Diff in /app/src/utils.rs:719:
 impl RoomNameId {
     /// Create a new `RoomNameId` with the given display name and room ID.
     pub fn new(display_name: RoomDisplayName, room_id: OwnedRoomId) -> Self {
[31m-        Self { display_name, room_id }
[m[32m+        Self {
[m[32m+            display_name,
[m[32m+            room_id,
[m[32m+        }
[m     }

     /// Creates a new `RoomNameId` with an empty display name.
Diff in /app/src/utils.rs:780:
         self.room_id == other.room_id
     }
 }
[31m-impl Eq for RoomNameId { }
[m[32m+impl Eq for RoomNameId {}
[m impl std::fmt::Debug for RoomNameId {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         let mut ds = f.debug_struct("RoomNameId");
Diff in /app/src/utils.rs:787:
         match &self.display_name {
             RoomDisplayName::Empty => ds.field("name", &"Empty"),
[31m-            RoomDisplayName::EmptyWas(name) => ds.field("name", &format!("Empty Room (was \"{name}\")")),
[m[32m+            RoomDisplayName::EmptyWas(name) => {
[m[32m+                ds.field("name", &format!("Empty Room (was \"{name}\")"))
[m[32m+            }
[m             RoomDisplayName::Aliased(name)
             | RoomDisplayName::Calculated(name)
[31m-            | RoomDisplayName::Named(name) => ds.field("name", name)
[m[32m+            | RoomDisplayName::Named(name) => ds.field("name", name),
[m         };
[31m-        ds.field("ID", &self.room_id)
[m[31m-            .finish()
[m[32m+        ds.field("ID", &self.room_id).finish()
[m     }
 }
 impl std::ops::Deref for RoomNameId {
Diff in /app/src/utils.rs:852:
 ///
 /// Skips the first character if it is a `#` or `!`, the sigils used for Room aliases and Room IDs.
 pub fn avatar_from_room_name(room_name: Option<&str>) -> FetchedRoomAvatar {
[31m-    let first = room_name.and_then(|rn| rn
[m[31m-        .graphemes(true)
[m[31m-        .find(|&g| g != "#" && g != "!")
[m[31m-        .map(ToString::to_string)
[m[31m-    ).unwrap_or_else(|| String::from("?"));
[m[32m+    let first = room_name
[m[32m+        .and_then(|rn| {
[m[32m+            rn.graphemes(true)
[m[32m+                .find(|&g| g != "#" && g != "!")
[m[32m+                .map(ToString::to_string)
[m[32m+        })
[m[32m+        .unwrap_or_else(|| String::from("?"));
[m     FetchedRoomAvatar::Text(first)
 }

Diff in /app/src/utils.rs:863:
[31m-
[m #[cfg(test)]
 mod tests_room_name {
     use super::*;
Diff in /app/src/utils.rs:875:
     #[test]
     fn to_string_prefers_display_name() {
         let room_id = sample_room_id("!preferred:example.org");
[31m-        let room_name = RoomNameId::new(RoomDisplayName::Named("Hello World".into()), room_id.clone());
[m[32m+        let room_name = RoomNameId::new(
[m[32m+            RoomDisplayName::Named("Hello World".into()),
[m[32m+            room_id.clone(),
[m[32m+        );
[m         assert_eq!(room_name.to_string(), "Hello World");
         assert_eq!(room_name.room_id().as_str(), room_id.as_str());
     }
Diff in /app/src/utils.rs:884:
     fn to_string_falls_back_to_id_when_empty() {
         let room_id = sample_room_id("!fallback:example.org");
         let room_name = RoomNameId::new(RoomDisplayName::Empty, room_id.clone());
[31m-        assert_eq!(room_name.to_string(), format!("Room ID {}", room_id.as_str()));
[m[32m+        assert_eq!(
[m[32m+            room_name.to_string(),
[m[32m+            format!("Room ID {}", room_id.as_str())
[m[32m+        );
[m     }

     #[test]
Diff in /app/src/utils.rs:928:

     #[test]
     fn test_human_readable_list_long() {
[31m-        let names: Vec<&str> = vec!["Alice", "Bob", "Charlie", "Dennis", "Eudora", "Fanny", "Gina", "Hiroshi", "Ivan", "James", "Karen", "Lisa", "Michael", "Nathan", "Oliver", "Peter", "Quentin", "Rachel", "Sally", "Tanya", "Ulysses", "Victor", "William", "Xenia", "Yuval", "Zachariah"];
[m[32m+        let names: Vec<&str> = vec![
[m[32m+            "Alice",
[m[32m+            "Bob",
[m[32m+            "Charlie",
[m[32m+            "Dennis",
[m[32m+            "Eudora",
[m[32m+            "Fanny",
[m[32m+            "Gina",
[m[32m+            "Hiroshi",
[m[32m+            "Ivan",
[m[32m+            "James",
[m[32m+            "Karen",
[m[32m+            "Lisa",
[m[32m+            "Michael",
[m[32m+            "Nathan",
[m[32m+            "Oliver",
[m[32m+            "Peter",
[m[32m+            "Quentin",
[m[32m+            "Rachel",
[m[32m+            "Sally",
[m[32m+            "Tanya",
[m[32m+            "Ulysses",
[m[32m+            "Victor",
[m[32m+            "William",
[m[32m+            "Xenia",
[m[32m+            "Yuval",
[m[32m+            "Zachariah",
[m[32m+        ];
[m         let result = human_readable_list(&names, 3);
         assert_eq!(result, "Alice, Bob, Charlie, and 23 others");
     }
Diff in /app/src/utils.rs:947:
     #[test]
     fn test_linkify1() {
         let text = "Check out this website: https://example.com";
[31m-        let expected = "Check out this website: <a href=\"https://example.com\">https://example.com</a>";
[m[32m+        let expected =
[m[32m+            "Check out this website: <a href=\"https://example.com\">https://example.com</a>";
[m         let actual = linkify(text, false);
         println!("{:?}", actual.as_ref());
         assert_eq!(actual.as_ref(), expected);
Diff in /app/src/utils.rs:977:
         assert_eq!(actual.as_ref(), expected);
     }

[31m-
[m     #[test]
     fn test_linkify5() {
         let text = "html test <a href=http://google.com>Link title</a> Link 2 https://example.com";
Diff in /app/src/utils.rs:1022:
         assert_eq!(linkify(text, true).as_ref(), expected);
     }

[31m-
[m     #[test]
     fn test_linkify11() {
         let text = "And then https://google.com call <a href=\"https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_until\"><code>read_until</code></a> or other <code>BufRead</code> methods.";
Diff in /app/src/utils.rs:1039:

     #[test]
     fn test_linkify13() {
[31m-        let text = "Check out this website: <a href=\"https://example.com\">https://example.com</a>";
[m[31m-        let expected = "Check out this website: <a href=\"https://example.com\">https://example.com</a>";
[m[32m+        let text =
[m[32m+            "Check out this website: <a href=\"https://example.com\">https://example.com</a>";
[m[32m+        let expected =
[m[32m+            "Check out this website: <a href=\"https://example.com\">https://example.com</a>";
[m         assert_eq!(linkify(text, true).as_ref(), expected);
     }

Diff in /app/src/verification.rs:4:
 use matrix_sdk_base::crypto::{AcceptedProtocols, CancelInfo, EmojiShortAuthString};
 use matrix_sdk::{
     encryption::{
[31m-        verification::{SasState, SasVerification, Verification, VerificationRequest, VerificationRequestState}, VerificationState}, ruma::{
[m[32m+        verification::{
[m[32m+            SasState, SasVerification, Verification, VerificationRequest, VerificationRequestState,
[m[32m+        },
[m[32m+        VerificationState,
[m[32m+    },
[m[32m+    ruma::{
[m         events::{
             key::verification::{request::ToDeviceKeyVerificationRequestEvent, VerificationMethod},
             room::message::{MessageType, OriginalSyncRoomMessageEvent},
Diff in /app/src/verification.rs:11:
         },
         UserId,
[31m-    }, Client
[m[32m+    },
[m[32m+    Client,
[m };
[31m-use tokio::{runtime::Handle, sync::mpsc::{UnboundedReceiver, UnboundedSender}};
[m[32m+use tokio::{
[m[32m+    runtime::Handle,
[m[32m+    sync::mpsc::{UnboundedReceiver, UnboundedSender},
[m[32m+};
[m
 #[derive(Clone, Debug, DefaultNone)]
 pub enum VerificationStateAction {
Diff in /app/src/verification.rs:22:

 pub fn add_verification_event_handlers_and_sync_client(client: Client) {
     let mut verification_state_subscriber = client.encryption().verification_state();
[31m-    log!("Initial verification state is {:?}", verification_state_subscriber.get());
[m[32m+    log!(
[m[32m+        "Initial verification state is {:?}",
[m[32m+        verification_state_subscriber.get()
[m[32m+    );
[m     Handle::current().spawn(async move {
         while let Some(state) = verification_state_subscriber.next().await {
             log!("Received a verification state update: {state:?}");
Diff in /app/src/verification.rs:41:
                 .await
             {
                 Handle::current().spawn(request_verification_handler(client, request));
[31m-            }
[m[31m-            else {
[m[32m+            } else {
[m                 // warning!("Skipping invalid verification request from {}, transaction ID: {}\n   Content: {:?}",
                 //     ev.sender, ev.content.transaction_id, ev.content,
                 // );
Diff in /app/src/verification.rs:59:
                     .await
                 {
                     Handle::current().spawn(request_verification_handler(client, request));
[31m-                }
[m[31m-                else {
[m[32m+                } else {
[m                     // warning!("Skipping invalid verification request from {}, event ID: {}\n   Content: {:?}",
                     //     ev.sender, ev.event_id, ev.content,
                     // );
Diff in /app/src/verification.rs:67:
                 }
             }
[31m-        }
[m[32m+        },
[m     );
 }

Diff in /app/src/verification.rs:73:
[31m-
[m async fn dump_devices(user_id: &UserId, client: &Client) -> String {
     let mut devices = String::new();
[31m-    for device in client.encryption().get_user_devices(user_id).await.unwrap().devices() {
[m[31m-        let current = client.device_id().is_some_and(|id| id == device.device_id());
[m[32m+    for device in client
[m[32m+        .encryption()
[m[32m+        .get_user_devices(user_id)
[m[32m+        .await
[m[32m+        .unwrap()
[m[32m+        .devices()
[m[32m+    {
[m[32m+        let current = client
[m[32m+            .device_id()
[m[32m+            .is_some_and(|id| id == device.device_id());
[m         devices.push_str(&format!(
             "    {:<10} {:<30} {:<}{}\n",
             device.device_id(),
Diff in /app/src/verification.rs:83:
             if current { " <-- this device" } else { "" },
         ));
     }
[31m-    format!("Currently-known devices of user {user_id}:\n{}",
[m[31m-        if devices.is_empty() { "    (none)" } else { &devices },
[m[32m+    format!(
[m[32m+        "Currently-known devices of user {user_id}:\n{}",
[m[32m+        if devices.is_empty() {
[m[32m+            "    (none)"
[m[32m+        } else {
[m[32m+            &devices
[m[32m+        },
[m     )
 }

Diff in /app/src/verification.rs:91:
[31m-
[m async fn sas_verification_handler(
     client: Client,
     sas: SasVerification,
Diff in /app/src/verification.rs:99:
         &sas.other_device().user_id(),
         &sas.other_device().device_id()
     );
[31m-    log!("[Pre-verification] {}", dump_devices(sas.other_device().user_id(), &client).await);
[m[32m+    log!(
[m[32m+        "[Pre-verification] {}",
[m[32m+        dump_devices(sas.other_device().user_id(), &client).await
[m[32m+    );
[m
     let mut stream = sas.changes();
     // Accept the SAS verification with both default methods: emoji and decimal.
Diff in /app/src/verification.rs:113:
     let mut receiver_opt = Some(response_receiver);
     while let Some(state) = stream.next().await {
         match state {
[31m-            SasState::Created { .. }
[m[31m-            | SasState::Started { .. } => { } // we've already passed these states
[m[32m+            SasState::Created { .. } | SasState::Started { .. } => {} // we've already passed these states
[m
[31m-            SasState::Accepted { accepted_protocols } => Cx::post_action(
[m[31m-                VerificationAction::SasAccepted(accepted_protocols)
[m[31m-            ),
[m[32m+            SasState::Accepted { accepted_protocols } => {
[m[32m+                Cx::post_action(VerificationAction::SasAccepted(accepted_protocols))
[m[32m+            }
[m
             SasState::KeysExchanged { emojis, decimals } => {
                 Cx::post_action(VerificationAction::KeysExchanged { emojis, decimals });
Diff in /app/src/verification.rs:131:
                                 log!("User confirmed SAS verification keys");
                                 if let Err(e) = sas2.confirm().await {
                                     log!("Failed to confirm SAS verification keys; error: {:?}", e);
[31m-                                    Cx::post_action(VerificationAction::SasConfirmationError(Arc::new(e)));
[m[32m+                                    Cx::post_action(VerificationAction::SasConfirmationError(
[m[32m+                                        Arc::new(e),
[m[32m+                                    ));
[m                                 }
                                 // If successful, SAS verification will now transition to the Confirmed state,
                                 // which will be sent to the main UI thread in the `SasState::Confirmed` match arm below.
Diff in /app/src/verification.rs:147:
                     // confirmed their keys match the ones we have *before* we confirmed them.
                     log!("The other side confirmed that the displayed keys matched.");
                 };
[31m-
[m             }

             SasState::Confirmed => Cx::post_action(VerificationAction::SasConfirmed),
Diff in /app/src/verification.rs:154:

[31m-            SasState::Done { verified_devices, verified_identities } => {
[m[32m+            SasState::Done {
[m[32m+                verified_devices,
[m[32m+                verified_identities,
[m[32m+            } => {
[m                 let device = sas.other_device();
[31m-                log!("SAS verification done.
[m[32m+                log!(
[m[32m+                    "SAS verification done.
[m                     Devices: {verified_devices:?}
                     Identities: {verified_identities:?}",
                 );
Diff in /app/src/verification.rs:164:
                     device.device_id(),
                     device.local_trust_state()
                 );
[31m-                log!("[Post-verification] {}", dump_devices(sas.other_device().user_id(), &client).await);
[m[32m+                log!(
[m[32m+                    "[Post-verification] {}",
[m[32m+                    dump_devices(sas.other_device().user_id(), &client).await
[m[32m+                );
[m                 // We go ahead and send the RequestCompleted action here,
                 // because it is not guaranteed that the VerificationRequestState stream loop
                 // will receive an update an enter the `Done` state.
Diff in /app/src/verification.rs:172:
                 break;
             }
             SasState::Cancelled(cancel_info) => {
[31m-                log!("SAS verification has been cancelled, reason: {}", cancel_info.reason());
[m[32m+                log!(
[m[32m+                    "SAS verification has been cancelled, reason: {}",
[m[32m+                    cancel_info.reason()
[m[32m+                );
[m                 // We go ahead and send the RequestCancelled action here,
                 // because it is not guaranteed that the VerificationRequestState stream loop
                 // will receive an update an enter the `Cancelled` state.
Diff in /app/src/verification.rs:184:
 }

 async fn request_verification_handler(client: Client, request: VerificationRequest) {
[31m-    log!("Received a verification request in room {:?}: {:?}", request.room_id(), request.state());
[m[31m-    let (sender, mut response_receiver) = tokio::sync::mpsc::unbounded_channel::<VerificationUserResponse>();
[m[31m-    Cx::post_action(
[m[31m-        VerificationAction::RequestReceived(
[m[31m-            VerificationRequestActionState {
[m[31m-                request: request.clone(),
[m[31m-                response_sender: sender.clone(),
[m[31m-            }
[m[31m-        )
[m[32m+    log!(
[m[32m+        "Received a verification request in room {:?}: {:?}",
[m[32m+        request.room_id(),
[m[32m+        request.state()
[m     );
[32m+    let (sender, mut response_receiver) =
[m[32m+        tokio::sync::mpsc::unbounded_channel::<VerificationUserResponse>();
[m[32m+    Cx::post_action(VerificationAction::RequestReceived(
[m[32m+        VerificationRequestActionState {
[m[32m+            request: request.clone(),
[m[32m+            response_sender: sender.clone(),
[m[32m+        },
[m[32m+    ));
[m
     let mut stream = request.changes();

Diff in /app/src/verification.rs:200:
     // We currently only support SAS verification.
     let supported_methods = vec![VerificationMethod::SasV1];
     match response_receiver.recv().await {
[31m-        Some(VerificationUserResponse::Accept) => match request.accept_with_methods(supported_methods).await {
[m[31m-            Ok(()) => {
[m[31m-                Cx::post_action(VerificationAction::RequestAccepted);
[m[31m-                // Fall through to the stream loop below.
[m[32m+        Some(VerificationUserResponse::Accept) => {
[m[32m+            match request.accept_with_methods(supported_methods).await {
[m[32m+                Ok(()) => {
[m[32m+                    Cx::post_action(VerificationAction::RequestAccepted);
[m[32m+                    // Fall through to the stream loop below.
[m[32m+                }
[m[32m+                Err(e) => {
[m[32m+                    Cx::post_action(VerificationAction::RequestAcceptError(Arc::new(e)));
[m[32m+                    return;
[m[32m+                }
[m             }
[31m-            Err(e) => {
[m[31m-                Cx::post_action(VerificationAction::RequestAcceptError(Arc::new(e)));
[m[31m-                return;
[m[31m-            }
[m         }
         Some(VerificationUserResponse::Cancel) | None => match request.cancel().await {
[31m-            Ok(()) => { } // response will be sent in the stream loop below
[m[32m+            Ok(()) => {} // response will be sent in the stream loop below
[m             Err(e) => {
                 Cx::post_action(VerificationAction::RequestCancelError(Arc::new(e)));
                 return;
Diff in /app/src/verification.rs:218:
             }
[31m-        }
[m[32m+        },
[m     };

     while let Some(state) = stream.next().await {
Diff in /app/src/verification.rs:223:
         match state {
             VerificationRequestState::Created { .. }
             | VerificationRequestState::Requested { .. }
[31m-            | VerificationRequestState::Ready { .. } => { }
[m[32m+            | VerificationRequestState::Ready { .. } => {}
[m             VerificationRequestState::Transitioned { verification } => match verification {
                 // We only support SAS verification.
                 Verification::SasV1(sas) => {
Diff in /app/src/verification.rs:230:
                     log!("Verification request transitioned to SAS V1.");
[31m-                    Handle::current().spawn(sas_verification_handler(client, sas, response_receiver));
[m[32m+                    Handle::current().spawn(sas_verification_handler(
[m[32m+                        client,
[m[32m+                        sas,
[m[32m+                        response_receiver,
[m[32m+                    ));
[m                     return;
                 }
                 unsupported => {
Diff in /app/src/verification.rs:235:
[31m-                    log!("Verification request transitioned to unsupported method: {:?}", unsupported);
[m[31m-                    Cx::post_action(VerificationAction::RequestTransitionedToUnsupportedMethod(unsupported));
[m[32m+                    log!(
[m[32m+                        "Verification request transitioned to unsupported method: {:?}",
[m[32m+                        unsupported
[m[32m+                    );
[m[32m+                    Cx::post_action(VerificationAction::RequestTransitionedToUnsupportedMethod(
[m[32m+                        unsupported,
[m[32m+                    ));
[m                     return;
                 }
[31m-            }
[m[32m+            },
[m             VerificationRequestState::Cancelled(info) => {
[31m-                log!("Verification request was cancelled, reason: {}", info.reason());
[m[32m+                log!(
[m[32m+                    "Verification request was cancelled, reason: {}",
[m[32m+                    info.reason()
[m[32m+                );
[m                 Cx::post_action(VerificationAction::RequestCancelled(info));
             }
             VerificationRequestState::Done => {
Diff in /app/src/verification.rs:249:
         }
     }
 }
[31m-
[m
 /// Actions related to verification that should be handled by the top-level app context.
 #[derive(Clone, Debug, DefaultNone)]
Diff in /app/src/verification_modal.rs:3:
 use makepad_widgets::*;
 use matrix_sdk::encryption::verification::Verification;

[31m-use crate::verification::{VerificationAction, VerificationRequestActionState, VerificationUserResponse};
[m[32m+use crate::verification::{
[m[32m+    VerificationAction, VerificationRequestActionState, VerificationUserResponse,
[m[32m+};
[m
 live_design! {
     use link::theme::*;
Diff in /app/src/verification_modal.rs:76:
                             color: (COLOR_FG_DANGER_RED),
                         }
                         icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                         draw_bg: {
                             border_color: (COLOR_FG_DANGER_RED),
                             color: (COLOR_BG_DANGER_RED)
Diff in /app/src/verification_modal.rs:95:
                             color: (COLOR_FG_ACCEPT_GREEN),
                         }
                         icon_walk: {width: 16, height: 16, margin: {left: -2, right: -1} }
[31m-
[m[32m+
[m                         draw_bg: {
                             border_color: (COLOR_FG_ACCEPT_GREEN),
                             color: (COLOR_BG_ACCEPT_GREEN)
Diff in /app/src/verification_modal.rs:113:

 #[derive(Live, LiveHook, Widget)]
 pub struct VerificationModal {
[31m-    #[deref] view: View,
[m[31m-    #[rust] state: Option<VerificationRequestActionState>,
[m[32m+    #[deref]
[m[32m+    view: View,
[m[32m+    #[rust]
[m[32m+    state: Option<VerificationRequestActionState>,
[m     /// Whether the modal is in a "final" state,
     /// meaning that the verification process has ended
     /// and that any further interaction with it should close the modal.
Diff in /app/src/verification_modal.rs:121:
[31m-    #[rust(false)] is_final: bool,
[m[32m+    #[rust(false)]
[m[32m+    is_final: bool,
[m }

 /// Actions emitted by the `VerificationModal`.
Diff in /app/src/verification_modal.rs:182:
                     VerificationAction::RequestCancelled(cancel_info) => {
                         self.label(ids!(prompt)).set_text(
                             cx,
[31m-                            &format!("Verification request was cancelled: {}", cancel_info.reason())
[m[32m+                            &format!(
[m[32m+                                "Verification request was cancelled: {}",
[m[32m+                                cancel_info.reason()
[m[32m+                            ),
[m                         );
                         accept_button.set_enabled(cx, true);
                         accept_button.set_text(cx, "Ok");
Diff in /app/src/verification_modal.rs:194:
                         self.label(ids!(prompt)).set_text(
                             cx,
                             "You successfully accepted the verification request.\n\n\
[31m-                            Waiting for the other device to agree on verification methods..."
[m[32m+                            Waiting for the other device to agree on verification methods...",
[m                         );
                         accept_button.set_enabled(cx, false);
                         accept_button.set_text(cx, "Waiting...");
Diff in /app/src/verification_modal.rs:204:
                     }

                     VerificationAction::RequestAcceptError(error) => {
[31m-                        self.label(ids!(prompt)).set_text(cx,
[m[32m+                        self.label(ids!(prompt)).set_text(
[m[32m+                            cx,
[m                             &format!(
                                 "Error accepting verification request: {}\n\n\
                                 Please try the verification process again.",
Diff in /app/src/verification_modal.rs:220:
                     VerificationAction::RequestCancelError(error) => {
                         self.label(ids!(prompt)).set_text(
                             cx,
[31m-                            &format!("Error cancelling verification request: {}.", error)
[m[32m+                            &format!("Error cancelling verification request: {}.", error),
[m                         );
                         accept_button.set_enabled(cx, true);
                         accept_button.set_text(cx, "Ok");
Diff in /app/src/verification_modal.rs:250:
                         self.label(ids!(prompt)).set_text(
                             cx,
                             "Both sides have accepted the same verification method(s).\n\n\
[31m-                            Waiting for both devices to exchange keys..."
[m[32m+                            Waiting for both devices to exchange keys...",
[m                         );
                         accept_button.set_enabled(cx, false);
                         accept_button.set_text(cx, "Waiting...");
Diff in /app/src/verification_modal.rs:265:
                                 "Keys have been exchanged. Please verify the following emoji:\
                                 \n   {}\n\n\
                                 Do these emoji keys match?",
[31m-                                emoji_list.emojis
[m[32m+                                emoji_list
[m[32m+                                    .emojis
[m                                     .iter()
                                     .map(|em| format!("{}  ({})", em.symbol, em.description))
                                     .collect::<Vec<_>>()
Diff in /app/src/verification_modal.rs:291:
                         self.label(ids!(prompt)).set_text(
                             cx,
                             "You successfully confirmed the Short Auth String keys.\n\n\
[31m-                            Waiting for the other device to confirm..."
[m[32m+                            Waiting for the other device to confirm...",
[m                         );
                         accept_button.set_enabled(cx, false);
                         accept_button.set_text(cx, "Waiting...");
Diff in /app/src/verification_modal.rs:312:
                     }

                     VerificationAction::RequestCompleted => {
[31m-                        self.label(ids!(prompt)).set_text(cx, "Verification completed successfully!");
[m[32m+                        self.label(ids!(prompt))
[m[32m+                            .set_text(cx, "Verification completed successfully!");
[m                         accept_button.set_text(cx, "Ok");
                         accept_button.set_enabled(cx, true);
                         cancel_button.set_visible(cx, false);
Diff in /app/src/verification_modal.rs:319:
                         self.is_final = true;
                     }
[31m-                    _ => { }
[m[32m+                    _ => {}
[m                 }
                 // If we received a `VerificationAction`, we need to redraw the modal content.
                 needs_redraw = true;
Diff in /app/src/verification_modal.rs:337:
         self.is_final = false;
     }

[31m-    fn initialize_with_data(
[m[31m-        &mut self,
[m[31m-        cx: &mut Cx,
[m[31m-        state: VerificationRequestActionState,
[m[31m-    ) {
[m[32m+    fn initialize_with_data(&mut self, cx: &mut Cx, state: VerificationRequestActionState) {
[m         log!("Initializing verification modal with state: {:?}", state);
         let request = &state.request;
         let prompt_text = if request.is_self_verification() {
Diff in /app/src/verification_modal.rs:348:
             Cow::from("Do you wish to verify your own device?")
         } else {
             if let Some(room_id) = request.room_id() {
[31m-                format!("Do you wish to verify user {} in room {}?",
[m[32m+                format!(
[m[32m+                    "Do you wish to verify user {} in room {}?",
[m                     request.other_user_id(),
                     room_id,
[31m-                ).into()
[m[32m+                )
[m[32m+                .into()
[m             } else {
[31m-                format!("Do you wish to verify user {}?",
[m[31m-                    request.other_user_id()
[m[31m-                ).into()
[m[32m+                format!("Do you wish to verify user {}?", request.other_user_id()).into()
[m             }
         };
         self.label(ids!(prompt)).set_text(cx, &prompt_text);
Diff in /app/src/verification_modal.rs:375:
 }

 impl VerificationModalRef {
[31m-    pub fn initialize_with_data(
[m[31m-        &self,
[m[31m-        cx: &mut Cx,
[m[31m-        state: VerificationRequestActionState,
[m[31m-    ) {
[m[32m+    pub fn initialize_with_data(&self, cx: &mut Cx, state: VerificationRequestActionState) {
[m         if let Some(mut inner) = self.borrow_mut() {
             inner.initialize_with_data(cx, state);
         }
Warning: can't set `hex_literal_case = Upper`, unstable features are only available in nightly channel.
Warning: can't set `fn_single_line = true`, unstable features are only available in nightly channel.
Warning: can't set `imports_granularity = Crate`, unstable features are only available in nightly channel.
Warning: can't set `group_imports = StdExternalCrate`, unstable features are only available in nightly channel.
Warning: can't set `reorder_impl_items = false`, unstable features are only available in nightly channel.
Warning: can't set `spaces_around_ranges = true`, unstable features are only available in nightly channel.
Warning: can't set `blank_lines_upper_bound = 3`, unstable features are only available in nightly channel.
Warning: can't set `inline_attribute_width = 50`, unstable features are only available in nightly channel.
Warning: can't set `format_generated_files = false`, unstable features are only available in nightly channel.
Warning: can't set `error_on_line_overflow = false`, unstable features are only available in nightly channel.
Diff in /app/src/main.rs:4:

 // This cfg option hides the command prompt console window on Windows.
 // TODO: move this into Makepad itself as an addition to the `MAKEPAD` env var.
[31m-#![cfg_attr(all(feature = "hide_windows_console", target_os = "windows"), windows_subsystem = "windows")]
[m[32m+#![cfg_attr(
[m[32m+    all(feature = "hide_windows_console", target_os = "windows"),
[m[32m+    windows_subsystem = "windows"
[m[32m+)]
[m
 fn main() {
     robrix::app::app_main()
Warning: can't set `hex_literal_case = Upper`, unstable features are only available in nightly channel.
Warning: can't set `fn_single_line = true`, unstable features are only available in nightly channel.
Warning: can't set `imports_granularity = Crate`, unstable features are only available in nightly channel.
Warning: can't set `group_imports = StdExternalCrate`, unstable features are only available in nightly channel.
Warning: can't set `reorder_impl_items = false`, unstable features are only available in nightly channel.
Warning: can't set `spaces_around_ranges = true`, unstable features are only available in nightly channel.
Warning: can't set `blank_lines_upper_bound = 3`, unstable features are only available in nightly channel.
Warning: can't set `inline_attribute_width = 50`, unstable features are only available in nightly channel.
Warning: can't set `format_generated_files = false`, unstable features are only available in nightly channel.
Warning: can't set `error_on_line_overflow = false`, unstable features are only available in nightly channel.
Diff in /app/src/sliding_sync.rs:8:
 use makepad_widgets::{error, log, warning, Cx, SignalToUI};
 use matrix_sdk_base::crypto::{DecryptionSettings, TrustRequirement};
 use matrix_sdk::{
[31m-    config::RequestConfig, encryption::EncryptionSettings, event_handler::EventHandlerDropGuard, media::MediaRequestParameters, room::{edit::EditedContent, reply::Reply, RoomMember}, ruma::{
[m[31m-        api::client::{profile::{AvatarUrl, DisplayName}, receipt::create_receipt::v3::ReceiptType}, events::{
[m[31m-            room::{
[m[31m-                message::RoomMessageEventContent, power_levels::RoomPowerLevels, MediaSource
[m[31m-            }, MessageLikeEventType, StateEventType
[m[31m-        }, matrix_uri::MatrixId, MatrixToUri, MatrixUri, MilliSecondsSinceUnixEpoch, OwnedEventId, OwnedMxcUri, OwnedRoomAliasId, OwnedRoomId, OwnedUserId, RoomOrAliasId, UserId
[m[31m-    }, sliding_sync::VersionBuilder, Client, ClientBuildError, Error, OwnedServerName, Room, RoomDisplayName, RoomMemberships, RoomState, SuccessorRoom
[m[32m+    config::RequestConfig,
[m[32m+    encryption::EncryptionSettings,
[m[32m+    event_handler::EventHandlerDropGuard,
[m[32m+    media::MediaRequestParameters,
[m[32m+    room::{edit::EditedContent, reply::Reply, RoomMember},
[m[32m+    ruma::{
[m[32m+        api::client::{
[m[32m+            profile::{AvatarUrl, DisplayName},
[m[32m+            receipt::create_receipt::v3::ReceiptType,
[m[32m+        },
[m[32m+        events::{
[m[32m+            room::{message::RoomMessageEventContent, power_levels::RoomPowerLevels, MediaSource},
[m[32m+            MessageLikeEventType, StateEventType,
[m[32m+        },
[m[32m+        matrix_uri::MatrixId,
[m[32m+        MatrixToUri, MatrixUri, MilliSecondsSinceUnixEpoch, OwnedEventId, OwnedMxcUri,
[m[32m+        OwnedRoomAliasId, OwnedRoomId, OwnedUserId, RoomOrAliasId, UserId,
[m[32m+    },
[m[32m+    sliding_sync::VersionBuilder,
[m[32m+    Client, ClientBuildError, Error, OwnedServerName, Room, RoomDisplayName, RoomMemberships,
[m[32m+    RoomState, SuccessorRoom,
[m };
 use matrix_sdk_ui::{
[31m-    RoomListService, Timeline, room_list_service::{RoomListItem, RoomListLoadingState, SyncIndicator, filters}, sync_service::{self, SyncService}, timeline::{LatestEventValue, RoomExt, TimelineEventItemId, TimelineItem, TimelineReadReceiptTracking, TimelineDetails}
[m[32m+    RoomListService, Timeline,
[m[32m+    room_list_service::{RoomListItem, RoomListLoadingState, SyncIndicator, filters},
[m[32m+    sync_service::{self, SyncService},
[m[32m+    timeline::{
[m[32m+        LatestEventValue, RoomExt, TimelineEventItemId, TimelineItem, TimelineReadReceiptTracking,
[m[32m+        TimelineDetails,
[m[32m+    },
[m };
 use robius_open::Uri;
 use ruma::{OwnedRoomOrAliasId, events::tag::Tags};
Diff in /app/src/sliding_sync.rs:24:
 use tokio::{
     runtime::Handle,
[31m-    sync::{mpsc::{Sender, UnboundedReceiver, UnboundedSender}, watch, Notify}, task::JoinHandle, time::error::Elapsed,
[m[32m+    sync::{
[m[32m+        mpsc::{Sender, UnboundedReceiver, UnboundedSender},
[m[32m+        watch, Notify,
[m[32m+    },
[m[32m+    task::JoinHandle,
[m[32m+    time::error::Elapsed,
[m };
 use url::Url;
[31m-use std::{cmp::{max, min}, future::Future, hash::{BuildHasherDefault, DefaultHasher}, iter::Peekable, ops::{Deref, Not}, path:: Path, sync::{Arc, LazyLock, Mutex}, time::Duration};
[m[32m+use std::{
[m[32m+    cmp::{max, min},
[m[32m+    future::Future,
[m[32m+    hash::{BuildHasherDefault, DefaultHasher},
[m[32m+    iter::Peekable,
[m[32m+    ops::{Deref, Not},
[m[32m+    path::Path,
[m[32m+    sync::{Arc, LazyLock, Mutex},
[m[32m+    time::Duration,
[m[32m+};
[m use std::io;
 use hashbrown::{HashMap, HashSet};
 use crate::{
Diff in /app/src/sliding_sync.rs:33:
[31m-    app::AppStateAction, app_data_dir, avatar_cache::AvatarUpdate, event_preview::text_preview_of_timeline_item, home::{
[m[31m-        add_room::KnockResultAction, invite_screen::{JoinRoomResultAction, LeaveRoomResultAction}, link_preview::{LinkPreviewData, LinkPreviewDataNonNumeric, LinkPreviewRateLimitResponse}, room_screen::{InviteResultAction, TimelineUpdate}, rooms_list::{self, InvitedRoomInfo, InviterInfo, JoinedRoomInfo, RoomsListUpdate, enqueue_rooms_list_update}, rooms_list_header::RoomsListHeaderAction, tombstone_footer::SuccessorRoomDetails
[m[31m-    }, login::login_screen::LoginAction, logout::{logout_confirm_modal::LogoutAction, logout_state_machine::{LogoutConfig, is_logout_in_progress, logout_with_state_machine}}, media_cache::{MediaCacheEntry, MediaCacheEntryRef}, persistence::{self, ClientSessionPersisted, load_app_state}, profile::{
[m[32m+    app::AppStateAction,
[m[32m+    app_data_dir,
[m[32m+    avatar_cache::AvatarUpdate,
[m[32m+    event_preview::text_preview_of_timeline_item,
[m[32m+    home::{
[m[32m+        add_room::KnockResultAction,
[m[32m+        invite_screen::{JoinRoomResultAction, LeaveRoomResultAction},
[m[32m+        link_preview::{LinkPreviewData, LinkPreviewDataNonNumeric, LinkPreviewRateLimitResponse},
[m[32m+        room_screen::{InviteResultAction, TimelineUpdate},
[m[32m+        rooms_list::{
[m[32m+            self, InvitedRoomInfo, InviterInfo, JoinedRoomInfo, RoomsListUpdate,
[m[32m+            enqueue_rooms_list_update,
[m[32m+        },
[m[32m+        rooms_list_header::RoomsListHeaderAction,
[m[32m+        tombstone_footer::SuccessorRoomDetails,
[m[32m+    },
[m[32m+    login::login_screen::LoginAction,
[m[32m+    logout::{
[m[32m+        logout_confirm_modal::LogoutAction,
[m[32m+        logout_state_machine::{LogoutConfig, is_logout_in_progress, logout_with_state_machine},
[m[32m+    },
[m[32m+    media_cache::{MediaCacheEntry, MediaCacheEntryRef},
[m[32m+    persistence::{self, ClientSessionPersisted, load_app_state},
[m[32m+    profile::{
[m         user_profile::UserProfile,
         user_profile_cache::{UserProfileUpdate, enqueue_user_profile_update},
[31m-    }, room::{FetchedRoomAvatar, FetchedRoomPreview, RoomPreviewAction}, shared::{
[m[31m-        avatar::AvatarState, html_or_plaintext::MatrixLinkPillState, jump_to_bottom_button::UnreadMessageCount, popup_list::{PopupKind, enqueue_popup_notification}
[m[31m-    }, space_service_sync::space_service_loop, utils::{self, AVATAR_THUMBNAIL_FORMAT, RoomNameId, avatar_from_room_name, VecDiff}, verification::add_verification_event_handlers_and_sync_client
[m[32m+    },
[m[32m+    room::{FetchedRoomAvatar, FetchedRoomPreview, RoomPreviewAction},
[m[32m+    shared::{
[m[32m+        avatar::AvatarState,
[m[32m+        html_or_plaintext::MatrixLinkPillState,
[m[32m+        jump_to_bottom_button::UnreadMessageCount,
[m[32m+        popup_list::{PopupKind, enqueue_popup_notification},
[m[32m+    },
[m[32m+    space_service_sync::space_service_loop,
[m[32m+    utils::{self, AVATAR_THUMBNAIL_FORMAT, RoomNameId, avatar_from_room_name, VecDiff},
[m[32m+    verification::add_verification_event_handlers_and_sync_client,
[m };

 #[derive(Parser, Debug, Default)]
Diff in /app/src/sliding_sync.rs:79:
     }
 }

[31m-
[m /// Build a new client.
 async fn build_client(
     cli: &Cli,
Diff in /app/src/sliding_sync.rs:101:
             .collect()
     };

[31m-    let homeserver_url = cli.homeserver.as_deref()
[m[32m+    let homeserver_url = cli
[m[32m+        .homeserver
[m[32m+        .as_deref()
[m         .unwrap_or("https://matrix-client.matrix.org/");
[31m-        // .unwrap_or("https://matrix.org/");
[m[32m+    // .unwrap_or("https://matrix.org/");
[m
     let mut builder = Client::builder()
         .server_name_or_homeserver_url(homeserver_url)
Diff in /app/src/sliding_sync.rs:128:

     // Use a 60 second timeout for all requests to the homeserver.
     // Yes, this is a long timeout, but the standard matrix homeserver is often very slow.
[31m-    builder = builder.request_config(
[m[31m-        RequestConfig::new()
[m[31m-            .timeout(std::time::Duration::from_secs(60))
[m[31m-    );
[m[32m+    builder =
[m[32m+        builder.request_config(RequestConfig::new().timeout(std::time::Duration::from_secs(60)));
[m
     let client = builder.build().await?;
[31m-    let homeserver_url =  client.homeserver().to_string();
[m[32m+    let homeserver_url = client.homeserver().to_string();
[m     Ok((
         client,
         ClientSessionPersisted {
Diff in /app/src/sliding_sync.rs:150:
 /// This function is used by the login screen to log in to the Matrix server.
 ///
 /// Upon success, this function returns the logged-in client and an optional sync token.
[31m-async fn login(
[m[31m-    cli: &Cli,
[m[31m-    login_request: LoginRequest,
[m[31m-) -> Result<(Client, Option<String>)> {
[m[32m+async fn login(cli: &Cli, login_request: LoginRequest) -> Result<(Client, Option<String>)> {
[m     match login_request {
         LoginRequest::LoginByCli | LoginRequest::LoginByPassword(_) => {
             let cli = if let LoginRequest::LoginByPassword(login_by_password) = login_request {
Diff in /app/src/sliding_sync.rs:183:
             } else {
                 let err_msg = format!("Failed to login as {}: {:?}", cli.user_id, login_result);
                 enqueue_popup_notification(err_msg.clone(), PopupKind::Error, None);
[31m-                enqueue_rooms_list_update(RoomsListUpdate::Status { status: err_msg.clone() });
[m[32m+                enqueue_rooms_list_update(RoomsListUpdate::Status {
[m[32m+                    status: err_msg.clone(),
[m[32m+                });
[m                 bail!(err_msg);
             }
         }
Diff in /app/src/sliding_sync.rs:200:
     }
 }

[31m-
[m /// Which direction to paginate in.
 ///
 /// * `Forwards` will retrieve later events (towards the end of the timeline),
Diff in /app/src/sliding_sync.rs:269:
     Option<crossbeam_channel::Sender<TimelineUpdate>>,
 );

[31m-
[m /// Actions emitted in response to a [`MatrixRequest::GenerateMatrixLink`].
 #[derive(Clone, Debug)]
 pub enum MatrixLinkAction {
Diff in /app/src/sliding_sync.rs:300:
         room_name_id: RoomNameId,
     },
     /// A direct message room didn't exist, and we didn't attempt to create a new one.
[31m-    DidNotExist {
[m[31m-        user_profile: UserProfile,
[m[31m-    },
[m[32m+    DidNotExist { user_profile: UserProfile },
[m     /// A direct message room didn't exist, but we successfully created a new one.
     NewlyCreated {
         user_profile: UserProfile,
Diff in /app/src/sliding_sync.rs:321:
     /// Request from the login screen to log in with the given credentials.
     Login(LoginRequest),
     /// Request to logout.
[31m-    Logout{
[m[31m-        is_desktop: bool,
[m[31m-    },
[m[32m+    Logout { is_desktop: bool },
[m     /// Request to paginate the older (or newer) events of a room's timeline.
     PaginateRoomTimeline {
         room_id: OwnedRoomId,
Diff in /app/src/sliding_sync.rs:344:
     },
     /// Request to fetch profile information for all members of a room.
     /// This can be *very* slow depending on the number of members in the room.
[31m-    SyncRoomMemberList {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    SyncRoomMemberList { room_id: OwnedRoomId },
[m     /// Request to knock on (request an invite to) the given room.
     Knock {
         room_or_alias_id: OwnedRoomOrAliasId,
Diff in /app/src/sliding_sync.rs:360:
         user_id: OwnedUserId,
     },
     /// Request to join the given room.
[31m-    JoinRoom {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    JoinRoom { room_id: OwnedRoomId },
[m     /// Request to leave the given room.
[31m-    LeaveRoom {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    LeaveRoom { room_id: OwnedRoomId },
[m     /// Request to get the actual list of members in a room.
     /// This returns the list of members that can be displayed in the UI.
     GetRoomMembers {
Diff in /app/src/sliding_sync.rs:385:
         via: Vec<OwnedServerName>,
     },
     /// Request to fetch the full details (the room preview) of a tombstoned room.
[31m-    GetSuccessorRoomDetails {
[m[31m-        tombstoned_room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetSuccessorRoomDetails { tombstoned_room_id: OwnedRoomId },
[m     /// Request to create or open a direct message room with the given user.
     ///
     /// If there is no existing DM room with the given user, this will create a new DM room
Diff in /app/src/sliding_sync.rs:412:
         local_only: bool,
     },
     /// Request to fetch the number of unread messages in the given room.
[31m-    GetNumberUnreadMessages {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetNumberUnreadMessages { room_id: OwnedRoomId },
[m     /// Request to set the unread flag for the given room.
     SetUnreadFlag {
         room_id: OwnedRoomId,
Diff in /app/src/sliding_sync.rs:499:
     /// This request does not return a response or notify the UI thread, and
     /// furthermore, there is no need to send a follow-up request to stop typing
     /// (though you certainly can do so).
[31m-    SendTypingNotice {
[m[31m-        room_id: OwnedRoomId,
[m[31m-        typing: bool,
[m[31m-    },
[m[32m+    SendTypingNotice { room_id: OwnedRoomId, typing: bool },
[m     /// Spawn an async task to login to the given Matrix homeserver using the given SSO identity provider ID.
     ///
     /// While an SSO request is in flight, the login screen will temporarily prevent the user
Diff in /app/src/sliding_sync.rs:509:
     /// from submitting another redundant request, until this request has succeeded or failed.
[31m-    SpawnSSOServer{
[m[32m+    SpawnSSOServer {
[m         brand: String,
         homeserver_url: String,
         identity_provider_id: String,
Diff in /app/src/sliding_sync.rs:547:
     /// Sends a request to obtain the power levels for this room.
     ///
     /// The response is delivered back to the main UI thread via [`TimelineUpdate::UserPowerLevels`].
[31m-    GetRoomPowerLevels {
[m[31m-        room_id: OwnedRoomId,
[m[31m-    },
[m[32m+    GetRoomPowerLevels { room_id: OwnedRoomId },
[m     /// Toggles the given reaction to the given event in the given room.
     ToggleReaction {
         room_id: OwnedRoomId,
Diff in /app/src/sliding_sync.rs:575:
     /// The MatrixLinkPillInfo::Loaded variant is sent back to the main UI thread via.
     GetMatrixRoomLinkPillInfo {
         matrix_id: MatrixId,
[31m-        via: Vec<OwnedServerName>
[m[32m+        via: Vec<OwnedServerName>,
[m     },
     /// Request to fetch URL preview from the Matrix homeserver.
     GetUrlPreview {
Diff in /app/src/sliding_sync.rs:589:
 /// Submits a request to the worker thread to be executed asynchronously.
 pub fn submit_async_request(req: MatrixRequest) {
     if let Some(sender) = REQUEST_SENDER.lock().unwrap().as_ref() {
[31m-        sender.send(req)
[m[32m+        sender
[m[32m+            .send(req)
[m             .expect("BUG: matrix worker task receiver has died!");
     }
 }
Diff in /app/src/sliding_sync.rs:596:

 /// Details of a login request that get submitted within [`MatrixRequest::Login`].
[31m-pub enum LoginRequest{
[m[32m+pub enum LoginRequest {
[m     LoginByPassword(LoginByPassword),
     LoginBySSOSuccess(Client, ClientSessionPersisted),
     LoginByCli,
Diff in /app/src/sliding_sync.rs:602:
     HomeserverLoginTypesQuery(String),
[31m-
[m }
 /// Information needed to log in to a Matrix homeserver.
 pub struct LoginByPassword {
Diff in /app/src/sliding_sync.rs:609:
     pub homeserver: Option<String>,
 }

[31m-
[m /// The entry point for the worker task that runs Matrix-related operations.
 ///
 /// All this task does is wait for [`MatrixRequests`] from the main UI thread
Diff in /app/src/sliding_sync.rs:619:
     login_sender: Sender<LoginRequest>,
 ) -> Result<()> {
     log!("Started matrix_worker_task.");
[31m-    let mut subscribers_own_user_read_receipts: HashMap<OwnedRoomId, JoinHandle<()>> = HashMap::new();
[m[32m+    let mut subscribers_own_user_read_receipts: HashMap<OwnedRoomId, JoinHandle<()>> =
[m[32m+        HashMap::new();
[m     let mut subscribers_pinned_events: HashMap<OwnedRoomId, JoinHandle<()>> = HashMap::new();

     while let Some(request) = request_receiver.recv().await {
Diff in /app/src/sliding_sync.rs:628:
                 if let Err(e) = login_sender.send(login_request).await {
                     error!("Error sending login request to login_sender: {e:?}");
                     Cx::post_action(LoginAction::LoginFailure(String::from(
[31m-                        "BUG: failed to send login request to login worker task."
[m[32m+                        "BUG: failed to send login request to login worker task.",
[m                     )));
                 }
             }
Diff in /app/src/sliding_sync.rs:641:
                     match logout_with_state_machine(is_desktop).await {
                         Ok(()) => {
                             log!("Logout completed successfully via state machine");
[31m-                        },
[m[32m+                        }
[m                         Err(e) => {
                             error!("Logout failed: {e:?}");
                         }
Diff in /app/src/sliding_sync.rs:649:
                 });
             }

[31m-            MatrixRequest::PaginateRoomTimeline { room_id, num_events, direction } => {
[m[32m+            MatrixRequest::PaginateRoomTimeline {
[m[32m+                room_id,
[m[32m+                num_events,
[m[32m+                direction,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:698:
                 });
             }

[31m-            MatrixRequest::EditMessage { room_id, timeline_event_item_id: timeline_event_id, edited_content } => {
[m[32m+            MatrixRequest::EditMessage {
[m[32m+                room_id,
[m[32m+                timeline_event_item_id: timeline_event_id,
[m[32m+                edited_content,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:705:
                         error!("BUG: room info not found for edit request, room {room_id}");
                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 // Spawn a new async task that will make the actual edit request.
Diff in /app/src/sliding_sync.rs:712:
                 let _edit_task = Handle::current().spawn(async move {
[31m-                    log!("Sending request to edit message {timeline_event_id:?} in room {room_id}...");
[m[32m+                    log!(
[m[32m+                        "Sending request to edit message {timeline_event_id:?} in room {room_id}..."
[m[32m+                    );
[m                     let result = timeline.edit(&timeline_event_id, edited_content).await;
                     match result {
[31m-                        Ok(_) => log!("Successfully edited message {timeline_event_id:?} in room {room_id}."),
[m[31m-                        Err(ref e) => error!("Error editing message {timeline_event_id:?} in room {room_id}: {e:?}"),
[m[32m+                        Ok(_) => log!(
[m[32m+                            "Successfully edited message {timeline_event_id:?} in room {room_id}."
[m[32m+                        ),
[m[32m+                        Err(ref e) => error!(
[m[32m+                            "Error editing message {timeline_event_id:?} in room {room_id}: {e:?}"
[m[32m+                        ),
[m                     }
[31m-                    sender.send(TimelineUpdate::MessageEdited {
[m[31m-                        timeline_event_id,
[m[31m-                        result,
[m[31m-                    }).unwrap();
[m[32m+                    sender
[m[32m+                        .send(TimelineUpdate::MessageEdited {
[m[32m+                            timeline_event_id,
[m[32m+                            result,
[m[32m+                        })
[m[32m+                        .unwrap();
[m                     SignalToUI::set_ui_signal();
                 });
             }
Diff in /app/src/sliding_sync.rs:728:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        error!("BUG: room info not found for fetch details for event request {room_id}");
[m[32m+                        error!(
[m[32m+                            "BUG: room info not found for fetch details for event request {room_id}"
[m[32m+                        );
[m                         continue;
                     };

Diff in /app/src/sliding_sync.rs:735:
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 // Spawn a new async task that will make the actual fetch request.
Diff in /app/src/sliding_sync.rs:747:
                             // error!("Error fetching details for event {event_id} in room {room_id}: {_e:?}");
                         }
                     }
[31m-                    sender.send(TimelineUpdate::EventDetailsFetched {
[m[31m-                        event_id,
[m[31m-                        result,
[m[31m-                    }).unwrap();
[m[32m+                    sender
[m[32m+                        .send(TimelineUpdate::EventDetailsFetched { event_id, result })
[m[32m+                        .unwrap();
[m                     SignalToUI::set_ui_signal();
                 });
             }
Diff in /app/src/sliding_sync.rs:763:
                         continue;
                     };

[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 // Spawn a new async task that will make the actual fetch request.
Diff in /app/src/sliding_sync.rs:776:
                 });
             }

[31m-            MatrixRequest::Knock { room_or_alias_id, reason, server_names } => {
[m[32m+            MatrixRequest::Knock {
[m[32m+                room_or_alias_id,
[m[32m+                reason,
[m[32m+                server_names,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _knock_room_task = Handle::current().spawn(async move {
                     log!("Sending request to knock on room {room_or_alias_id}...");
Diff in /app/src/sliding_sync.rs:783:
[31m-                    match client.knock(room_or_alias_id.clone(), reason, server_names).await {
[m[32m+                    match client
[m[32m+                        .knock(room_or_alias_id.clone(), reason, server_names)
[m[32m+                        .await
[m[32m+                    {
[m                         Ok(room) => {
                             let _ = room.display_name().await; // populate this room's display name cache
                             Cx::post_action(KnockResultAction::Knocked {
Diff in /app/src/sliding_sync.rs:804:
                     if let Some(room) = client.get_room(&room_id) {
                         log!("Sending request to invite user {user_id} to room {room_id}...");
                         match room.invite_user_by_id(&user_id).await {
[31m-                            Ok(_) => Cx::post_action(InviteResultAction::Sent {
[m[31m-                                room_id,
[m[31m-                                user_id,
[m[31m-                            }),
[m[32m+                            Ok(_) => Cx::post_action(InviteResultAction::Sent { room_id, user_id }),
[m                             Err(error) => Cx::post_action(InviteResultAction::Failed {
                                 room_id,
                                 user_id,
Diff in /app/src/sliding_sync.rs:814:
                                 error,
                             }),
                         }
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         error!("Room/Space not found for invite user request {room_id}, {user_id}");
                         Cx::post_action(InviteResultAction::Failed {
                             room_id,
Diff in /app/src/sliding_sync.rs:822:
                             user_id,
[31m-                            error: matrix_sdk::Error::UnknownError("Room/Space not found in client's known list.".into()),
[m[32m+                            error: matrix_sdk::Error::UnknownError(
[m[32m+                                "Room/Space not found in client's known list.".into(),
[m[32m+                            ),
[m                         })
                     }
                 });
Diff in /app/src/sliding_sync.rs:841:
                                 JoinRoomResultAction::Failed { room_id, error: e }
                             }
                         }
[31m-                    }
[m[31m-                    else {
[m[32m+                    } else {
[m                         match client.join_room_by_id(&room_id).await {
                             Ok(_room) => {
                                 log!("Successfully joined new unknown room {room_id}.");
Diff in /app/src/sliding_sync.rs:877:
                         error!("BUG: client could not get room with ID {room_id}");
                         LeaveRoomResultAction::Failed {
                             room_id,
[31m-                            error: matrix_sdk::Error::UnknownError("Client couldn't locate room to leave it.".into()),
[m[32m+                            error: matrix_sdk::Error::UnknownError(
[m[32m+                                "Client couldn't locate room to leave it.".into(),
[m[32m+                            ),
[m                         }
                     };
                     Cx::post_action(result_action);
Diff in /app/src/sliding_sync.rs:884:
                 });
             }

[31m-            MatrixRequest::GetRoomMembers { room_id, memberships, local_only } => {
[m[32m+            MatrixRequest::GetRoomMembers {
[m[32m+                room_id,
[m[32m+                memberships,
[m[32m+                local_only,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:891:
                         log!("BUG: room info not found for get room members request {room_id}");
                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 let _get_members_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:899:

                     let send_update = |members: Vec<matrix_sdk::room::RoomMember>, source: &str| {
                         log!("{} {} members for room {}", source, members.len(), room_id);
[31m-                        sender.send(TimelineUpdate::RoomMembersListFetched {
[m[31m-                            members
[m[31m-                        }).unwrap();
[m[32m+                        sender
[m[32m+                            .send(TimelineUpdate::RoomMembersListFetched { members })
[m[32m+                            .unwrap();
[m                         SignalToUI::set_ui_signal();
                     };

Diff in /app/src/sliding_sync.rs:917:
                 });
             }

[31m-            MatrixRequest::GetRoomPreview { room_or_alias_id, via } => {
[m[32m+            MatrixRequest::GetRoomPreview {
[m[32m+                room_or_alias_id,
[m[32m+                via,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _fetch_task = Handle::current().spawn(async move {
                     let res = fetch_room_preview_with_avatar(&client, &room_or_alias_id, via).await;
Diff in /app/src/sliding_sync.rs:930:
                 let (sender, successor_room) = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&tombstoned_room_id) else {
[31m-                        error!("BUG: tombstoned room {tombstoned_room_id} info not found for get successor room details request");
[m[32m+                        error!(
[m[32m+                            "BUG: tombstoned room {tombstoned_room_id} info not found for get successor room details request"
[m[32m+                        );
[m                         continue;
                     };
[31m-                    (room_info.timeline_update_sender.clone(), room_info.timeline.room().successor_room())
[m[32m+                    (
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                        room_info.timeline.room().successor_room(),
[m[32m+                    )
[m                 };
                 spawn_fetch_successor_room_preview(
                     client,
Diff in /app/src/sliding_sync.rs:943:
                 );
             }

[31m-            MatrixRequest::OpenOrCreateDirectMessage { user_profile, allow_create } => {
[m[32m+            MatrixRequest::OpenOrCreateDirectMessage {
[m[32m+                user_profile,
[m[32m+                allow_create,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _create_dm_task = Handle::current().spawn(async move {
                     if let Some(room) = client.get_dm_room(&user_profile.user_id) {
Diff in /app/src/sliding_sync.rs:966:
                                 user_profile,
                                 room_name_id: RoomNameId::from_room(&room).await,
                             });
[31m-                        },
[m[32m+                        }
[m                         Err(error) => {
                             error!("Failed to create DM with {user_profile:?}: {error}");
                             Cx::post_action(DirectMessageRoomAction::FailedToCreate {
Diff in /app/src/sliding_sync.rs:978:
                 });
             }

[31m-            MatrixRequest::GetUserProfile { user_id, room_id, local_only } => {
[m[32m+            MatrixRequest::GetUserProfile {
[m[32m+                user_id,
[m[32m+                room_id,
[m[32m+                local_only,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _fetch_task = Handle::current().spawn(async move {
                     // log!("Sending get user profile request: user: {user_id}, \
Diff in /app/src/sliding_sync.rs:1051:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("Skipping get number of unread messages request for not-yet-known room {room_id}");
[m[32m+                        log!(
[m[32m+                            "Skipping get number of unread messages request for not-yet-known room {room_id}"
[m[32m+                        );
[m                         continue;
                     };

Diff in /app/src/sliding_sync.rs:1058:
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };
                 let _get_unreads_task = Handle::current().spawn(async move {
                     match sender.send(TimelineUpdate::NewUnreadMessagesCount(
Diff in /app/src/sliding_sync.rs:1072:
                     });
                 });
             }
[31m-            MatrixRequest::SetUnreadFlag { room_id, mark_as_unread } => {
[m[32m+            MatrixRequest::SetUnreadFlag {
[m[32m+                room_id,
[m[32m+                mark_as_unread,
[m[32m+            } => {
[m                 let timeline = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:1085:
                     let result = timeline.room().set_unread_flag(mark_as_unread).await;
                     match result {
                         Ok(_) => log!("Set unread flag to {} for room {}", mark_as_unread, room_id),
[31m-                        Err(e) => error!("Failed to set unread flag to {} for room {}: {:?}", mark_as_unread, room_id, e),
[m[32m+                        Err(e) => error!(
[m[32m+                            "Failed to set unread flag to {} for room {}: {:?}",
[m[32m+                            mark_as_unread, room_id, e
[m[32m+                        ),
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1092:
[31m-            MatrixRequest::SetIsFavorite { room_id, is_favorite } => {
[m[32m+            MatrixRequest::SetIsFavorite {
[m[32m+                room_id,
[m[32m+                is_favorite,
[m[32m+            } => {
[m                 let timeline = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:1102:
                     let result = timeline.room().set_is_favourite(is_favorite, None).await;
                     match result {
                         Ok(_) => log!("Set favorite to {} for room {}", is_favorite, room_id),
[31m-                        Err(e) => error!("Failed to set favorite to {} for room {}: {:?}", is_favorite, room_id, e),
[m[32m+                        Err(e) => error!(
[m[32m+                            "Failed to set favorite to {} for room {}: {:?}",
[m[32m+                            is_favorite, room_id, e
[m[32m+                        ),
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1109:
[31m-            MatrixRequest::SetIsLowPriority { room_id, is_low_priority } => {
[m[32m+            MatrixRequest::SetIsLowPriority {
[m[32m+                room_id,
[m[32m+                is_low_priority,
[m[32m+            } => {
[m                 let timeline = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
Diff in /app/src/sliding_sync.rs:1116:
                     room_info.timeline.clone()
                 };
                 let _set_lp_task = Handle::current().spawn(async move {
[31m-                    let result = timeline.room().set_is_low_priority(is_low_priority, None).await;
[m[32m+                    let result = timeline
[m[32m+                        .room()
[m[32m+                        .set_is_low_priority(is_low_priority, None)
[m[32m+                        .await;
[m                     match result {
[31m-                        Ok(_) => log!("Set low priority to {} for room {}", is_low_priority, room_id),
[m[31m-                        Err(e) => error!("Failed to set low priority to {} for room {}: {:?}", is_low_priority, room_id, e),
[m[32m+                        Ok(_) => log!(
[m[32m+                            "Set low priority to {} for room {}",
[m[32m+                            is_low_priority,
[m[32m+                            room_id
[m[32m+                        ),
[m[32m+                        Err(e) => error!(
[m[32m+                            "Failed to set low priority to {} for room {}: {:?}",
[m[32m+                            is_low_priority, room_id, e
[m[32m+                        ),
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1127:
                 let Some(client) = get_client() else { continue };
                 let _set_avatar_task = Handle::current().spawn(async move {
                     let is_removing = avatar_url.is_none();
[31m-                    log!("Sending request to {} avatar...", if is_removing { "remove" } else { "set" });
[m[32m+                    log!(
[m[32m+                        "Sending request to {} avatar...",
[m[32m+                        if is_removing { "remove" } else { "set" }
[m[32m+                    );
[m                     let result = client.account().set_avatar_url(avatar_url.as_deref()).await;
                     match result {
                         Ok(_) => {
Diff in /app/src/sliding_sync.rs:1134:
[31m-                            log!("Successfully {} avatar.", if is_removing { "removed" } else { "set" });
[m[32m+                            log!(
[m[32m+                                "Successfully {} avatar.",
[m[32m+                                if is_removing { "removed" } else { "set" }
[m[32m+                            );
[m                             Cx::post_action(AccountDataAction::AvatarChanged(avatar_url));
                         }
                         Err(e) => {
Diff in /app/src/sliding_sync.rs:1138:
[31m-                            let err_msg = format!("Failed to {} avatar: {e}", if is_removing { "remove" } else { "set" });
[m[32m+                            let err_msg = format!(
[m[32m+                                "Failed to {} avatar: {e}",
[m[32m+                                if is_removing { "remove" } else { "set" }
[m[32m+                            );
[m                             Cx::post_action(AccountDataAction::AvatarChangeFailed(err_msg));
                         }
                     }
Diff in /app/src/sliding_sync.rs:1145:
                 let Some(client) = get_client() else { continue };
                 let _set_display_name_task = Handle::current().spawn(async move {
                     let is_removing = new_display_name.is_none();
[31m-                    log!("Sending request to {} display name{}...",
[m[32m+                    log!(
[m[32m+                        "Sending request to {} display name{}...",
[m                         if is_removing { "remove" } else { "set" },
[31m-                        new_display_name.as_ref().map(|n| format!(" to '{n}'")).unwrap_or_default()
[m[32m+                        new_display_name
[m[32m+                            .as_ref()
[m[32m+                            .map(|n| format!(" to '{n}'"))
[m[32m+                            .unwrap_or_default()
[m                     );
[31m-                    let result = client.account().set_display_name(new_display_name.as_deref()).await;
[m[32m+                    let result = client
[m[32m+                        .account()
[m[32m+                        .set_display_name(new_display_name.as_deref())
[m[32m+                        .await;
[m                     match result {
                         Ok(_) => {
[31m-                            log!("Successfully {} display name.", if is_removing { "removed" } else { "set" });
[m[31m-                            Cx::post_action(AccountDataAction::DisplayNameChanged(new_display_name));
[m[32m+                            log!(
[m[32m+                                "Successfully {} display name.",
[m[32m+                                if is_removing { "removed" } else { "set" }
[m[32m+                            );
[m[32m+                            Cx::post_action(AccountDataAction::DisplayNameChanged(
[m[32m+                                new_display_name,
[m[32m+                            ));
[m                         }
                         Err(e) => {
[31m-                            let err_msg = format!("Failed to {} display name: {e}", if is_removing { "remove" } else { "set" });
[m[32m+                            let err_msg = format!(
[m[32m+                                "Failed to {} display name: {e}",
[m[32m+                                if is_removing { "remove" } else { "set" }
[m[32m+                            );
[m                             Cx::post_action(AccountDataAction::DisplayNameChangeFailed(err_msg));
                         }
                     }
Diff in /app/src/sliding_sync.rs:1163:
                 });
             }
[31m-            MatrixRequest::GenerateMatrixLink { room_id, event_id, use_matrix_scheme, join_on_click } => {
[m[32m+            MatrixRequest::GenerateMatrixLink {
[m[32m+                room_id,
[m[32m+                event_id,
[m[32m+                use_matrix_scheme,
[m[32m+                join_on_click,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _gen_link_task = Handle::current().spawn(async move {
                     if let Some(room) = client.get_room(&room_id) {
Diff in /app/src/sliding_sync.rs:1169:
                         let result = if use_matrix_scheme {
                             if let Some(event_id) = event_id {
[31m-                                room.matrix_event_permalink(event_id).await
[m[32m+                                room.matrix_event_permalink(event_id)
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixUri)
                             } else {
[31m-                                room.matrix_permalink(join_on_click).await
[m[32m+                                room.matrix_permalink(join_on_click)
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixUri)
                             }
                         } else {
Diff in /app/src/sliding_sync.rs:1178:
                             if let Some(event_id) = event_id {
[31m-                                room.matrix_to_event_permalink(event_id).await
[m[32m+                                room.matrix_to_event_permalink(event_id)
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixToUri)
                             } else {
[31m-                                room.matrix_to_permalink().await
[m[32m+                                room.matrix_to_permalink()
[m[32m+                                    .await
[m                                     .map(MatrixLinkAction::MatrixToUri)
                             }
                         };
Diff in /app/src/sliding_sync.rs:1186:
[31m-
[m[32m+
[m                         match result {
                             Ok(action) => Cx::post_action(action),
                             Err(e) => Cx::post_action(MatrixLinkAction::Error(e.to_string())),
Diff in /app/src/sliding_sync.rs:1190:
                         }
                     } else {
[31m-                         Cx::post_action(MatrixLinkAction::Error(format!("Room {room_id} not found")));
[m[32m+                        Cx::post_action(MatrixLinkAction::Error(format!(
[m[32m+                            "Room {room_id} not found"
[m[32m+                        )));
[m                     }
                 });
             }
Diff in /app/src/sliding_sync.rs:1196:
[31m-            MatrixRequest::IgnoreUser { ignore, room_member, room_id } => {
[m[32m+            MatrixRequest::IgnoreUser {
[m[32m+                ignore,
[m[32m+                room_member,
[m[32m+                room_id,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let _ignore_task = Handle::current().spawn(async move {
                     let user_id = room_member.user_id();
Diff in /app/src/sliding_sync.rs:1262:
                 let (room, timeline_update_sender, mut typing_notice_receiver) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("BUG: room info not found for subscribe to typing notices request, room {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for subscribe to typing notices request, room {room_id}"
[m[32m+                        );
[m                         continue;
                     };
                     let (room, recv) = if subscribe {
Diff in /app/src/sliding_sync.rs:1269:
                         if room_info.typing_notice_subscriber.is_some() {
[31m-                            warning!("Note: room {room_id} is already subscribed to typing notices.");
[m[32m+                            warning!(
[m[32m+                                "Note: room {room_id} is already subscribed to typing notices."
[m[32m+                            );
[m                             continue;
                         } else {
                             let Some(room) = get_client().and_then(|c| c.get_room(&room_id)) else {
Diff in /app/src/sliding_sync.rs:1274:
[31m-                                error!("BUG: client/room not found when subscribing to typing notices request, room: {room_id}");
[m[32m+                                error!(
[m[32m+                                    "BUG: client/room not found when subscribing to typing notices request, room: {room_id}"
[m[32m+                                );
[m                                 continue;
                             };
                             let (drop_guard, recv) = room.subscribe_to_typing_notifications();
Diff in /app/src/sliding_sync.rs:1310:
             }
             MatrixRequest::SubscribeToOwnUserReadReceiptsChanged { room_id, subscribe } => {
                 if !subscribe {
[31m-                    if let Some(task_handler) = subscribers_own_user_read_receipts.remove(&room_id) {
[m[32m+                    if let Some(task_handler) = subscribers_own_user_read_receipts.remove(&room_id)
[m[32m+                    {
[m                         task_handler.abort();
                     }
                     continue;
Diff in /app/src/sliding_sync.rs:1318:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("BUG: room info not found for subscribe to own user read receipts changed request, room {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for subscribe to own user read receipts changed request, room {room_id}"
[m[32m+                        );
[m                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };
                 let room_id_clone = room_id.clone();
                 let subscribe_own_read_receipt_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:1372:
                 let (timeline, sender) = {
                     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get_mut(&room_id) else {
[31m-                        log!("BUG: room info not found for subscribe to pinned events request, room {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for subscribe to pinned events request, room {room_id}"
[m[32m+                        );
[m                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };
                 let subscribe_pinned_events_task = Handle::current().spawn(async move {
                     // Send an initial update, as the stream may not update immediately.
Diff in /app/src/sliding_sync.rs:1395:
                 });
                 subscribers_pinned_events.insert(room_id, subscribe_pinned_events_task);
             }
[31m-            MatrixRequest::SpawnSSOServer { brand, homeserver_url, identity_provider_id} => {
[m[31m-                spawn_sso_server(brand, homeserver_url, identity_provider_id, login_sender.clone()).await;
[m[32m+            MatrixRequest::SpawnSSOServer {
[m[32m+                brand,
[m[32m+                homeserver_url,
[m[32m+                identity_provider_id,
[m[32m+            } => {
[m[32m+                spawn_sso_server(
[m[32m+                    brand,
[m[32m+                    homeserver_url,
[m[32m+                    identity_provider_id,
[m[32m+                    login_sender.clone(),
[m[32m+                )
[m[32m+                .await;
[m             }
             MatrixRequest::ResolveRoomAlias(room_alias) => {
                 let Some(client) = get_client() else { continue };
Diff in /app/src/sliding_sync.rs:1407:
                     todo!("Send the resolved room alias back to the UI thread somehow.");
                 });
             }
[31m-            MatrixRequest::FetchAvatar { mxc_uri, on_fetched } => {
[m[32m+            MatrixRequest::FetchAvatar {
[m[32m+                mxc_uri,
[m[32m+                on_fetched,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 Handle::current().spawn(async move {
                     // log!("Sending fetch avatar request for {mxc_uri:?}...");
Diff in /app/src/sliding_sync.rs:1417:
                     };
                     let res = client.media().get_media_content(&media_request, true).await;
                     // log!("Fetched avatar for {mxc_uri:?}, succeeded? {}", res.is_ok());
[31m-                    on_fetched(AvatarUpdate { mxc_uri, avatar_data: res.map(|v| v.into()) });
[m[32m+                    on_fetched(AvatarUpdate {
[m[32m+                        mxc_uri,
[m[32m+                        avatar_data: res.map(|v| v.into()),
[m[32m+                    });
[m                 });
             }

Diff in /app/src/sliding_sync.rs:1424:
[31m-            MatrixRequest::FetchMedia { media_request, on_fetched, destination, update_sender } => {
[m[32m+            MatrixRequest::FetchMedia {
[m[32m+                media_request,
[m[32m+                on_fetched,
[m[32m+                destination,
[m[32m+                update_sender,
[m[32m+            } => {
[m                 let Some(client) = get_client() else { continue };
                 let media = client.media();

Diff in /app/src/sliding_sync.rs:1520:
                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
[31m-                        log!("BUG: room info not found when sending read receipt, room {room_id}, {event_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found when sending read receipt, room {room_id}, {event_id}"
[m[32m+                        );
[m                         continue;
                     };
                     room_info.timeline.clone()
Diff in /app/src/sliding_sync.rs:1538:
                         unread_mentions: timeline.room().num_unread_mentions()
                     });
                 });
[31m-            },
[m[32m+            }
[m
[31m-            MatrixRequest::FullyReadReceipt { room_id, event_id, .. } => {
[m[32m+            MatrixRequest::FullyReadReceipt {
[m[32m+                room_id, event_id, ..
[m[32m+            } => {
[m                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1547:
[31m-                        log!("BUG: room info not found when sending fully read receipt, room {room_id}, {event_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found when sending fully read receipt, room {room_id}, {event_id}"
[m[32m+                        );
[m                         continue;
                     };
                     room_info.timeline.clone()
Diff in /app/src/sliding_sync.rs:1564:
                         unread_mentions: timeline.room().num_unread_mentions()
                     });
                 });
[31m-            },
[m[32m+            }
[m
             MatrixRequest::GetRoomPowerLevels { room_id } => {
                 let (timeline, sender) = {
Diff in /app/src/sliding_sync.rs:1571:
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
[31m-                        log!("BUG: room info not found for get room power levels request {room_id}");
[m[32m+                        log!(
[m[32m+                            "BUG: room info not found for get room power levels request {room_id}"
[m[32m+                        );
[m                         continue;
                     };

Diff in /app/src/sliding_sync.rs:1577:
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

[31m-                let Some(user_id) = current_user_id() else { continue };
[m[32m+                let Some(user_id) = current_user_id() else {
[m[32m+                    continue;
[m[32m+                };
[m
                 let _power_levels_task = Handle::current().spawn(async move {
                     match timeline.room().power_levels().await {
Diff in /app/src/sliding_sync.rs:1595:
                         }
                     }
                 });
[31m-            },
[m[31m-            MatrixRequest::ToggleReaction { room_id, timeline_event_id, reaction } => {
[m[32m+            }
[m[32m+            MatrixRequest::ToggleReaction {
[m[32m+                room_id,
[m[32m+                timeline_event_id,
[m[32m+                reaction,
[m[32m+            } => {
[m                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1616:
                         Err(_e) => error!("Failed to send toggle reaction to room {room_id} {reaction}; error: {_e:?}"),
                     }
                 });
[31m-
[m[31m-            },
[m[31m-            MatrixRequest::RedactMessage { room_id, timeline_event_id, reason } => {
[m[32m+            }
[m[32m+            MatrixRequest::RedactMessage {
[m[32m+                room_id,
[m[32m+                timeline_event_id,
[m[32m+                reason,
[m[32m+            } => {
[m                 let timeline = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1641:
                         }
                     }
                 });
[31m-            },
[m[31m-            MatrixRequest::PinEvent { room_id, event_id, pin } => {
[m[32m+            }
[m[32m+            MatrixRequest::PinEvent {
[m[32m+                room_id,
[m[32m+                event_id,
[m[32m+                pin,
[m[32m+            } => {
[m                 let (timeline, sender) = {
                     let all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
                     let Some(room_info) = all_joined_rooms.get(&room_id) else {
Diff in /app/src/sliding_sync.rs:1649:
                         log!("BUG: room info not found for pin message {room_id}");
                         continue;
                     };
[31m-                    (room_info.timeline.clone(), room_info.timeline_update_sender.clone())
[m[32m+                    (
[m[32m+                        room_info.timeline.clone(),
[m[32m+                        room_info.timeline_update_sender.clone(),
[m[32m+                    )
[m                 };

                 let _pin_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:1658:
                     } else {
                         timeline.unpin_event(&event_id).await
                     };
[31m-                    match sender.send(TimelineUpdate::PinResult { event_id, pin, result }) {
[m[32m+                    match sender.send(TimelineUpdate::PinResult {
[m[32m+                        event_id,
[m[32m+                        pin,
[m[32m+                        result,
[m[32m+                    }) {
[m                         Ok(_) => SignalToUI::set_ui_signal(),
                         Err(e) => log!("Failed to send timeline update for pin event: {e:?}"),
                     }
Diff in /app/src/sliding_sync.rs:1690:
                     }
                 });
             }
[31m-            MatrixRequest::GetUrlPreview { url, on_fetched, destination, update_sender,} => {
[m[32m+            MatrixRequest::GetUrlPreview {
[m[32m+                url,
[m[32m+                on_fetched,
[m[32m+                destination,
[m[32m+                update_sender,
[m[32m+            } => {
[m                 // const MAX_LOG_RESPONSE_BODY_LENGTH: usize = 1000;
                 // log!("Starting URL preview fetch for: {}", url);
                 let _fetch_url_preview_task = Handle::current().spawn(async move {
Diff in /app/src/sliding_sync.rs:1700:
                             // error!("Matrix client not available for URL preview: {}", url);
                             UrlPreviewError::ClientNotAvailable
                         })?;
[31m-
[m[32m+
[m                         let token = client.access_token().ok_or_else(|| {
                             // error!("Access token not available for URL preview: {}", url);
                             UrlPreviewError::AccessTokenNotAvailable
Diff in /app/src/sliding_sync.rs:1707:
                         })?;
                         // Official Doc: https://spec.matrix.org/v1.11/client-server-api/#get_matrixclientv1mediapreview_url
                         // Element desktop is using /_matrix/media/v3/preview_url
[31m-                        let endpoint_url = client.homeserver().join("/_matrix/client/v1/media/preview_url")
[m[32m+                        let endpoint_url = client
[m[32m+                            .homeserver()
[m[32m+                            .join("/_matrix/client/v1/media/preview_url")
[m                             .map_err(UrlPreviewError::UrlParse)?;
                         // log!("Fetching URL preview from endpoint: {} for URL: {}", endpoint_url, url);
[31m-
[m[32m+
[m                         let response = client
                             .http_client()
                             .get(endpoint_url.clone())
Diff in /app/src/sliding_sync.rs:1723:
                                 // error!("HTTP request failed for URL preview {}: {}", url, e);
                                 UrlPreviewError::Request(e)
                             })?;
[31m-
[m[32m+
[m                         let status = response.status();
                         // log!("URL preview response status for {}: {}", url, status);
[31m-
[m[32m+
[m                         if !status.is_success() && status.as_u16() != 429 {
                             // error!("URL preview request failed with status {} for URL: {}", status, url);
                             return Err(UrlPreviewError::HttpStatus(status.as_u16()));
Diff in /app/src/sliding_sync.rs:1733:
                         }
[31m-
[m[32m+
[m                         let text = response.text().await.map_err(|e| {
                             // error!("Failed to read response text for URL preview {}: {}", url, e);
                             UrlPreviewError::Request(e)
Diff in /app/src/sliding_sync.rs:1738:
                         })?;
[31m-
[m[32m+
[m                         // log!("URL preview response body length for {}: {} bytes", url, text.len());
                         // if text.len() > MAX_LOG_RESPONSE_BODY_LENGTH {
                         //     log!("URL preview response body preview for {}: {}...", url, &text[..MAX_LOG_RESPONSE_BODY_LENGTH]);
Diff in /app/src/sliding_sync.rs:1745:
                         // }
                         // This request is rate limited, retry after a duration we get from the server.
                         if status.as_u16() == 429 {
[31m-                            let link_preview_429_res = serde_json::from_str::<LinkPreviewRateLimitResponse>(&text)
[m[31m-                                .map_err(|e| {
[m[31m-                                    // error!("Failed to parse as LinkPreviewRateLimitResponse for URL preview {}: {}", url, e);
[m[31m-                                    UrlPreviewError::Json(e)
[m[31m-                            });
[m[32m+                            let link_preview_429_res =
[m[32m+                                serde_json::from_str::<LinkPreviewRateLimitResponse>(&text)
[m[32m+                                    .map_err(|e| {
[m[32m+                                        // error!("Failed to parse as LinkPreviewRateLimitResponse for URL preview {}: {}", url, e);
[m[32m+                                        UrlPreviewError::Json(e)
[m[32m+                                    });
[m                             match link_preview_429_res {
                                 Ok(link_preview_429_res) => {
                                     if let Some(retry_after) = link_preview_429_res.retry_after_ms {
Diff in /app/src/sliding_sync.rs:1756:
[31m-                                        tokio::time::sleep(Duration::from_millis(retry_after.into())).await;
[m[31m-                                        submit_async_request(MatrixRequest::GetUrlPreview{
[m[32m+                                        tokio::time::sleep(Duration::from_millis(
[m[32m+                                            retry_after.into(),
[m[32m+                                        ))
[m[32m+                                        .await;
[m[32m+                                        submit_async_request(MatrixRequest::GetUrlPreview {
[m                                             url: url.clone(),
                                             on_fetched,
                                             destination: destination.clone(),
Diff in /app/src/sliding_sync.rs:1761:
                                             update_sender: update_sender.clone(),
                                         });
[31m-
[m                                     }
                                 }
                                 Err(_e) => {
Diff in /app/src/sliding_sync.rs:1780:
                                 // error!("Response body that failed to parse: {}", text);
                                 UrlPreviewError::Json(e)
                             })
[31m-                    }.await;
[m[32m+                    }
[m[32m+                    .await;
[m
                     // match &result {
                     //     Ok(preview_data) => {
Diff in /app/src/sliding_sync.rs:1787:
[31m-                    //         log!("Successfully fetched URL preview for {}: title={:?}, site_name={:?}",
[m[32m+                    //         log!("Successfully fetched URL preview for {}: title={:?}, site_name={:?}",
[m                     //              url, preview_data.title, preview_data.site_name);
                     //     }
                     //     Err(e) => {
Diff in /app/src/sliding_sync.rs:1803:
     bail!("matrix_worker_task task ended unexpectedly")
 }

[31m-
[m /// The single global Tokio runtime that is used by all async tasks.
 static TOKIO_RUNTIME: Mutex<Option<tokio::runtime::Runtime>> = Mutex::new(None);

Diff in /app/src/sliding_sync.rs:1816:
 static DEFAULT_SSO_CLIENT: Mutex<Option<(Client, ClientSessionPersisted)>> = Mutex::new(None);

 /// Used to notify the SSO login task that the async creation of the `DEFAULT_SSO_CLIENT` has finished.
[31m-static DEFAULT_SSO_CLIENT_NOTIFIER: LazyLock<Arc<Notify>> = LazyLock::new(|| Arc::new(Notify::new()));
[m[32m+static DEFAULT_SSO_CLIENT_NOTIFIER: LazyLock<Arc<Notify>> =
[m[32m+    LazyLock::new(|| Arc::new(Notify::new()));
[m
 /// Blocks the current thread until the given future completes.
 ///
Diff in /app/src/sliding_sync.rs:1827:
     timeout: Option<Duration>,
     async_future: impl Future<Output = T>,
 ) -> Result<T, Elapsed> {
[31m-    let rt = TOKIO_RUNTIME.lock().unwrap().get_or_insert_with(||
[m[31m-        tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[31m-    ).handle().clone();
[m[32m+    let rt = TOKIO_RUNTIME
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .get_or_insert_with(|| {
[m[32m+            tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[32m+        })
[m[32m+        .handle()
[m[32m+        .clone();
[m
     if let Some(timeout) = timeout {
[31m-        rt.block_on(async {
[m[31m-            tokio::time::timeout(timeout, async_future).await
[m[31m-        })
[m[32m+        rt.block_on(async { tokio::time::timeout(timeout, async_future).await })
[m     } else {
         Ok(rt.block_on(async_future))
     }
Diff in /app/src/sliding_sync.rs:1841:
 }

[31m-
[m /// The primary initialization routine for starting the Matrix client sync
 /// and the async tokio runtime.
 ///
Diff in /app/src/sliding_sync.rs:1847:
 /// Returns a handle to the Tokio runtime that is used to run async background tasks.
 pub fn start_matrix_tokio() -> Result<tokio::runtime::Handle> {
     // Create a Tokio runtime, and save it in a static variable to ensure it isn't dropped.
[31m-    let rt_handle = TOKIO_RUNTIME.lock().unwrap().get_or_insert_with(|| {
[m[31m-        tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[31m-    }).handle().clone();
[m[32m+    let rt_handle = TOKIO_RUNTIME
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .get_or_insert_with(|| {
[m[32m+            tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime")
[m[32m+        })
[m[32m+        .handle()
[m[32m+        .clone();
[m
     // Proactively build a Matrix Client in the background so that the SSO Server
     // can have a quicker start if needed (as it's rather slow to build this client).
Diff in /app/src/sliding_sync.rs:1856:
     rt_handle.spawn(async move {
         match build_client(&Cli::default(), app_data_dir()).await {
             Ok(client_and_session) => {
[31m-                DEFAULT_SSO_CLIENT.lock().unwrap()
[m[32m+                DEFAULT_SSO_CLIENT
[m[32m+                    .lock()
[m[32m+                    .unwrap()
[m                     .get_or_insert(client_and_session);
             }
             Err(e) => error!("Error: could not create DEFAULT_SSO_CLIENT object: {e}"),
Diff in /app/src/sliding_sync.rs:1873:
     Ok(rt_handle)
 }

[31m-
[m /// A tokio::watch channel sender for sending requests from the RoomScreen UI widget
 /// to the corresponding background async task for that room (its `timeline_subscriber_handler`).
 pub type TimelineRequestSender = watch::Sender<Vec<BackwardsPaginateUntilEventRequest>>;
Diff in /app/src/sliding_sync.rs:1928:
     }
 }

[31m-
[m /// A const-compatible hasher, used for `static` items containing `HashMap`s or `HashSet`s.
 type ConstHasher = BuildHasherDefault<DefaultHasher>;

Diff in /app/src/sliding_sync.rs:1937:
 ///
 /// We use `LazyLock` here to initialize the `HashMap` with its default hasher (AHash),
 /// which is significantly faster than the default `std` hasher (SipHash) required for const initialization.
[31m-static ALL_JOINED_ROOMS: LazyLock<Mutex<HashMap<OwnedRoomId, JoinedRoomDetails>>> = LazyLock::new(|| Mutex::new(HashMap::new()));
[m[32m+static ALL_JOINED_ROOMS: LazyLock<Mutex<HashMap<OwnedRoomId, JoinedRoomDetails>>> =
[m[32m+    LazyLock::new(|| Mutex::new(HashMap::new()));
[m
 /// The logged-in Matrix client, which can be freely and cheaply cloned.
 static CLIENT: Mutex<Option<Client>> = Mutex::new(None);
Diff in /app/src/sliding_sync.rs:1948:

 /// Returns the user ID of the currently logged-in user, if any.
 pub fn current_user_id() -> Option<OwnedUserId> {
[31m-    CLIENT.lock().unwrap().as_ref().and_then(|c|
[m[31m-        c.session_meta().map(|m| m.user_id.clone())
[m[31m-    )
[m[32m+    CLIENT
[m[32m+        .lock()
[m[32m+        .unwrap()
[m[32m+        .as_ref()
[m[32m+        .and_then(|c| c.session_meta().map(|m| m.user_id.clone()))
[m }

 /// The singleton sync service.
Diff in /app/src/sliding_sync.rs:1957:
 static SYNC_SERVICE: Mutex<Option<Arc<SyncService>>> = Mutex::new(None);

[31m-
[m /// Get a reference to the current sync service, if available.
 pub fn get_sync_service() -> Option<Arc<SyncService>> {
     SYNC_SERVICE.lock().ok()?.as_ref().cloned()
Diff in /app/src/sliding_sync.rs:1965:
 /// The list of users that the current user has chosen to ignore.
 /// Ideally we shouldn't have to maintain this list ourselves,
 /// but the Matrix SDK doesn't currently properly maintain the list of ignored users.
[31m-static IGNORED_USERS: Mutex<HashSet<OwnedUserId, ConstHasher>> = Mutex::new(HashSet::with_hasher(BuildHasherDefault::new()));
[m[32m+static IGNORED_USERS: Mutex<HashSet<OwnedUserId, ConstHasher>> =
[m[32m+    Mutex::new(HashSet::with_hasher(BuildHasherDefault::new()));
[m
 /// Returns a deep clone of the current list of ignored users.
 pub fn get_ignored_users() -> HashSet<OwnedUserId, ConstHasher> {
Diff in /app/src/sliding_sync.rs:1977:
     IGNORED_USERS.lock().unwrap().contains(user_id)
 }

[31m-
[m /// Returns three channel endpoints related to the timeline for the given joined room.
 ///
 /// 1. A timeline update sender.
Diff in /app/src/sliding_sync.rs:1985:
 /// 3. A `tokio::watch` sender that can be used to send requests to the timeline subscriber handler.
 ///
 /// This will only succeed once per room, as only a single channel receiver can exist.
[31m-pub fn take_timeline_endpoints(
[m[31m-    room_id: &OwnedRoomId,
[m[31m-) -> Option<TimelineEndpoints> {
[m[32m+pub fn take_timeline_endpoints(room_id: &OwnedRoomId) -> Option<TimelineEndpoints> {
[m     let mut all_joined_rooms = ALL_JOINED_ROOMS.lock().unwrap();
     all_joined_rooms
         .get_mut(room_id)
Diff in /app/src/sliding_sync.rs:1994:
[31m-        .and_then(|jrd| jrd.timeline_singleton_endpoints.take()
[m[31m-            .map(|(update_receiver, request_sender)| (
[m[31m-                jrd.timeline_update_sender.clone(),
[m[31m-                update_receiver,
[m[31m-                request_sender,
[m[31m-                jrd.timeline.room().successor_room(),
[m[31m-            ))
[m[31m-        )
[m[31m-        .map(|(update_sender, update_receiver, request_sender, successor_room)| {
[m[31m-            TimelineEndpoints {
[m[32m+        .and_then(|jrd| {
[m[32m+            jrd.timeline_singleton_endpoints
[m[32m+                .take()
[m[32m+                .map(|(update_receiver, request_sender)| {
[m[32m+                    (
[m[32m+                        jrd.timeline_update_sender.clone(),
[m[32m+                        update_receiver,
[m[32m+                        request_sender,
[m[32m+                        jrd.timeline.room().successor_room(),
[m[32m+                    )
[m[32m+                })
[m[32m+        })
[m[32m+        .map(
[m[32m+            |(update_sender, update_receiver, request_sender, successor_room)| TimelineEndpoints {
[m                 update_sender,
                 update_receiver,
                 request_sender,
Diff in /app/src/sliding_sync.rs:2007:
                 successor_room,
[31m-            }
[m[31m-        })
[m[32m+            },
[m[32m+        )
[m }

 const DEFAULT_HOMESERVER: &str = "matrix.org";
Diff in /app/src/sliding_sync.rs:2013:

[31m-fn username_to_full_user_id(
[m[31m-    username: &str,
[m[31m-    homeserver: Option<&str>,
[m[31m-) -> Option<OwnedUserId> {
[m[31m-    username
[m[31m-        .try_into()
[m[31m-        .ok()
[m[31m-        .or_else(|| {
[m[31m-            let homeserver_url = homeserver.unwrap_or(DEFAULT_HOMESERVER);
[m[31m-            let user_id_str = if username.starts_with("@") {
[m[31m-                format!("{}:{}", username, homeserver_url)
[m[31m-            } else {
[m[31m-                format!("@{}:{}", username, homeserver_url)
[m[31m-            };
[m[31m-            user_id_str.as_str().try_into().ok()
[m[31m-        })
[m[32m+fn username_to_full_user_id(username: &str, homeserver: Option<&str>) -> Option<OwnedUserId> {
[m[32m+    username.try_into().ok().or_else(|| {
[m[32m+        let homeserver_url = homeserver.unwrap_or(DEFAULT_HOMESERVER);
[m[32m+        let user_id_str = if username.starts_with("@") {
[m[32m+            format!("{}:{}", username, homeserver_url)
[m[32m+        } else {
[m[32m+            format!("@{}:{}", username, homeserver_url)
[m[32m+        };
[m[32m+        user_id_str.as_str().try_into().ok()
[m[32m+    })
[m }

[31m-
[m /// Info we store about a room received by the room list service.
 ///
 /// This struct is necessary in order for us to track the previous state
Diff in /app/src/sliding_sync.rs:2057:
 impl RoomListServiceRoomInfo {
     async fn from_room(room: matrix_sdk::Room, current_user_id: &Option<OwnedUserId>) -> Self {
         // Parallelize fetching of independent room data.
[31m-        let (is_direct, tags, display_name, user_power_levels) = tokio::join!(
[m[31m-            room.is_direct(),
[m[31m-            room.tags(),
[m[31m-            room.display_name(),
[m[31m-            async {
[m[32m+        let (is_direct, tags, display_name, user_power_levels) =
[m[32m+            tokio::join!(room.is_direct(), room.tags(), room.display_name(), async {
[m                 if let Some(user_id) = current_user_id {
                     UserPowerLevels::from_room(&room, user_id.deref()).await
                 } else {
Diff in /app/src/sliding_sync.rs:2068:
                     None
                 }
[31m-            }
[m[31m-        );
[m[32m+            });
[m
         Self {
             room_id: room.room_id().to_owned(),
Diff in /app/src/sliding_sync.rs:2110:
     let most_recent_user_id = persistence::most_recent_user_id().await;
     log!("Most recent user ID: {most_recent_user_id:?}");
     let cli_parse_result = Cli::try_parse();
[31m-    let cli_has_valid_username_password = cli_parse_result.as_ref()
[m[32m+    let cli_has_valid_username_password = cli_parse_result
[m[32m+        .as_ref()
[m         .is_ok_and(|cli| !cli.user_id.is_empty() && !cli.password.is_empty());
[31m-    log!("CLI parsing succeeded? {}. CLI has valid UN+PW? {}",
[m[32m+    log!(
[m[32m+        "CLI parsing succeeded? {}. CLI has valid UN+PW? {}",
[m         cli_parse_result.as_ref().is_ok(),
         cli_has_valid_username_password,
     );
Diff in /app/src/sliding_sync.rs:2119:
[31m-    let wait_for_login = !cli_has_valid_username_password && (
[m[31m-        most_recent_user_id.is_none()
[m[31m-            || std::env::args().any(|arg| arg == "--login-screen" || arg == "--force-login")
[m[31m-    );
[m[32m+    let wait_for_login = !cli_has_valid_username_password
[m[32m+        && (most_recent_user_id.is_none()
[m[32m+            || std::env::args().any(|arg| arg == "--login-screen" || arg == "--force-login"));
[m     log!("Waiting for login? {}", wait_for_login);

     let new_login_opt = if !wait_for_login {
Diff in /app/src/sliding_sync.rs:2126:
[31m-        let specified_username = cli_parse_result.as_ref().ok().and_then(|cli|
[m[31m-            username_to_full_user_id(
[m[31m-                &cli.user_id,
[m[31m-                cli.homeserver.as_deref(),
[m[31m-            )
[m[31m-        );
[m[31m-        log!("Trying to restore session for user: {:?}",
[m[32m+        let specified_username = cli_parse_result
[m[32m+            .as_ref()
[m[32m+            .ok()
[m[32m+            .and_then(|cli| username_to_full_user_id(&cli.user_id, cli.homeserver.as_deref()));
[m[32m+        log!(
[m[32m+            "Trying to restore session for user: {:?}",
[m             specified_username.as_ref().or(most_recent_user_id.as_ref())
         );
         match persistence::restore_session(specified_username).await {
Diff in /app/src/sliding_sync.rs:2140:
                 Cx::post_action(LoginAction::LoginFailure(status_err.to_string()));

                 if let Ok(cli) = &cli_parse_result {
[31m-                    log!("Attempting auto-login from CLI arguments as user '{}'...", cli.user_id);
[m[32m+                    log!(
[m[32m+                        "Attempting auto-login from CLI arguments as user '{}'...",
[m[32m+                        cli.user_id
[m[32m+                    );
[m                     Cx::post_action(LoginAction::CliAutoLogin {
                         user_id: cli.user_id.clone(),
                         homeserver: cli.homeserver.clone(),
Diff in /app/src/sliding_sync.rs:2149:
                         Ok(new_login) => Some(new_login),
                         Err(e) => {
                             error!("CLI-based login failed: {e:?}");
[31m-                            Cx::post_action(LoginAction::LoginFailure(
[m[31m-                                format!("Could not login with CLI-provided arguments.\n\nPlease login manually.\n\nError: {e}")
[m[31m-                            ));
[m[32m+                            Cx::post_action(LoginAction::LoginFailure(format!(
[m[32m+                                "Could not login with CLI-provided arguments.\n\nPlease login manually.\n\nError: {e}"
[m[32m+                            )));
[m                             enqueue_rooms_list_update(RoomsListUpdate::Status {
                                 status: format!("Login failed: {e:?}"),
                             });
Diff in /app/src/sliding_sync.rs:2169:
     let cli: Cli = cli_parse_result.unwrap_or(Cli::default());
     let (client, _sync_token) = match new_login_opt {
         Some(new_login) => new_login,
[31m-        None => {
[m[31m-            loop {
[m[31m-                log!("Waiting for login request...");
[m[31m-                match login_receiver.recv().await {
[m[31m-                    Some(login_request) => {
[m[31m-                        match login(&cli, login_request).await {
[m[31m-                            Ok((client, sync_token)) => {
[m[31m-                                break (client, sync_token);
[m[31m-                            }
[m[31m-                            Err(e) => {
[m[31m-                                error!("Login failed: {e:?}");
[m[31m-                                Cx::post_action(LoginAction::LoginFailure(format!("{e}")));
[m[31m-                                enqueue_rooms_list_update(RoomsListUpdate::Status {
[m[31m-                                    status: format!("Login failed: {e}"),
[m[31m-                                });
[m[31m-                            }
[m[31m-                        }
[m[31m-                    },
[m[31m-                    None => {
[m[31m-                        error!("BUG: login_receiver hung up unexpectedly");
[m[31m-                        let err = String::from("Please restart Robrix.\n\nUnable to listen for login requests.");
[m[31m-                        Cx::post_action(LoginAction::LoginFailure(err.clone()));
[m[32m+        None => loop {
[m[32m+            log!("Waiting for login request...");
[m[32m+            match login_receiver.recv().await {
[m[32m+                Some(login_request) => match login(&cli, login_request).await {
[m[32m+                    Ok((client, sync_token)) => {
[m[32m+                        break (client, sync_token);
[m[32m+                    }
[m[32m+                    Err(e) => {
[m[32m+                        error!("Login failed: {e:?}");
[m[32m+                        Cx::post_action(LoginAction::LoginFailure(format!("{e}")));
[m                         enqueue_rooms_list_update(RoomsListUpdate::Status {
[31m-                            status: err,
[m[32m+                            status: format!("Login failed: {e}"),
[m                         });
[31m-                        return;
[m                     }
[32m+                },
[m[32m+                None => {
[m[32m+                    error!("BUG: login_receiver hung up unexpectedly");
[m[32m+                    let err = String::from(
[m[32m+                        "Please restart Robrix.\n\nUnable to listen for login requests.",
[m[32m+                    );
[m[32m+                    Cx::post_action(LoginAction::LoginFailure(err.clone()));
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::Status { status: err });
[m[32m+                    return;
[m                 }
             }
[31m-        }
[m[32m+        },
[m     };

     Cx::post_action(LoginAction::LoginSuccess);
Diff in /app/src/sliding_sync.rs:2208:
         let _ = client_opt.take();
     }

[31m-    let logged_in_user_id = client.user_id()
[m[32m+    let logged_in_user_id = client
[m[32m+        .user_id()
[m         .expect("BUG: client.user_id() returned None after successful login!");
     let status = format!("Logged in as {}.\n → Loading rooms...", logged_in_user_id);
     enqueue_rooms_list_update(RoomsListUpdate::Status { status });
Diff in /app/src/sliding_sync.rs:2215:

     // Store this active client in our global Client state so that other tasks can access it.
     if let Some(_existing) = CLIENT.lock().unwrap().replace(client.clone()) {
[31m-        error!("BUG: unexpectedly replaced an existing client when initializing the matrix client.");
[m[32m+        error!(
[m[32m+            "BUG: unexpectedly replaced an existing client when initializing the matrix client."
[m[32m+        );
[m     }

     // Listen for changes to our verification status and incoming verification requests.
Diff in /app/src/sliding_sync.rs:2232:
         Ok(ss) => ss,
         Err(e) => {
             error!("BUG: failed to create SyncService: {e:?}");
[31m-            let err = format!("Please restart Robrix.\n\nFailed to create Matrix sync service: {e}.");
[m[31m-            enqueue_popup_notification(
[m[31m-                err.clone(),
[m[31m-                PopupKind::Error,
[m[31m-                None,
[m[31m-            );
[m[32m+            let err =
[m[32m+                format!("Please restart Robrix.\n\nFailed to create Matrix sync service: {e}.");
[m[32m+            enqueue_popup_notification(err.clone(), PopupKind::Error, None);
[m             enqueue_rooms_list_update(RoomsListUpdate::Status { status: err });
             return;
         }
Diff in /app/src/sliding_sync.rs:2251:
     let room_list_service = sync_service.room_list_service();

     if let Some(_existing) = SYNC_SERVICE.lock().unwrap().replace(Arc::new(sync_service)) {
[31m-        error!("BUG: unexpectedly replaced an existing sync service when initializing the matrix client.");
[m[32m+        error!(
[m[32m+            "BUG: unexpectedly replaced an existing sync service when initializing the matrix client."
[m[32m+        );
[m     }

     let mut room_list_service_task = rt.spawn(room_list_service_loop(room_list_service));
Diff in /app/src/sliding_sync.rs:2342:
     }
 }

[31m-
[m /// The main async task that listens for changes to all rooms.
 async fn room_list_service_loop(room_list_service: Arc<RoomListService>) -> Result<()> {
     let all_rooms_list = room_list_service.all_rooms().await?;
Diff in /app/src/sliding_sync.rs:2356:
     // 1. not spaces (those are handled by the SpaceService),
     // 2. not left (clients don't typically show rooms that the user has already left),
     // 3. not outdated (don't show tombstoned rooms whose successor is already joined).
[31m-    room_list_dynamic_entries_controller.set_filter(Box::new(
[m[31m-        filters::new_filter_all(vec![
[m[31m-            Box::new(filters::new_filter_not(Box::new(filters::new_filter_space()))),
[m[31m-            Box::new(filters::new_filter_non_left()),
[m[31m-            Box::new(filters::new_filter_deduplicate_versions()),
[m[31m-        ])
[m[31m-    ));
[m[32m+    room_list_dynamic_entries_controller.set_filter(Box::new(filters::new_filter_all(vec![
[m[32m+        Box::new(filters::new_filter_not(Box::new(
[m[32m+            filters::new_filter_space(),
[m[32m+        ))),
[m[32m+        Box::new(filters::new_filter_non_left()),
[m[32m+        Box::new(filters::new_filter_deduplicate_versions()),
[m[32m+    ])));
[m
     let mut all_known_rooms: Vector<RoomListServiceRoomInfo> = Vector::new();
     let current_user_id = current_user_id();
Diff in /app/src/sliding_sync.rs:2378:
                     // Append and Reset are identical, except for Reset first clears all rooms.
                     let _num_new_rooms = new_rooms.len();
                     if is_reset {
[31m-                        if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Reset, old length {}, new length {}", all_known_rooms.len(), new_rooms.len()); }
[m[32m+                        if LOG_ROOM_LIST_DIFFS {
[m[32m+                            log!(
[m[32m+                                "room_list: diff Reset, old length {}, new length {}",
[m[32m+                                all_known_rooms.len(),
[m[32m+                                new_rooms.len()
[m[32m+                            );
[m[32m+                        }
[m                         // Iterate manually so we can know which rooms are being removed.
                         while let Some(room) = all_known_rooms.pop_back() {
                             remove_room(&room);
Diff in /app/src/sliding_sync.rs:2389:
                         enqueue_rooms_list_update(RoomsListUpdate::ClearRooms);
                         enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Clear));
                     } else {
[31m-                        if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Append, old length {}, adding {} new items", all_known_rooms.len(), _num_new_rooms); }
[m[32m+                        if LOG_ROOM_LIST_DIFFS {
[m[32m+                            log!(
[m[32m+                                "room_list: diff Append, old length {}, adding {} new items",
[m[32m+                                all_known_rooms.len(),
[m[32m+                                _num_new_rooms
[m[32m+                            );
[m[32m+                        }
[m                     }

                     // Parallelize creating each room's RoomListServiceRoomInfo and adding that new room.
Diff in /app/src/sliding_sync.rs:2396:
                     // We combine `from_room` and `add_new_room` into a single async task per room.
[31m-                    let new_room_infos: Vec<RoomListServiceRoomInfo> = join_all(
[m[31m-                        new_rooms.into_iter().map(|room| async {
[m[31m-                            let room_info = RoomListServiceRoomInfo::from_room(room.into_inner(), &current_user_id).await;
[m[31m-                            if let Err(e) = add_new_room(&room_info, &room_list_service, false).await {
[m[31m-                                error!("Failed to add new room: {:?} ({}); error: {:?}", room_info.display_name, room_info.room_id, e);
[m[32m+                    let new_room_infos: Vec<RoomListServiceRoomInfo> =
[m[32m+                        join_all(new_rooms.into_iter().map(|room| async {
[m[32m+                            let room_info = RoomListServiceRoomInfo::from_room(
[m[32m+                                room.into_inner(),
[m[32m+                                &current_user_id,
[m[32m+                            )
[m[32m+                            .await;
[m[32m+                            if let Err(e) =
[m[32m+                                add_new_room(&room_info, &room_list_service, false).await
[m[32m+                            {
[m[32m+                                error!(
[m[32m+                                    "Failed to add new room: {:?} ({}); error: {:?}",
[m[32m+                                    room_info.display_name, room_info.room_id, e
[m[32m+                                );
[m                             }
                             room_info
[31m-                        })
[m[31m-                    ).await;
[m[32m+                        }))
[m[32m+                        .await;
[m
                     // Send room order update with the new room IDs
                     let (room_id_refs, room_ids) = {
Diff in /app/src/sliding_sync.rs:2416:
                     };
                     if !room_ids.is_empty() {
                         enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[31m-                            VecDiff::Append { values: room_ids }
[m[32m+                            VecDiff::Append { values: room_ids },
[m                         ));
                         room_list_service.subscribe_to_rooms(&room_id_refs).await;
                         all_known_rooms.extend(new_room_infos);
Diff in /app/src/sliding_sync.rs:2423:
                     }
                 }
                 VectorDiff::Clear => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Clear"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Clear");
[m[32m+                    }
[m                     all_known_rooms.clear();
                     ALL_JOINED_ROOMS.lock().unwrap().clear();
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Clear));
Diff in /app/src/sliding_sync.rs:2430:
                     enqueue_rooms_list_update(RoomsListUpdate::ClearRooms);
                 }
                 VectorDiff::PushFront { value: new_room } => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PushFront"); }
[m[31m-                    let new_room = RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id).await;
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PushFront");
[m[32m+                    }
[m[32m+                    let new_room =
[m[32m+                        RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id)
[m[32m+                            .await;
[m                     let room_id = new_room.room_id.clone();
                     add_new_room(&new_room, &room_list_service, true).await?;
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
Diff in /app/src/sliding_sync.rs:2438:
[31m-                        VecDiff::PushFront { value: room_id }
[m[32m+                        VecDiff::PushFront { value: room_id },
[m                     ));
                     all_known_rooms.push_front(new_room);
                 }
Diff in /app/src/sliding_sync.rs:2442:
                 VectorDiff::PushBack { value: new_room } => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PushBack"); }
[m[31m-                    let new_room = RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id).await;
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PushBack");
[m[32m+                    }
[m[32m+                    let new_room =
[m[32m+                        RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id)
[m[32m+                            .await;
[m                     let room_id = new_room.room_id.clone();
                     add_new_room(&new_room, &room_list_service, true).await?;
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
Diff in /app/src/sliding_sync.rs:2448:
[31m-                        VecDiff::PushBack { value: room_id }
[m[32m+                        VecDiff::PushBack { value: room_id },
[m                     ));
                     all_known_rooms.push_back(new_room);
                 }
Diff in /app/src/sliding_sync.rs:2452:
                 remove_diff @ VectorDiff::PopFront => {
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PopFront"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PopFront");
[m[32m+                    }
[m                     if let Some(room) = all_known_rooms.pop_front() {
[31m-                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PopFront));
[m[32m+                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[32m+                            VecDiff::PopFront,
[m[32m+                        ));
[m                         optimize_remove_then_add_into_update(
                             remove_diff,
                             &room,
Diff in /app/src/sliding_sync.rs:2460:
                             &mut all_known_rooms,
                             &room_list_service,
                             &current_user_id,
[31m-                        ).await?;
[m[32m+                        )
[m[32m+                        .await?;
[m                     }
                 }
                 remove_diff @ VectorDiff::PopBack => {
Diff in /app/src/sliding_sync.rs:2467:
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff PopBack"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff PopBack");
[m[32m+                    }
[m                     if let Some(room) = all_known_rooms.pop_back() {
[31m-                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PopBack));
[m[32m+                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[32m+                            VecDiff::PopBack,
[m[32m+                        ));
[m                         optimize_remove_then_add_into_update(
                             remove_diff,
                             &room,
Diff in /app/src/sliding_sync.rs:2474:
                             &mut all_known_rooms,
                             &room_list_service,
                             &current_user_id,
[31m-                        ).await?;
[m[32m+                        )
[m[32m+                        .await?;
[m                     }
                 }
[31m-                VectorDiff::Insert { index, value: new_room } => {
[m[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Insert at {index}"); }
[m[31m-                    let new_room = RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id).await;
[m[32m+                VectorDiff::Insert {
[m[32m+                    index,
[m[32m+                    value: new_room,
[m[32m+                } => {
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Insert at {index}");
[m[32m+                    }
[m[32m+                    let new_room =
[m[32m+                        RoomListServiceRoomInfo::from_room(new_room.into_inner(), &current_user_id)
[m[32m+                            .await;
[m                     let room_id = new_room.room_id.clone();
                     add_new_room(&new_room, &room_list_service, true).await?;
[31m-                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                        VecDiff::Insert { index, value: room_id }
[m[31m-                    ));
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Insert {
[m[32m+                        index,
[m[32m+                        value: room_id,
[m[32m+                    }));
[m                     all_known_rooms.insert(index, new_room);
                 }
[31m-                VectorDiff::Set { index, value: changed_room } => {
[m[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Set at {index}"); }
[m[31m-                    let changed_room = RoomListServiceRoomInfo::from_room(changed_room.into_inner(), &current_user_id).await;
[m[32m+                VectorDiff::Set {
[m[32m+                    index,
[m[32m+                    value: changed_room,
[m[32m+                } => {
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Set at {index}");
[m[32m+                    }
[m[32m+                    let changed_room = RoomListServiceRoomInfo::from_room(
[m[32m+                        changed_room.into_inner(),
[m[32m+                        &current_user_id,
[m[32m+                    )
[m[32m+                    .await;
[m                     if let Some(old_room) = all_known_rooms.get(index) {
                         update_room(old_room, &changed_room, &room_list_service).await?;
                     } else {
Diff in /app/src/sliding_sync.rs:2496:
                         error!("BUG: room list diff: Set index {index} was out of bounds.");
                     }
                     // Send order update (room ID at this index may have changed)
[31m-                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                        VecDiff::Set { index, value: changed_room.room_id.clone() }
[m[31m-                    ));
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Set {
[m[32m+                        index,
[m[32m+                        value: changed_room.room_id.clone(),
[m[32m+                    }));
[m                     all_known_rooms.set(index, changed_room);
                 }
                 remove_diff @ VectorDiff::Remove { index } => {
Diff in /app/src/sliding_sync.rs:2505:
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Remove at {index}"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Remove at {index}");
[m[32m+                    }
[m                     if index < all_known_rooms.len() {
                         let room = all_known_rooms.remove(index);
[31m-                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Remove { index }));
[m[32m+                        enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[32m+                            VecDiff::Remove { index },
[m[32m+                        ));
[m                         optimize_remove_then_add_into_update(
                             remove_diff,
                             &room,
Diff in /app/src/sliding_sync.rs:2513:
                             &mut all_known_rooms,
                             &room_list_service,
                             &current_user_id,
[31m-                        ).await?;
[m[32m+                        )
[m[32m+                        .await?;
[m                     } else {
[31m-                        error!("BUG: room_list: diff Remove index {index} out of bounds, len {}", all_known_rooms.len());
[m[32m+                        error!(
[m[32m+                            "BUG: room_list: diff Remove index {index} out of bounds, len {}",
[m[32m+                            all_known_rooms.len()
[m[32m+                        );
[m                     }
                 }
                 VectorDiff::Truncate { length } => {
Diff in /app/src/sliding_sync.rs:2522:
[31m-                    if LOG_ROOM_LIST_DIFFS { log!("room_list: diff Truncate to {length}"); }
[m[32m+                    if LOG_ROOM_LIST_DIFFS {
[m[32m+                        log!("room_list: diff Truncate to {length}");
[m[32m+                    }
[m                     // Iterate manually so we can know which rooms are being removed.
                     while all_known_rooms.len() > length {
                         if let Some(room) = all_known_rooms.pop_back() {
Diff in /app/src/sliding_sync.rs:2528:
                     }
                     all_known_rooms.truncate(length); // sanity check
                     enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[31m-                        VecDiff::Truncate { length }
[m[32m+                        VecDiff::Truncate { length },
[m                     ));
                 }
             }
Diff in /app/src/sliding_sync.rs:2538:
     bail!("room list service sync loop ended unexpectedly")
 }

[31m-
[m /// Attempts to optimize a common RoomListService operation of remove + add.
 ///
 /// If a `Remove` diff (or `PopBack` or `PopFront`) is immediately followed by
Diff in /app/src/sliding_sync.rs:2558:
 ) -> Result<()> {
     let next_diff_was_handled: bool;
     match peekable_diffs.peek() {
[31m-        Some(VectorDiff::Insert { index: insert_index, value: new_room })
[m[31m-            if room.room_id == new_room.room_id() =>
[m[31m-        {
[m[32m+        Some(VectorDiff::Insert {
[m[32m+            index: insert_index,
[m[32m+            value: new_room,
[m[32m+        }) if room.room_id == new_room.room_id() => {
[m             if LOG_ROOM_LIST_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + Insert({insert_index}) into Update for room {}", room.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + Insert({insert_index}) into Update for room {}",
[m[32m+                    room.room_id
[m[32m+                );
[m             }
[31m-            let new_room = RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m[32m+            let new_room =
[m[32m+                RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m             update_room(room, &new_room, room_list_service).await?;
             // Send order update for the insert
[31m-            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                VecDiff::Insert { index: *insert_index, value: new_room.room_id.clone() }
[m[31m-            ));
[m[32m+            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::Insert {
[m[32m+                index: *insert_index,
[m[32m+                value: new_room.room_id.clone(),
[m[32m+            }));
[m             all_known_rooms.insert(*insert_index, new_room);
             next_diff_was_handled = true;
         }
Diff in /app/src/sliding_sync.rs:2576:
[31m-        Some(VectorDiff::PushFront { value: new_room })
[m[31m-            if room.room_id == new_room.room_id() =>
[m[31m-        {
[m[32m+        Some(VectorDiff::PushFront { value: new_room }) if room.room_id == new_room.room_id() => {
[m             if LOG_ROOM_LIST_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + PushFront into Update for room {}", room.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + PushFront into Update for room {}",
[m[32m+                    room.room_id
[m[32m+                );
[m             }
[31m-            let new_room = RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m[32m+            let new_room =
[m[32m+                RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m             update_room(room, &new_room, room_list_service).await?;
             // Send order update for the push front
[31m-            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                VecDiff::PushFront { value: new_room.room_id.clone() }
[m[31m-            ));
[m[32m+            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PushFront {
[m[32m+                value: new_room.room_id.clone(),
[m[32m+            }));
[m             all_known_rooms.push_front(new_room);
             next_diff_was_handled = true;
         }
Diff in /app/src/sliding_sync.rs:2591:
[31m-        Some(VectorDiff::PushBack { value: new_room })
[m[31m-            if room.room_id == new_room.room_id() =>
[m[31m-        {
[m[32m+        Some(VectorDiff::PushBack { value: new_room }) if room.room_id == new_room.room_id() => {
[m             if LOG_ROOM_LIST_DIFFS {
[31m-                log!("Optimizing {remove_diff:?} + PushBack into Update for room {}", room.room_id);
[m[32m+                log!(
[m[32m+                    "Optimizing {remove_diff:?} + PushBack into Update for room {}",
[m[32m+                    room.room_id
[m[32m+                );
[m             }
[31m-            let new_room = RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m[32m+            let new_room =
[m[32m+                RoomListServiceRoomInfo::from_room_ref(new_room.deref(), current_user_id).await;
[m             update_room(room, &new_room, room_list_service).await?;
             // Send order update for the push back
[31m-            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(
[m[31m-                VecDiff::PushBack { value: new_room.room_id.clone() }
[m[31m-            ));
[m[32m+            enqueue_rooms_list_update(RoomsListUpdate::RoomOrderUpdate(VecDiff::PushBack {
[m[32m+                value: new_room.room_id.clone(),
[m[32m+            }));
[m             all_known_rooms.push_back(new_room);
             next_diff_was_handled = true;
         }
Diff in /app/src/sliding_sync.rs:2613:
     Ok(())
 }

[31m-
[m /// Invoked when the room list service has received an update that changes an existing room.
 async fn update_room(
     old_room: &RoomListServiceRoomInfo,
Diff in /app/src/sliding_sync.rs:2624:
     if old_room.room_id == new_room_id {
         // Handle state transitions for a room.
         if LOG_ROOM_LIST_DIFFS {
[31m-            log!("Room {:?} ({new_room_id}) state went from {:?} --> {:?}", new_room.display_name, old_room.state, new_room.state);
[m[32m+            log!(
[m[32m+                "Room {:?} ({new_room_id}) state went from {:?} --> {:?}",
[m[32m+                new_room.display_name,
[m[32m+                old_room.state,
[m[32m+                new_room.state
[m[32m+            );
[m         }
         if old_room.state != new_room.state {
             match new_room.state {
Diff in /app/src/sliding_sync.rs:2631:
                 RoomState::Banned => {
                     // TODO: handle rooms that this user has been banned from.
[31m-                    log!("Removing Banned room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "Removing Banned room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     remove_room(new_room);
                     return Ok(());
                 }
Diff in /app/src/sliding_sync.rs:2637:
                 RoomState::Left => {
[31m-                    log!("Removing Left room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "Removing Left room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     // TODO: instead of removing this, we could optionally add it to
                     //       a separate list of left rooms, which would be collapsed by default.
                     //       Upon clicking a left room, we could show a splash page
Diff in /app/src/sliding_sync.rs:2645:
                     return Ok(());
                 }
                 RoomState::Joined => {
[31m-                    log!("update_room(): adding new Joined room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "update_room(): adding new Joined room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     return add_new_room(new_room, room_list_service, true).await;
                 }
                 RoomState::Invited => {
Diff in /app/src/sliding_sync.rs:2652:
[31m-                    log!("update_room(): adding new Invited room: {:?} ({new_room_id})", new_room.display_name);
[m[32m+                    log!(
[m[32m+                        "update_room(): adding new Invited room: {:?} ({new_room_id})",
[m[32m+                        new_room.display_name
[m[32m+                    );
[m                     return add_new_room(new_room, room_list_service, true).await;
                 }
                 RoomState::Knocked => {
Diff in /app/src/sliding_sync.rs:2667:
             spawn_fetch_room_avatar(new_room);
         }
         if old_room.display_name != new_room.display_name {
[31m-            log!("Updating room {} name: {:?} --> {:?}", new_room_id, old_room.display_name, new_room.display_name);
[m[32m+            log!(
[m[32m+                "Updating room {} name: {:?} --> {:?}",
[m[32m+                new_room_id,
[m[32m+                old_room.display_name,
[m[32m+                new_room.display_name
[m[32m+            );
[m
             enqueue_rooms_list_update(RoomsListUpdate::UpdateRoomName {
                 new_room_name: (new_room.display_name.clone(), new_room_id.clone()).into(),
Diff in /app/src/sliding_sync.rs:2677:
         // Then, we check for changes to room data that is only relevant to joined rooms:
         // including the latest event, tags, unread counts, is_direct, tombstoned state, power levels, etc.
         // Invited or left rooms don't care about these details.
[31m-        if matches!(new_room.state, RoomState::Joined) {
[m[32m+        if matches!(new_room.state, RoomState::Joined) {
[m             // For some reason, the latest event API does not reliably catch *all* changes
             // to the latest event in a given room, such as redactions.
             // Thus, we have to re-obtain the latest event on *every* update, regardless of timestamp.
Diff in /app/src/sliding_sync.rs:2684:
             //
[31m-            let update_latest = match (old_room.latest_event_timestamp, new_room.room.latest_event_timestamp()) {
[m[32m+            let update_latest = match (
[m[32m+                old_room.latest_event_timestamp,
[m[32m+                new_room.room.latest_event_timestamp(),
[m[32m+            ) {
[m                 (Some(old_ts), Some(new_ts)) => new_ts >= old_ts,
                 (None, Some(_)) => true,
                 _ => false,
Diff in /app/src/sliding_sync.rs:2691:
                 update_latest_event(&new_room.room).await;
             }

[31m-
[m             if old_room.tags != new_room.tags {
[31m-                log!("Updating room {} tags from {:?} to {:?}", new_room_id, old_room.tags, new_room.tags);
[m[32m+                log!(
[m[32m+                    "Updating room {} tags from {:?} to {:?}",
[m[32m+                    new_room_id,
[m[32m+                    old_room.tags,
[m[32m+                    new_room.tags
[m[32m+                );
[m                 enqueue_rooms_list_update(RoomsListUpdate::Tags {
                     room_id: new_room_id.clone(),
                     new_tags: new_room.tags.clone().unwrap_or_default(),
Diff in /app/src/sliding_sync.rs:2704:
                 || old_room.num_unread_messages != new_room.num_unread_messages
                 || old_room.num_unread_mentions != new_room.num_unread_mentions
             {
[31m-                log!("Updating room {}, marked unread {} --> {}, unread messages {} --> {}, unread mentions {} --> {}",
[m[32m+                log!(
[m[32m+                    "Updating room {}, marked unread {} --> {}, unread messages {} --> {}, unread mentions {} --> {}",
[m                     new_room_id,
[31m-                    old_room.is_marked_unread, new_room.is_marked_unread,
[m[31m-                    old_room.num_unread_messages, new_room.num_unread_messages,
[m[31m-                    old_room.num_unread_mentions, new_room.num_unread_mentions,
[m[32m+                    old_room.is_marked_unread,
[m[32m+                    new_room.is_marked_unread,
[m[32m+                    old_room.num_unread_messages,
[m[32m+                    new_room.num_unread_messages,
[m[32m+                    old_room.num_unread_mentions,
[m[32m+                    new_room.num_unread_mentions,
[m                 );
                 enqueue_rooms_list_update(RoomsListUpdate::UpdateNumUnreadMessages {
                     room_id: new_room_id.clone(),
Diff in /app/src/sliding_sync.rs:2719:
             }

             if old_room.is_direct != new_room.is_direct {
[31m-                log!("Updating room {} is_direct from {} to {}",
[m[32m+                log!(
[m[32m+                    "Updating room {} is_direct from {} to {}",
[m                     new_room_id,
                     old_room.is_direct,
                     new_room.is_direct,
Diff in /app/src/sliding_sync.rs:2743:
             if !old_room.is_tombstoned && new_room.is_tombstoned {
                 let successor_room = new_room.room.successor_room();
                 log!("Updating room {new_room_id} to be tombstoned, {successor_room:?}");
[31m-                enqueue_rooms_list_update(RoomsListUpdate::TombstonedRoom { room_id: new_room_id.clone() });
[m[32m+                enqueue_rooms_list_update(RoomsListUpdate::TombstonedRoom {
[m[32m+                    room_id: new_room_id.clone(),
[m[32m+                });
[m                 if let Some(timeline_update_sender) = get_timeline_update_sender(&new_room_id) {
                     spawn_fetch_successor_room_preview(
                         room_list_service.client().clone(),
Diff in /app/src/sliding_sync.rs:2752:
                         timeline_update_sender,
                     );
                 } else {
[31m-                    error!("BUG: could not find JoinedRoomDetails for newly-tombstoned room {new_room_id}");
[m[32m+                    error!(
[m[32m+                        "BUG: could not find JoinedRoomDetails for newly-tombstoned room {new_room_id}"
[m[32m+                    );
[m                 }
             }

Diff in /app/src/sliding_sync.rs:2763:
                     log!("Updating room {new_room_id} user power levels.");
                     match timeline_update_sender.send(TimelineUpdate::UserPowerLevels(nupl)) {
                         Ok(_) => SignalToUI::set_ui_signal(),
[31m-                        Err(_) => error!("Failed to send the UserPowerLevels update to room {new_room_id}"),
[m[32m+                        Err(_) => error!(
[m[32m+                            "Failed to send the UserPowerLevels update to room {new_room_id}"
[m[32m+                        ),
[m                     }
                 } else {
[31m-                    error!("BUG: could not find JoinedRoomDetails for room {new_room_id} where power levels changed.");
[m[32m+                    error!(
[m[32m+                        "BUG: could not find JoinedRoomDetails for room {new_room_id} where power levels changed."
[m[32m+                    );
[m                 }
             }
         }
Diff in /app/src/sliding_sync.rs:2773:
         Ok(())
[31m-    }
[m[31m-    else {
[m[31m-        warning!("UNTESTED SCENARIO: update_room(): removing old room {}, replacing with new room {}",
[m[31m-            old_room.room_id, new_room_id,
[m[32m+    } else {
[m[32m+        warning!(
[m[32m+            "UNTESTED SCENARIO: update_room(): removing old room {}, replacing with new room {}",
[m[32m+            old_room.room_id,
[m[32m+            new_room_id,
[m         );
         remove_room(old_room);
         add_new_room(new_room, room_list_service, true).await
Diff in /app/src/sliding_sync.rs:2781:
     }
 }

[31m-
[m /// Invoked when the room list service has received an update to remove an existing room.
 fn remove_room(room: &RoomListServiceRoomInfo) {
     ALL_JOINED_ROOMS.lock().unwrap().remove(&room.room_id);
Diff in /app/src/sliding_sync.rs:2788:
[31m-    enqueue_rooms_list_update(
[m[31m-        RoomsListUpdate::RemoveRoom {
[m[31m-            room_id: room.room_id.clone(),
[m[31m-            new_state: room.state,
[m[31m-        }
[m[31m-    );
[m[32m+    enqueue_rooms_list_update(RoomsListUpdate::RemoveRoom {
[m[32m+        room_id: room.room_id.clone(),
[m[32m+        new_state: room.state,
[m[32m+    });
[m }

[31m-
[m /// Invoked when the room list service has received an update with a brand new room.
 async fn add_new_room(
     new_room: &RoomListServiceRoomInfo,
Diff in /app/src/sliding_sync.rs:2802:
 ) -> Result<()> {
     match new_room.state {
         RoomState::Knocked => {
[31m-            log!("Got new Knocked room: {:?} ({})", new_room.display_name, new_room.room_id);
[m[32m+            log!(
[m[32m+                "Got new Knocked room: {:?} ({})",
[m[32m+                new_room.display_name,
[m[32m+                new_room.room_id
[m[32m+            );
[m             // Note: here we could optionally display Knocked rooms as a separate type of room
             //       in the rooms list, but it's not really necessary at this point.
             return Ok(());
Diff in /app/src/sliding_sync.rs:2809:
         }
         RoomState::Banned => {
[31m-            log!("Got new Banned room: {:?} ({})", new_room.display_name, new_room.room_id);
[m[32m+            log!(
[m[32m+                "Got new Banned room: {:?} ({})",
[m[32m+                new_room.display_name,
[m[32m+                new_room.room_id
[m[32m+            );
[m             // Note: here we could optionally display Banned rooms as a separate type of room
             //       in the rooms list, but it's not really necessary at this point.
             return Ok(());
Diff in /app/src/sliding_sync.rs:2815:
         }
         RoomState::Left => {
[31m-            log!("Got new Left room: {:?} ({:?})", new_room.display_name, new_room.room_id);
[m[32m+            log!(
[m[32m+                "Got new Left room: {:?} ({:?})",
[m[32m+                new_room.display_name,
[m[32m+                new_room.room_id
[m[32m+            );
[m             // Note: here we could optionally display Left rooms as a separate type of room
             //       in the rooms list, but it's not really necessary at this point.
             return Ok(());
Diff in /app/src/sliding_sync.rs:2821:
         }
         RoomState::Invited => {
             let invite_details = new_room.room.invite_details().await.ok();
[31m-            let room_name_id = RoomNameId::from((new_room.display_name.clone(), new_room.room_id.clone()));
[m[32m+            let room_name_id =
[m[32m+                RoomNameId::from((new_room.display_name.clone(), new_room.room_id.clone()));
[m             let room_avatar = room_avatar(&new_room.room, &room_name_id).await;
             let inviter_info = if let Some(inviter) = invite_details.and_then(|d| d.inviter) {
                 Some(InviterInfo {
Diff in /app/src/sliding_sync.rs:2837:
             } else {
                 None
             };
[31m-            rooms_list::enqueue_rooms_list_update(RoomsListUpdate::AddInvitedRoom(InvitedRoomInfo {
[m[31m-                room_name_id: room_name_id.clone(),
[m[31m-                inviter_info,
[m[31m-                room_avatar,
[m[31m-                canonical_alias: new_room.room.canonical_alias(),
[m[31m-                alt_aliases: new_room.room.alt_aliases(),
[m[31m-                // we don't actually display the latest event for Invited rooms, so don't bother.
[m[31m-                latest: None,
[m[31m-                invite_state: Default::default(),
[m[31m-                is_selected: false,
[m[31m-                is_direct: new_room.is_direct,
[m[31m-            }));
[m[32m+            rooms_list::enqueue_rooms_list_update(RoomsListUpdate::AddInvitedRoom(
[m[32m+                InvitedRoomInfo {
[m[32m+                    room_name_id: room_name_id.clone(),
[m[32m+                    inviter_info,
[m[32m+                    room_avatar,
[m[32m+                    canonical_alias: new_room.room.canonical_alias(),
[m[32m+                    alt_aliases: new_room.room.alt_aliases(),
[m[32m+                    // we don't actually display the latest event for Invited rooms, so don't bother.
[m[32m+                    latest: None,
[m[32m+                    invite_state: Default::default(),
[m[32m+                    is_selected: false,
[m[32m+                    is_direct: new_room.is_direct,
[m[32m+                },
[m[32m+            ));
[m             Cx::post_action(AppStateAction::RoomLoadedSuccessfully {
                 room_name_id,
                 is_invite: true,
Diff in /app/src/sliding_sync.rs:2855:
             });
             return Ok(());
         }
[31m-        RoomState::Joined => { } // Fall through to adding the joined room below.
[m[32m+        RoomState::Joined => {} // Fall through to adding the joined room below.
[m     }

     // If we didn't already subscribe to this room, do so now.
Diff in /app/src/sliding_sync.rs:2862:
     // This ensures we will properly receive all of its states and latest event.
     if subscribe {
[31m-        room_list_service.subscribe_to_rooms(&[&new_room.room_id]).await;
[m[32m+        room_list_service
[m[32m+            .subscribe_to_rooms(&[&new_room.room_id])
[m[32m+            .await;
[m     }

     let timeline = Arc::new(
Diff in /app/src/sliding_sync.rs:2868:
[31m-        new_room.room.timeline_builder()
[m[32m+        new_room
[m[32m+            .room
[m[32m+            .timeline_builder()
[m             .track_read_marker_and_receipts(TimelineReadReceiptTracking::AllEvents)
             .build()
             .await
Diff in /app/src/sliding_sync.rs:2872:
[31m-            .map_err(|e| anyhow::anyhow!("BUG: Failed to build timeline for room {}: {e}", new_room.room_id))?,
[m[32m+            .map_err(|e| {
[m[32m+                anyhow::anyhow!(
[m[32m+                    "BUG: Failed to build timeline for room {}: {e}",
[m[32m+                    new_room.room_id
[m[32m+                )
[m[32m+            })?,
[m     );
     let (timeline_update_sender, timeline_update_receiver) = crossbeam_channel::unbounded();

Diff in /app/src/sliding_sync.rs:2884:
     // We need to add the room to the `ALL_JOINED_ROOMS` list before we can send
     // an `AddJoinedRoom` update to the RoomsList widget, because that widget might
     // immediately issue a `MatrixRequest` that relies on that room being in `ALL_JOINED_ROOMS`.
[31m-    log!("Adding new joined room {}, name: {:?}", new_room.room_id, new_room.display_name);
[m[32m+    log!(
[m[32m+        "Adding new joined room {}, name: {:?}",
[m[32m+        new_room.room_id,
[m[32m+        new_room.display_name
[m[32m+    );
[m     ALL_JOINED_ROOMS.lock().unwrap().insert(
         new_room.room_id.clone(),
         JoinedRoomDetails {
Diff in /app/src/sliding_sync.rs:2901:
     let latest = get_latest_event_details(
         &new_room.room.latest_event().await,
         room_list_service.client(),
[31m-    ).await;
[m[32m+    )
[m[32m+    .await;
[m     let room_name_id = RoomNameId::from((new_room.display_name.clone(), new_room.room_id.clone()));
     // Start with a basic text avatar; the avatar image will be fetched asynchronously below.
     let room_avatar = avatar_from_room_name(room_name_id.name_for_avatar().as_deref());
Diff in /app/src/sliding_sync.rs:2932:
 #[allow(unused)]
 async fn current_ignore_user_list(client: &Client) -> Option<HashSet<OwnedUserId>> {
     use matrix_sdk::ruma::events::ignored_user_list::IgnoredUserListEventContent;
[31m-    let ignored_users = client.account()
[m[32m+    let ignored_users = client
[m[32m+        .account()
[m         .account_data::<IgnoredUserListEventContent>()
         .await
         .ok()??
Diff in /app/src/sliding_sync.rs:2994:
                     && !app_state.saved_dock_state_home.dock_items.is_empty()
                 {
                     log!("Loaded room panel state from app data directory. Restoring now...");
[31m-                    Cx::post_action(AppStateAction::RestoreAppStateFromPersistentState(app_state));
[m[32m+                    Cx::post_action(AppStateAction::RestoreAppStateFromPersistentState(
[m[32m+                        app_state,
[m[32m+                    ));
[m                 }
             }
             Err(_e) => {
Diff in /app/src/sliding_sync.rs:3038:
     const SYNC_INDICATOR_DELAY: Duration = Duration::from_millis(100);
     /// Duration for sync indicator delay before hiding
     const SYNC_INDICATOR_HIDE_DELAY: Duration = Duration::from_millis(200);
[31m-    let sync_indicator_stream = sync_service.room_list_service()
[m[31m-        .sync_indicator(
[m[31m-            SYNC_INDICATOR_DELAY,
[m[31m-            SYNC_INDICATOR_HIDE_DELAY
[m[31m-        );
[m[31m-
[m[32m+    let sync_indicator_stream = sync_service
[m[32m+        .room_list_service()
[m[32m+        .sync_indicator(SYNC_INDICATOR_DELAY, SYNC_INDICATOR_HIDE_DELAY);
[m[32m+
[m     Handle::current().spawn(async move {
[31m-       let mut sync_indicator_stream = std::pin::pin!(sync_indicator_stream);
[m[32m+        let mut sync_indicator_stream = std::pin::pin!(sync_indicator_stream);
[m
         while let Some(indicator) = sync_indicator_stream.next().await {
             let is_syncing = match indicator {
Diff in /app/src/sliding_sync.rs:3058:
 }

 fn handle_room_list_service_loading_state(mut loading_state: Subscriber<RoomListLoadingState>) {
[31m-    log!("Initial room list loading state is {:?}", loading_state.get());
[m[32m+    log!(
[m[32m+        "Initial room list loading state is {:?}",
[m[32m+        loading_state.get()
[m[32m+    );
[m     Handle::current().spawn(async move {
         while let Some(state) = loading_state.next().await {
             log!("Received a room list loading state update: {state:?}");
Diff in /app/src/sliding_sync.rs:3066:
                 RoomListLoadingState::NotLoaded => {
                     enqueue_rooms_list_update(RoomsListUpdate::NotLoaded);
                 }
[31m-                RoomListLoadingState::Loaded { maximum_number_of_rooms } => {
[m[31m-                    enqueue_rooms_list_update(RoomsListUpdate::LoadedRooms { max_rooms: maximum_number_of_rooms });
[m[32m+                RoomListLoadingState::Loaded {
[m[32m+                    maximum_number_of_rooms,
[m[32m+                } => {
[m[32m+                    enqueue_rooms_list_update(RoomsListUpdate::LoadedRooms {
[m[32m+                        max_rooms: maximum_number_of_rooms,
[m[32m+                    });
[m                     // The SDK docs state that we cannot move from the `Loaded` state
                     // back to the `NotLoaded` state, so we can safely exit this task here.
                     return;
Diff in /app/src/sliding_sync.rs:3090:
     Handle::current().spawn(async move {
         log!("Updating room {tombstoned_room_id} to be tombstoned, {successor_room:?}");
         let srd = if let Some(SuccessorRoom { room_id, reason }) = successor_room {
[31m-            match fetch_room_preview_with_avatar(
[m[31m-                &client,
[m[31m-                room_id.deref().into(),
[m[31m-                Vec::new(),
[m[31m-            ).await {
[m[31m-                Ok(room_preview) => SuccessorRoomDetails::Full { room_preview, reason },
[m[32m+            match fetch_room_preview_with_avatar(&client, room_id.deref().into(), Vec::new()).await
[m[32m+            {
[m[32m+                Ok(room_preview) => SuccessorRoomDetails::Full {
[m[32m+                    room_preview,
[m[32m+                    reason,
[m[32m+                },
[m                 Err(e) => {
                     log!("Failed to fetch preview of successor room {room_id}, error: {e:?}");
                     SuccessorRoomDetails::Basic(SuccessorRoom { room_id, reason })
Diff in /app/src/sliding_sync.rs:3129:
         };
         match client.media().get_media_content(&media_request, true).await {
             Ok(avatar_content) => {
[31m-                log!("Fetched avatar for room preview {:?} ({})", room_preview.name, room_preview.room_id);
[m[32m+                log!(
[m[32m+                    "Fetched avatar for room preview {:?} ({})",
[m[32m+                    room_preview.name,
[m[32m+                    room_preview.room_id
[m[32m+                );
[m                 FetchedRoomAvatar::Image(avatar_content.into())
             }
             Err(e) => {
Diff in /app/src/sliding_sync.rs:3136:
[31m-                log!("Failed to fetch avatar for room preview {:?} ({}), error: {e:?}",
[m[31m-                    room_preview.name, room_preview.room_id
[m[32m+                log!(
[m[32m+                    "Failed to fetch avatar for room preview {:?} ({}), error: {e:?}",
[m[32m+                    room_preview.name,
[m[32m+                    room_preview.room_id
[m                 );
                 avatar_from_room_name(room_preview.name.as_deref())
             }
Diff in /app/src/sliding_sync.rs:3146:
     Ok(FetchedRoomPreview::from(room_preview, room_avatar))
 }

[31m-
[m /// Returns the timestamp and an HTML-formatted text preview of the given `latest_event`.
 ///
 /// If the sender profile of the event is not yet available, this function will
Diff in /app/src/sliding_sync.rs:3170:

     match latest_event_value {
         LatestEventValue::None => None,
[31m-        LatestEventValue::Remote { timestamp, sender, is_own, profile, content } => {
[m[32m+        LatestEventValue::Remote {
[m[32m+            timestamp,
[m[32m+            sender,
[m[32m+            is_own,
[m[32m+            profile,
[m[32m+            content,
[m[32m+        } => {
[m             let sender_username = get_sender_username!(profile, sender, *is_own);
[31m-            let latest_message_text = text_preview_of_timeline_item(
[m[31m-                content,
[m[31m-                sender,
[m[31m-                &sender_username,
[m[31m-            ).format_with(&sender_username, true);
[m[32m+            let latest_message_text =
[m[32m+                text_preview_of_timeline_item(content, sender, &sender_username)
[m[32m+                    .format_with(&sender_username, true);
[m             Some((*timestamp, latest_message_text))
         }
[31m-        LatestEventValue::Local { timestamp, sender, profile, content, state: _ } => {
[m[32m+        LatestEventValue::Local {
[m[32m+            timestamp,
[m[32m+            sender,
[m[32m+            profile,
[m[32m+            content,
[m[32m+            state: _,
[m[32m+        } => {
[m             // TODO: use the `state` enum to augment the preview text with more details.
             //       Example: "<span color="blue">Sending... {msg}</span>" or
             //                "<span color="red">Failed to send {msg}</span>"
Diff in /app/src/sliding_sync.rs:3186:
             let is_own = current_user_id().is_some_and(|id| &id == sender);
             let sender_username = get_sender_username!(profile, sender, is_own);
[31m-            let latest_message_text = text_preview_of_timeline_item(
[m[31m-                content,
[m[31m-                sender,
[m[31m-                &sender_username,
[m[31m-            ).format_with(&sender_username, true);
[m[32m+            let latest_message_text =
[m[32m+                text_preview_of_timeline_item(content, sender, &sender_username)
[m[32m+                    .format_with(&sender_username, true);
[m             Some((*timestamp, latest_message_text))
         }
[31m-    }
[m[32m+    }
[m }

 /// Handles the given updated latest event for the given room.
Diff in /app/src/sliding_sync.rs:3200:
 /// This function sends a `RoomsListUpdate::UpdateLatestEvent`
 /// to update the latest event in the RoomsListEntry for the given room.
 async fn update_latest_event(room: &Room) {
[31m-    if let Some((timestamp, latest_message_text)) = get_latest_event_details(
[m[31m-        &room.latest_event().await,
[m[31m-        &room.client(),
[m[31m-    ).await {
[m[32m+    if let Some((timestamp, latest_message_text)) =
[m[32m+        get_latest_event_details(&room.latest_event().await, &room.client()).await
[m[32m+    {
[m         enqueue_rooms_list_update(RoomsListUpdate::UpdateLatestEvent {
             room_id: room.room_id().to_owned(),
             timestamp,
Diff in /app/src/sliding_sync.rs:3238:
     timeline_update_sender: crossbeam_channel::Sender<TimelineUpdate>,
     mut request_receiver: watch::Receiver<Vec<BackwardsPaginateUntilEventRequest>>,
 ) {
[31m-
[m     /// An inner function that searches the given new timeline items for a target event.
     ///
     /// If the target event is found, it is removed from the `target_event_id_opt` and returned,
Diff in /app/src/sliding_sync.rs:3247:
         target_event_id_opt: &mut Option<OwnedEventId>,
         mut new_items_iter: impl Iterator<Item = &'a Arc<TimelineItem>>,
     ) -> Option<(usize, OwnedEventId)> {
[31m-        let found_index = target_event_id_opt
[m[31m-            .as_ref()
[m[31m-            .and_then(|target_event_id| new_items_iter
[m[31m-                .position(|new_item| new_item
[m[32m+        let found_index = target_event_id_opt.as_ref().and_then(|target_event_id| {
[m[32m+            new_items_iter.position(|new_item| {
[m[32m+                new_item
[m                     .as_event()
                     .is_some_and(|new_ev| new_ev.event_id() == Some(target_event_id))
[31m-                )
[m[31m-            );
[m[32m+            })
[m[32m+        });
[m
         if let Some(index) = found_index {
             target_event_id_opt.take().map(|ev| (index, ev))
Diff in /app/src/sliding_sync.rs:3263:
         }
     }

[31m-
[m     let room_id = room.room_id().to_owned();
     log!("Starting timeline subscriber for room {room_id}...");
     let (mut timeline_items, mut subscriber) = timeline.subscribe().await;
Diff in /app/src/sliding_sync.rs:3270:
[31m-    log!("Received initial timeline update of {} items for room {room_id}.", timeline_items.len());
[m[32m+    log!(
[m[32m+        "Received initial timeline update of {} items for room {room_id}.",
[m[32m+        timeline_items.len()
[m[32m+    );
[m
     timeline_update_sender.send(TimelineUpdate::FirstUpdate {
         initial_items: timeline_items.clone(),
Diff in /app/src/sliding_sync.rs:3280:
     // the timeline index and event ID of the target event, if it has been found.
     let mut found_target_event_id: Option<(usize, OwnedEventId)> = None;

[31m-    loop { tokio::select! {
[m[31m-        // we should check for new requests before handling new timeline updates,
[m[31m-        // because the request might influence how we handle a timeline update.
[m[31m-        biased;
[m[32m+    loop {
[m[32m+        tokio::select! {
[m[32m+            // we should check for new requests before handling new timeline updates,
[m[32m+            // because the request might influence how we handle a timeline update.
[m[32m+            biased;
[m
[31m-        // Handle updates to the current backwards pagination requests.
[m[31m-        Ok(()) = request_receiver.changed() => {
[m[31m-            let prev_target_event_id = target_event_id.clone();
[m[31m-            let new_request_details = request_receiver
[m[31m-                .borrow_and_update()
[m[31m-                .iter()
[m[31m-                .find_map(|req| req.room_id
[m[31m-                    .eq(&room_id)
[m[31m-                    .then(|| (req.target_event_id.clone(), req.starting_index, req.current_tl_len))
[m[31m-                );
[m[32m+            // Handle updates to the current backwards pagination requests.
[m[32m+            Ok(()) = request_receiver.changed() => {
[m[32m+                let prev_target_event_id = target_event_id.clone();
[m[32m+                let new_request_details = request_receiver
[m[32m+                    .borrow_and_update()
[m[32m+                    .iter()
[m[32m+                    .find_map(|req| req.room_id
[m[32m+                        .eq(&room_id)
[m[32m+                        .then(|| (req.target_event_id.clone(), req.starting_index, req.current_tl_len))
[m[32m+                    );
[m
[31m-            target_event_id = new_request_details.as_ref().map(|(ev, ..)| ev.clone());
[m[32m+                target_event_id = new_request_details.as_ref().map(|(ev, ..)| ev.clone());
[m
[31m-            // If we received a new request, start searching backwards for the target event.
[m[31m-            if let Some((new_target_event_id, starting_index, current_tl_len)) = new_request_details {
[m[31m-                if prev_target_event_id.as_ref() != Some(&new_target_event_id) {
[m[31m-                    let starting_index = if current_tl_len == timeline_items.len() {
[m[31m-                        starting_index
[m[31m-                    } else {
[m[31m-                        // The timeline has changed since the request was made, so we can't rely on the `starting_index`.
[m[31m-                        // Instead, we have no choice but to start from the end of the timeline.
[m[31m-                        timeline_items.len()
[m[31m-                    };
[m[31m-                    // log!("Received new request to search for event {new_target_event_id} in room {room_id} starting from index {starting_index} (tl len {}).", timeline_items.len());
[m[31m-                    // Search backwards for the target event in the timeline, starting from the given index.
[m[31m-                    if let Some(target_event_tl_index) = timeline_items
[m[31m-                        .focus()
[m[31m-                        .narrow(..starting_index)
[m[31m-                        .into_iter()
[m[31m-                        .rev()
[m[31m-                        .position(|i| i.as_event()
[m[31m-                            .and_then(|e| e.event_id())
[m[31m-                            .is_some_and(|ev_id| ev_id == new_target_event_id)
[m[31m-                        )
[m[31m-                        .map(|i| starting_index.saturating_sub(i).saturating_sub(1))
[m[31m-                    {
[m[31m-                        // log!("Found existing target event {new_target_event_id} in room {room_id} at index {target_event_tl_index}.");
[m[32m+                // If we received a new request, start searching backwards for the target event.
[m[32m+                if let Some((new_target_event_id, starting_index, current_tl_len)) = new_request_details {
[m[32m+                    if prev_target_event_id.as_ref() != Some(&new_target_event_id) {
[m[32m+                        let starting_index = if current_tl_len == timeline_items.len() {
[m[32m+                            starting_index
[m[32m+                        } else {
[m[32m+                            // The timeline has changed since the request was made, so we can't rely on the `starting_index`.
[m[32m+                            // Instead, we have no choice but to start from the end of the timeline.
[m[32m+                            timeline_items.len()
[m[32m+                        };
[m[32m+                        // log!("Received new request to search for event {new_target_event_id} in room {room_id} starting from index {starting_index} (tl len {}).", timeline_items.len());
[m[32m+                        // Search backwards for the target event in the timeline, starting from the given index.
[m[32m+                        if let Some(target_event_tl_index) = timeline_items
[m[32m+                            .focus()
[m[32m+                            .narrow(..starting_index)
[m[32m+                            .into_iter()
[m[32m+                            .rev()
[m[32m+                            .position(|i| i.as_event()
[m[32m+                                .and_then(|e| e.event_id())
[m[32m+                                .is_some_and(|ev_id| ev_id == new_target_event_id)
[m[32m+                            )
[m[32m+                            .map(|i| starting_index.saturating_sub(i).saturating_sub(1))
[m[32m+                        {
[m[32m+                            // log!("Found existing target event {new_target_event_id} in room {room_id} at index {target_event_tl_index}.");
[m
[31m-                        // Nice! We found the target event in the current timeline items,
[m[31m-                        // so there's no need to actually proceed with backwards pagination;
[m[31m-                        // thus, we can clear the locally-tracked target event ID.
[m[31m-                        target_event_id = None;
[m[31m-                        found_target_event_id = None;
[m[31m-                        timeline_update_sender.send(
[m[31m-                            TimelineUpdate::TargetEventFound {
[m[31m-                                target_event_id: new_target_event_id.clone(),
[m[31m-                                index: target_event_tl_index,
[m[31m-                            }
[m[31m-                        ).unwrap_or_else(
[m[31m-                            |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({new_target_event_id}, {target_event_tl_index}) to room {room_id}!")
[m[31m-                        );
[m[31m-                        // Send a Makepad-level signal to update this room's timeline UI view.
[m[31m-                        SignalToUI::set_ui_signal();
[m[32m+                            // Nice! We found the target event in the current timeline items,
[m[32m+                            // so there's no need to actually proceed with backwards pagination;
[m[32m+                            // thus, we can clear the locally-tracked target event ID.
[m[32m+                            target_event_id = None;
[m[32m+                            found_target_event_id = None;
[m[32m+                            timeline_update_sender.send(
[m[32m+                                TimelineUpdate::TargetEventFound {
[m[32m+                                    target_event_id: new_target_event_id.clone(),
[m[32m+                                    index: target_event_tl_index,
[m[32m+                                }
[m[32m+                            ).unwrap_or_else(
[m[32m+                                |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({new_target_event_id}, {target_event_tl_index}) to room {room_id}!")
[m[32m+                            );
[m[32m+                            // Send a Makepad-level signal to update this room's timeline UI view.
[m[32m+                            SignalToUI::set_ui_signal();
[m[32m+                        }
[m[32m+                        else {
[m[32m+                            log!("Target event not in timeline. Starting backwards pagination \
[m[32m+                                in room {room_id} to find target event {new_target_event_id} \
[m[32m+                                starting from index {starting_index}.",
[m[32m+                            );
[m[32m+                            // If we didn't find the target event in the current timeline items,
[m[32m+                            // we need to start loading previous items into the timeline.
[m[32m+                            submit_async_request(MatrixRequest::PaginateRoomTimeline {
[m[32m+                                room_id: room_id.clone(),
[m[32m+                                num_events: 50,
[m[32m+                                direction: PaginationDirection::Backwards,
[m[32m+                            });
[m[32m+                        }
[m                     }
[31m-                    else {
[m[31m-                        log!("Target event not in timeline. Starting backwards pagination \
[m[31m-                            in room {room_id} to find target event {new_target_event_id} \
[m[31m-                            starting from index {starting_index}.",
[m[31m-                        );
[m[31m-                        // If we didn't find the target event in the current timeline items,
[m[31m-                        // we need to start loading previous items into the timeline.
[m[31m-                        submit_async_request(MatrixRequest::PaginateRoomTimeline {
[m[31m-                            room_id: room_id.clone(),
[m[31m-                            num_events: 50,
[m[31m-                            direction: PaginationDirection::Backwards,
[m[31m-                        });
[m[31m-                    }
[m                 }
             }
[31m-        }
[m
[31m-        // Handle updates to the actual timeline content.
[m[31m-        batch_opt = subscriber.next() => {
[m[31m-            let Some(batch) = batch_opt else { break };
[m[31m-            let mut num_updates = 0;
[m[31m-            let mut index_of_first_change = usize::MAX;
[m[31m-            let mut index_of_last_change = usize::MIN;
[m[31m-            // whether to clear the entire cache of drawn items
[m[31m-            let mut clear_cache = false;
[m[31m-            // whether the changes include items being appended to the end of the timeline
[m[31m-            let mut is_append = false;
[m[31m-            for diff in batch {
[m[31m-                num_updates += 1;
[m[31m-                match diff {
[m[31m-                    VectorDiff::Append { values } => {
[m[31m-                        let _values_len = values.len();
[m[31m-                        index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[31m-                        timeline_items.extend(values);
[m[31m-                        index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Append {_values_len}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                        is_append = true;
[m[31m-                    }
[m[31m-                    VectorDiff::Clear => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Clear"); }
[m[31m-                        clear_cache = true;
[m[31m-                        timeline_items.clear();
[m[31m-                    }
[m[31m-                    VectorDiff::PushFront { value } => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushFront"); }
[m[31m-                        if let Some((index, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            *index += 1; // account for this new `value` being prepended.
[m[31m-                        } else {
[m[31m-                            found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value));
[m[32m+            // Handle updates to the actual timeline content.
[m[32m+            batch_opt = subscriber.next() => {
[m[32m+                let Some(batch) = batch_opt else { break };
[m[32m+                let mut num_updates = 0;
[m[32m+                let mut index_of_first_change = usize::MAX;
[m[32m+                let mut index_of_last_change = usize::MIN;
[m[32m+                // whether to clear the entire cache of drawn items
[m[32m+                let mut clear_cache = false;
[m[32m+                // whether the changes include items being appended to the end of the timeline
[m[32m+                let mut is_append = false;
[m[32m+                for diff in batch {
[m[32m+                    num_updates += 1;
[m[32m+                    match diff {
[m[32m+                        VectorDiff::Append { values } => {
[m[32m+                            let _values_len = values.len();
[m[32m+                            index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[32m+                            timeline_items.extend(values);
[m[32m+                            index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Append {_values_len}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                            is_append = true;
[m                         }
[31m-
[m[31m-                        clear_cache = true;
[m[31m-                        timeline_items.push_front(value);
[m[31m-                    }
[m[31m-                    VectorDiff::PushBack { value } => {
[m[31m-                        index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[31m-                        timeline_items.push_back(value);
[m[31m-                        index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                        is_append = true;
[m[31m-                    }
[m[31m-                    VectorDiff::PopFront => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopFront"); }
[m[31m-                        clear_cache = true;
[m[31m-                        timeline_items.pop_front();
[m[31m-                        if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            *i = i.saturating_sub(1); // account for the first item being removed.
[m[32m+                        VectorDiff::Clear => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Clear"); }
[m[32m+                            clear_cache = true;
[m[32m+                            timeline_items.clear();
[m                         }
[31m-                        // This doesn't affect whether we should reobtain the latest event.
[m[31m-                    }
[m[31m-                    VectorDiff::PopBack => {
[m[31m-                        timeline_items.pop_back();
[m[31m-                        index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[31m-                        index_of_last_change = usize::MAX;
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Insert { index, value } => {
[m[31m-                        if index == 0 {
[m[32m+                        VectorDiff::PushFront { value } => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushFront"); }
[m[32m+                            if let Some((index, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                *index += 1; // account for this new `value` being prepended.
[m[32m+                            } else {
[m[32m+                                found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value));
[m[32m+                            }
[m[32m+
[m                             clear_cache = true;
[31m-                        } else {
[m[31m-                            index_of_first_change = min(index_of_first_change, index);
[m[31m-                            index_of_last_change = usize::MAX;
[m[32m+                            timeline_items.push_front(value);
[m                         }
[31m-                        if index >= timeline_items.len() {
[m[32m+                        VectorDiff::PushBack { value } => {
[m[32m+                            index_of_first_change = min(index_of_first_change, timeline_items.len());
[m[32m+                            timeline_items.push_back(value);
[m[32m+                            index_of_last_change = max(index_of_last_change, timeline_items.len());
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PushBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                             is_append = true;
                         }
[31m-
[m[31m-                        if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            // account for this new `value` being inserted before the previously-found target event's index.
[m[31m-                            if index <= *i {
[m[31m-                                *i += 1;
[m[32m+                        VectorDiff::PopFront => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopFront"); }
[m[32m+                            clear_cache = true;
[m[32m+                            timeline_items.pop_front();
[m[32m+                            if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                *i = i.saturating_sub(1); // account for the first item being removed.
[m                             }
[31m-                        } else {
[m[31m-                            found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value))
[m[31m-                                .map(|(i, ev)| (i + index, ev));
[m[32m+                            // This doesn't affect whether we should reobtain the latest event.
[m                         }
[31m-
[m[31m-                        timeline_items.insert(index, value);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Insert at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Set { index, value } => {
[m[31m-                        index_of_first_change = min(index_of_first_change, index);
[m[31m-                        index_of_last_change  = max(index_of_last_change, index.saturating_add(1));
[m[31m-                        timeline_items.set(index, value);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Set at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Remove { index } => {
[m[31m-                        if index == 0 {
[m[31m-                            clear_cache = true;
[m[31m-                        } else {
[m[31m-                            index_of_first_change = min(index_of_first_change, index.saturating_sub(1));
[m[32m+                        VectorDiff::PopBack => {
[m[32m+                            timeline_items.pop_back();
[m[32m+                            index_of_first_change = min(index_of_first_change, timeline_items.len());
[m                             index_of_last_change = usize::MAX;
[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff PopBack. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                         }
[31m-                        if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[31m-                            // account for an item being removed before the previously-found target event's index.
[m[31m-                            if index <= *i {
[m[31m-                                *i = i.saturating_sub(1);
[m[32m+                        VectorDiff::Insert { index, value } => {
[m[32m+                            if index == 0 {
[m[32m+                                clear_cache = true;
[m[32m+                            } else {
[m[32m+                                index_of_first_change = min(index_of_first_change, index);
[m[32m+                                index_of_last_change = usize::MAX;
[m                             }
[32m+                            if index >= timeline_items.len() {
[m[32m+                                is_append = true;
[m[32m+                            }
[m[32m+
[m[32m+                            if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                // account for this new `value` being inserted before the previously-found target event's index.
[m[32m+                                if index <= *i {
[m[32m+                                    *i += 1;
[m[32m+                                }
[m[32m+                            } else {
[m[32m+                                found_target_event_id = find_target_event(&mut target_event_id, std::iter::once(&value))
[m[32m+                                    .map(|(i, ev)| (i + index, ev));
[m[32m+                            }
[m[32m+
[m[32m+                            timeline_items.insert(index, value);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Insert at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                         }
[31m-                        timeline_items.remove(index);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Remove at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[31m-                    }
[m[31m-                    VectorDiff::Truncate { length } => {
[m[31m-                        if length == 0 {
[m[31m-                            clear_cache = true;
[m[31m-                        } else {
[m[31m-                            index_of_first_change = min(index_of_first_change, length.saturating_sub(1));
[m[31m-                            index_of_last_change = usize::MAX;
[m[32m+                        VectorDiff::Set { index, value } => {
[m[32m+                            index_of_first_change = min(index_of_first_change, index);
[m[32m+                            index_of_last_change  = max(index_of_last_change, index.saturating_add(1));
[m[32m+                            timeline_items.set(index, value);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Set at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m                         }
[31m-                        timeline_items.truncate(length);
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Truncate to length {length}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                        VectorDiff::Remove { index } => {
[m[32m+                            if index == 0 {
[m[32m+                                clear_cache = true;
[m[32m+                            } else {
[m[32m+                                index_of_first_change = min(index_of_first_change, index.saturating_sub(1));
[m[32m+                                index_of_last_change = usize::MAX;
[m[32m+                            }
[m[32m+                            if let Some((i, _ev)) = found_target_event_id.as_mut() {
[m[32m+                                // account for an item being removed before the previously-found target event's index.
[m[32m+                                if index <= *i {
[m[32m+                                    *i = i.saturating_sub(1);
[m[32m+                                }
[m[32m+                            }
[m[32m+                            timeline_items.remove(index);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Remove at {index}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                        }
[m[32m+                        VectorDiff::Truncate { length } => {
[m[32m+                            if length == 0 {
[m[32m+                                clear_cache = true;
[m[32m+                            } else {
[m[32m+                                index_of_first_change = min(index_of_first_change, length.saturating_sub(1));
[m[32m+                                index_of_last_change = usize::MAX;
[m[32m+                            }
[m[32m+                            timeline_items.truncate(length);
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Truncate to length {length}. Changes: {index_of_first_change}..{index_of_last_change}"); }
[m[32m+                        }
[m[32m+                        VectorDiff::Reset { values } => {
[m[32m+                            if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Reset, new length {}", values.len()); }
[m[32m+                            clear_cache = true; // we must assume all items have changed.
[m[32m+                            timeline_items = values;
[m[32m+                        }
[m                     }
[31m-                    VectorDiff::Reset { values } => {
[m[31m-                        if LOG_TIMELINE_DIFFS { log!("timeline_subscriber: room {room_id} diff Reset, new length {}", values.len()); }
[m[31m-                        clear_cache = true; // we must assume all items have changed.
[m[31m-                        timeline_items = values;
[m[31m-                    }
[m                 }
[31m-            }
[m

[31m-            if num_updates > 0 {
[m[31m-                // Handle the case where back pagination inserts items at the beginning of the timeline
[m[31m-                // (meaning the entire timeline needs to be re-drawn),
[m[31m-                // but there is a virtual event at index 0 (e.g., a day divider).
[m[31m-                // When that happens, we want the RoomScreen to treat this as if *all* events changed.
[m[31m-                if index_of_first_change == 1 && timeline_items.front().and_then(|item| item.as_virtual()).is_some() {
[m[31m-                    index_of_first_change = 0;
[m[31m-                    clear_cache = true;
[m[31m-                }
[m[32m+                if num_updates > 0 {
[m[32m+                    // Handle the case where back pagination inserts items at the beginning of the timeline
[m[32m+                    // (meaning the entire timeline needs to be re-drawn),
[m[32m+                    // but there is a virtual event at index 0 (e.g., a day divider).
[m[32m+                    // When that happens, we want the RoomScreen to treat this as if *all* events changed.
[m[32m+                    if index_of_first_change == 1 && timeline_items.front().and_then(|item| item.as_virtual()).is_some() {
[m[32m+                        index_of_first_change = 0;
[m[32m+                        clear_cache = true;
[m[32m+                    }
[m
[31m-                let changed_indices = index_of_first_change..index_of_last_change;
[m[32m+                    let changed_indices = index_of_first_change..index_of_last_change;
[m
[31m-                if LOG_TIMELINE_DIFFS {
[m[31m-                    log!("timeline_subscriber: applied {num_updates} updates for room {room_id}, timeline now has {} items. is_append? {is_append}, clear_cache? {clear_cache}. Changes: {changed_indices:?}.", timeline_items.len());
[m[31m-                }
[m[31m-                timeline_update_sender.send(TimelineUpdate::NewItems {
[m[31m-                    new_items: timeline_items.clone(),
[m[31m-                    changed_indices,
[m[31m-                    clear_cache,
[m[31m-                    is_append,
[m[31m-                }).expect("Error: timeline update sender couldn't send update with new items!");
[m[32m+                    if LOG_TIMELINE_DIFFS {
[m[32m+                        log!("timeline_subscriber: applied {num_updates} updates for room {room_id}, timeline now has {} items. is_append? {is_append}, clear_cache? {clear_cache}. Changes: {changed_indices:?}.", timeline_items.len());
[m[32m+                    }
[m[32m+                    timeline_update_sender.send(TimelineUpdate::NewItems {
[m[32m+                        new_items: timeline_items.clone(),
[m[32m+                        changed_indices,
[m[32m+                        clear_cache,
[m[32m+                        is_append,
[m[32m+                    }).expect("Error: timeline update sender couldn't send update with new items!");
[m
[31m-                // We must send this update *after* the actual NewItems update,
[m[31m-                // otherwise the UI thread (RoomScreen) won't be able to correctly locate the target event.
[m[31m-                if let Some((index, found_event_id)) = found_target_event_id.take() {
[m[31m-                    target_event_id = None;
[m[31m-                    timeline_update_sender.send(
[m[31m-                        TimelineUpdate::TargetEventFound {
[m[31m-                            target_event_id: found_event_id.clone(),
[m[31m-                            index,
[m[31m-                        }
[m[31m-                    ).unwrap_or_else(
[m[31m-                        |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({found_event_id}, {index}) to room {room_id}!")
[m[31m-                    );
[m[32m+                    // We must send this update *after* the actual NewItems update,
[m[32m+                    // otherwise the UI thread (RoomScreen) won't be able to correctly locate the target event.
[m[32m+                    if let Some((index, found_event_id)) = found_target_event_id.take() {
[m[32m+                        target_event_id = None;
[m[32m+                        timeline_update_sender.send(
[m[32m+                            TimelineUpdate::TargetEventFound {
[m[32m+                                target_event_id: found_event_id.clone(),
[m[32m+                                index,
[m[32m+                            }
[m[32m+                        ).unwrap_or_else(
[m[32m+                            |_e| panic!("Error: timeline update sender couldn't send TargetEventFound({found_event_id}, {index}) to room {room_id}!")
[m[32m+                        );
[m[32m+                    }
[m[32m+
[m[32m+                    // Send a Makepad-level signal to update this room's timeline UI view.
[m[32m+                    SignalToUI::set_ui_signal();
[m                 }
[32m+            }
[m
[31m-                // Send a Makepad-level signal to update this room's timeline UI view.
[m[31m-                SignalToUI::set_ui_signal();
[m[32m+            else => {
[m[32m+                break;
[m             }
         }
[32m+    }
[m
[31m-        else => {
[m[31m-            break;
[m[31m-        }
[m[31m-    } }
[m[31m-
[m     error!("Error: unexpectedly ended timeline subscriber for room {room_id}.");
 }

Diff in /app/src/sliding_sync.rs:3551:
         _ => {
             if let Ok(room_members) = room.members(RoomMemberships::ACTIVE).await {
                 if room_members.len() == 2 {
[31m-                    if let Some(non_account_member) = room_members.iter().find(|m| !m.is_account_user()) {
[m[31m-                        if let Ok(Some(avatar)) = non_account_member.avatar(AVATAR_THUMBNAIL_FORMAT.into()).await {
[m[32m+                    if let Some(non_account_member) =
[m[32m+                        room_members.iter().find(|m| !m.is_account_user())
[m[32m+                    {
[m[32m+                        if let Ok(Some(avatar)) = non_account_member
[m[32m+                            .avatar(AVATAR_THUMBNAIL_FORMAT.into())
[m[32m+                            .await
[m[32m+                        {
[m                             return FetchedRoomAvatar::Image(avatar.into());
                         }
                     }
Diff in /app/src/sliding_sync.rs:3581:
     // Post a status update to inform the user that we're waiting for the client to be built.
     Cx::post_action(LoginAction::Status {
         title: "Initializing client...".into(),
[31m-        status: "Please wait while Matrix builds and configures the client object for login.".into(),
[m[32m+        status: "Please wait while Matrix builds and configures the client object for login."
[m[32m+            .into(),
[m     });

     // Wait for the notification that the client has been built
Diff in /app/src/sliding_sync.rs:3602:
         // or if the homeserver_url is *not* empty and isn't the default,
         // we cannot use the DEFAULT_SSO_CLIENT, so we must build a new one.
         let mut build_client_error = None;
[31m-        if client_and_session.is_none() || (
[m[31m-            !homeserver_url.is_empty()
[m[32m+        if client_and_session.is_none()
[m[32m+            || (!homeserver_url.is_empty()
[m                 && homeserver_url != "matrix.org"
                 && Url::parse(&homeserver_url) != Url::parse("https://matrix-client.matrix.org/")
[31m-                && Url::parse(&homeserver_url) != Url::parse("https://matrix.org/")
[m[31m-        ) {
[m[32m+                && Url::parse(&homeserver_url) != Url::parse("https://matrix.org/"))
[m[32m+        {
[m             match build_client(
                 &Cli {
                     homeserver: homeserver_url.is_empty().not().then_some(homeserver_url),
Diff in /app/src/sliding_sync.rs:3614:
                     ..Default::default()
                 },
                 app_data_dir(),
[31m-            ).await {
[m[32m+            )
[m[32m+            .await
[m[32m+            {
[m                 Ok(success) => client_and_session = Some(success),
                 Err(e) => build_client_error = Some(e),
             }
Diff in /app/src/sliding_sync.rs:3623:
         let Some((client, client_session)) = client_and_session else {
             Cx::post_action(LoginAction::LoginFailure(
                 if let Some(err) = build_client_error {
[31m-                    format!("Could not create client object. Please try to login again.\n\nError: {err}")
[m[32m+                    format!(
[m[32m+                        "Could not create client object. Please try to login again.\n\nError: {err}"
[m[32m+                    )
[m                 } else {
                     String::from("Could not create client object. Please try to login again.")
[31m-                }
[m[32m+                },
[m             ));
             // This ensures that the called to `DEFAULT_SSO_CLIENT_NOTIFIER.notified()`
             // at the top of this function will not block upon the next login attempt.
Diff in /app/src/sliding_sync.rs:3638:
         let mut is_logged_in = false;
         Cx::post_action(LoginAction::Status {
             title: "Opening your browser...".into(),
[31m-            status: "Please finish logging in using your browser, and then come back to Robrix.".into(),
[m[32m+            status: "Please finish logging in using your browser, and then come back to Robrix."
[m[32m+                .into(),
[m         });
         match client
             .matrix_auth()
Diff in /app/src/sliding_sync.rs:3648:
                     if key == "redirectUrl" {
                         let redirect_url = Url::parse(&value)?;
                         Cx::post_action(LoginAction::SsoSetRedirectUrl(redirect_url));
[31m-                        break
[m[32m+                        break;
[m                     }
                 }
[31m-                Uri::new(&sso_url).open().map_err(|err|
[m[31m-                    Error::Io(io::Error::other(format!("Unable to open SSO login url. Error: {:?}", err)))
[m[31m-                )
[m[32m+                Uri::new(&sso_url).open().map_err(|err| {
[m[32m+                    Error::Io(io::Error::other(format!(
[m[32m+                        "Unable to open SSO login url. Error: {:?}",
[m[32m+                        err
[m[32m+                    )))
[m[32m+                })
[m             })
             .identity_provider_id(&identity_provider_id)
             .initial_device_display_name(&format!("robrix-sso-{brand}"))
Diff in /app/src/sliding_sync.rs:3668:
             }) {
             Ok(identity_provider_res) => {
                 if !is_logged_in {
[31m-                    if let Err(e) = login_sender.send(LoginRequest::LoginBySSOSuccess(client, client_session)).await {
[m[32m+                    if let Err(e) = login_sender
[m[32m+                        .send(LoginRequest::LoginBySSOSuccess(client, client_session))
[m[32m+                        .await
[m[32m+                    {
[m                         error!("Error sending login request to login_sender: {e:?}");
                         Cx::post_action(LoginAction::LoginFailure(String::from(
[31m-                            "BUG: failed to send login request to matrix worker thread."
[m[32m+                            "BUG: failed to send login request to matrix worker thread.",
[m                         )));
                     }
                     enqueue_rooms_list_update(RoomsListUpdate::Status {
Diff in /app/src/sliding_sync.rs:3697:
     });
 }

[31m-
[m bitflags! {
     /// The powers that a user has in a given room.
     #[derive(Copy, Clone, PartialEq, Eq)]
Diff in /app/src/sliding_sync.rs:3775:
         retval.set(UserPowerLevels::Invite, user_power >= power_levels.invite);
         retval.set(UserPowerLevels::Kick, user_power >= power_levels.kick);
         retval.set(UserPowerLevels::Redact, user_power >= power_levels.redact);
[31m-        retval.set(UserPowerLevels::NotifyRoom, user_power >= power_levels.notifications.room);
[m[31m-        retval.set(UserPowerLevels::Location, user_power >= power_levels.for_message(MessageLikeEventType::Location));
[m[31m-        retval.set(UserPowerLevels::Message, user_power >= power_levels.for_message(MessageLikeEventType::Message));
[m[31m-        retval.set(UserPowerLevels::Reaction, user_power >= power_levels.for_message(MessageLikeEventType::Reaction));
[m[31m-        retval.set(UserPowerLevels::RoomMessage, user_power >= power_levels.for_message(MessageLikeEventType::RoomMessage));
[m[31m-        retval.set(UserPowerLevels::RoomRedaction, user_power >= power_levels.for_message(MessageLikeEventType::RoomRedaction));
[m[31m-        retval.set(UserPowerLevels::Sticker, user_power >= power_levels.for_message(MessageLikeEventType::Sticker));
[m[31m-        retval.set(UserPowerLevels::RoomPinnedEvents, user_power >= power_levels.for_state(StateEventType::RoomPinnedEvents));
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::NotifyRoom,
[m[32m+            user_power >= power_levels.notifications.room,
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Location,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Location),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Message,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Message),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Reaction,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Reaction),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::RoomMessage,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::RoomMessage),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::RoomRedaction,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::RoomRedaction),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::Sticker,
[m[32m+            user_power >= power_levels.for_message(MessageLikeEventType::Sticker),
[m[32m+        );
[m[32m+        retval.set(
[m[32m+            UserPowerLevels::RoomPinnedEvents,
[m[32m+            user_power >= power_levels.for_state(StateEventType::RoomPinnedEvents),
[m[32m+        );
[m         retval
     }

Diff in /app/src/sliding_sync.rs:3828:
     }

     pub fn can_send_message(self) -> bool {
[31m-        self.contains(UserPowerLevels::RoomMessage)
[m[31m-        || self.contains(UserPowerLevels::Message)
[m[32m+        self.contains(UserPowerLevels::RoomMessage) || self.contains(UserPowerLevels::Message)
[m     }

     pub fn can_send_reaction(self) -> bool {
Diff in /app/src/sliding_sync.rs:3846:
     }
 }

[31m-
[m /// Shuts down the current Tokio runtime completely and takes ownership to ensure proper cleanup.
 pub fn shutdown_background_tasks() {
     if let Some(runtime) = TOKIO_RUNTIME.lock().unwrap().take() {
Diff in /app/src/sliding_sync.rs:3864:
     ALL_JOINED_ROOMS.lock().unwrap().clear();

     let on_clear_appstate = Arc::new(Notify::new());
[31m-    Cx::post_action(LogoutAction::ClearAppState { on_clear_appstate: on_clear_appstate.clone() });
[m[31m-
[m[31m-    match tokio::time::timeout(config.app_state_cleanup_timeout, on_clear_appstate.notified()).await {
[m[32m+    Cx::post_action(LogoutAction::ClearAppState {
[m[32m+        on_clear_appstate: on_clear_appstate.clone(),
[m[32m+    });
[m[32m+
[m[32m+    match tokio::time::timeout(
[m[32m+        config.app_state_cleanup_timeout,
[m[32m+        on_clear_appstate.notified(),
[m[32m+    )
[m[32m+    .await
[m[32m+    {
[m         Ok(_) => {
             log!("Received signal that UI-side app state was cleaned successfully");
             Ok(())
